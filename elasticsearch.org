#+TITLE: elasticsearch
#+AUTHOR: lujun9972
#+TAGS: .
#+DATE: [2017-05-25 四 15:10]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* analyze
它是将文本块转换为有区别的、规范化的 token 的一个过程，目的是为了（a）创建倒排索引以及（b）查询倒排索引。 
#+BEGIN_EXAMPLE
  GET /my_index/_analyze
  {
    "field": "productID",
    "text": "XHDK-A-1293-#fJ3"
  }
#+END_EXAMPLE

* 搜索

** 精确搜索
当进行精确值查找时， 我们会使用过滤器（filters）。过滤器很重要，因为它们执行速度非常快，不会计算相关度（直接跳过了整个评分阶段）而且很容易被缓存。

*** term查询
我们首先来看最为常用的 term 查询， 可以用它处理数字（numbers）、布尔值（Booleans）、日期（dates）以及文本（text）。
erm 查询会查找我们指定的精确值。作为其本身， term 查询是简单的。它接受一个字段名以及我们希望查找的数值：

#+BEGIN_EXAMPLE
  {
      "term" : {
          "price" : 20
      }
  }
#+END_EXAMPLE

通常当查找一个精确值的时候，我们不希望对查询进行评分计算。只希望对文档进行包括或排除的计算，所以我们会使用 constant_score 查询以非评分模式来执行 term 查询并以一作为统一评分。

例如：
#+BEGIN_EXAMPLE
  GET /my_store/products/_search
  {
      "query" : {
          "constant_score" : { 
              "filter" : {
                  "term" : { 
                      "price" : 20
                  }
              }
          }
      }
  }
#+END_EXAMPLE

相当于

#+BEGIN_SRC sql
  SELECT *
  FROM   products
  WHERE  price = 20
#+END_SRC

*** terms查询
terms查询可以一次查找多个精确指，它几乎与 term 的使用方式一模一样，与指定单个价格不同，我们只要将 term 字段的值改为数组即可：

#+BEGIN_EXAMPLE
  {
      "terms" : {
          "price" : [20, 30]
      }
  }
#+END_EXAMPLE

例如
#+BEGIN_EXAMPLE
  GET /my_store/products/_search
  {
      "query" : {
          "constant_score" : {
              "filter" : {
                  "terms" : { 
                      "price" : [20, 30]
                  }
              }
          }
      }
  }
#+END_EXAMPLE

类似于

#+BEGIN_SRC sql
  SELECT *
  FROM   products
  WHERE  price = in (20,30)
#+END_SRC

*term 和 terms 是 必须包含（must contain） 操作，而不是 必须精确相等（must equal exactly）*

如果我们有一个 term（词项）过滤器 { "term" : { "tags" : "search" } } ，它会与以下两个文档 同时 匹配：

#+BEGIN_EXAMPLE
  { "tags" : ["search"] }
  { "tags" : ["search", "open_source"] } 
#+END_EXAMPLE

尽管第二个文档包含除 search 以外的其他词，它还是被匹配并作为结果返回。 

*** range查询
可以用它来查找处于某个范围内的文档：

**** 数字范围
#+BEGIN_EXAMPLE
  "range" : {
      "price" : {
          "gte" : 20,
          "lte" : 40
      }
  }
#+END_EXAMPLE

+ gt :: > 大于（greater than）
+ lt :: < 小于（less than）
+ gte :: >= 大于或等于（greater than or equal to）
+ lte :: <= 小于或等于（less than or equal to） 
         
例如
#+BEGIN_EXAMPLE
  GET /my_store/products/_search
  {
      "query" : {
          "constant_score" : {
              "filter" : {
                  "range" : {
                      "price" : {
                          "gte" : 20,
                          "lt"  : 40
                      }
                  }
              }
          }
      }
  }
#+END_EXAMPLE

相当于

#+BEGIN_SRC sql
  select * from products where price >=20 and price<40
#+END_SRC

**** 日期范围
ange 查询同样可以应用在日期字段上：

#+BEGIN_EXAMPLE
  "range" : {
      "timestamp" : {
          "gt" : "2014-01-01 00:00:00",
          "lt" : "2014-01-07 00:00:00"
      }
  }
#+END_EXAMPLE

当使用它处理日期字段时， range 查询支持对 日期计算（date math） 进行操作，比方说，如果我们想查找时间戳在过去一小时内的所有文档：

#+BEGIN_EXAMPLE
  "range" : {
      "timestamp" : {
          "gt" : "now-1h"
      }
  }
#+END_EXAMPLE
日期计算还可以被应用到某个具体的时间，并非只能是一个像 now 这样的占位符。只要在某个日期后加上一个双管符号 (||) 并紧跟一个日期数学表达式就能做到：

#+BEGIN_EXAMPLE
  "range" : {
      "timestamp" : {
          "gt" : "2014-01-01 00:00:00",
          "lt" : "2014-01-01 00:00:00||+1M" 
      }
  }
#+END_EXAMPLE

**** 字符串范围
range 查询同样可以处理字符串字段
#+BEGIN_EXAMPLE
  "range" : {
      "title" : {
          "gte" : "a",
          "lt" :  "b"
      }
  }
#+END_EXAMPLE

*** exists查询
这个查询会返回那些在指定字段有任何值的文档

例如：
#+BEGIN_EXAMPLE
  GET /my_index/posts/_search
  {
      "query" : {
          "constant_score" : {
              "filter" : {
                  "exists" : { "field" : "tags" }
              }
          }
      }
  }
#+END_EXAMPLE

类似于

#+BEGIN_SRC sql
  select * from posts where tags is not null
#+END_SRC


*** missing查询
missing 查询本质上与 exists 恰好相反： 它返回某个特定 _无_ 值字段的文档:

例如：
#+BEGIN_EXAMPLE
  GET /my_index/posts/_search
  {
      "query" : {
          "constant_score" : {
              "filter": {
                  "missing" : { "field" : "tags" }
              }
          }
      }
  }
#+END_EXAMPLE

类似于

#+BEGIN_SRC sql
  select * from posts where tags is null
#+END_SRC

注意： *我们不能判断是一个字段有明确的null值，还是根本没有这个字段*

*** 布尔过滤器
一个 bool 过滤器由三部分组成：
#+BEGIN_EXAMPLE
  {
     "bool" : {
        "must" :     [],
        "should" :   [],
        "must_not" : [],
     }
  }
#+END_EXAMPLE

+ must :: 所有的语句都 必须（must） 匹配，与 AND 等价。 
+ must_not :: 所有的语句都 不能（must not） 匹配，与 NOT 等价。 
+ should :: 至少有一个语句要匹配，与 OR 等价。 
            
例如：
#+BEGIN_EXAMPLE
  GET /my_store/products/_search
  {
     "query" : {
        "filtered" : { 
           "filter" : {
              "bool" : {
                "should" : [
                   { "term" : {"price" : 20}}, 
                   { "term" : {"productID" : "XHDK-A-1293-#fJ3"}} 
                ],
                "must_not" : {
                   "term" : {"price" : 30} 
                }
             }
           }
        }
     }
  }
#+END_EXAMPLE

相当于：

#+BEGIN_SRC sql
  SELECT *
  FROM   products
  WHERE  (price = 20 OR productID = "XHDK-A-1293-#fJ3")
  AND  (price != 30)
#+END_SRC

*** 嵌套布尔过滤器
尽管 bool 是一个复合的过滤器，可以接受多个子过滤器，需要注意的是 bool 过滤器本身仍然还只是一个过滤器。
这意味着我们可以将一个 bool 过滤器置于其他 bool 过滤器内部，这为我们提供了对任意复杂布尔逻辑进行处理的能力。

例如
#+BEGIN_EXAMPLE
  GET /my_store/products/_search
  {
     "query" : {
        "filtered" : {
           "filter" : {
              "bool" : {
                "should" : [
                  { "term" : {"productID" : "KDKE-B-9947-#kL5"}}, 
                  { "bool" : { 
                    "must" : [
                      { "term" : {"productID" : "JODL-X-1937-#pV7"}}, 
                      { "term" : {"price" : 30}} 
                    ]
                  }}
                ]
             }
           }
        }
     }
  }
#+END_EXAMPLE

类似于

#+BEGIN_SRC sql
  SELECT *
  FROM   products
  WHERE  productID      = "KDKE-B-9947-#kL5"
  OR (     productID = "JODL-X-1937-#pV7"
  AND price     = 30 )
#+END_SRC

** 全文查询
像 match 或 query_string 这样的查询是高层查询，它们了解字段映射的信息：

+ 如果查询 日期（date） 或 整数（integer） 字段，它们会将查询字符串分别作为日期或整数对待。
+ 如果查询一个（ not_analyzed ）未分析的精确值字符串字段， 它们会将整个查询字符串作为单个词项对待。
+ 但如果要查询一个（ analyzed ）已分析的全文字段， 它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表。

*** match查询
match查询既能处理全文字段，又能处理精确字段。match 查询主要的应用场景就是进行全文搜索。

#+BEGIN_EXAMPLE
  GET /my_index/my_type/_search
  {
      "query": {
          "match": {
              "title": "QUICK! DOG"
          }
      }
  }
#+END_EXAMPLE

Elasticsearch 执行上面这个 match 查询的步骤是：

+ 检查字段类型 。

  标题 title 字段是一个 string 类型（ analyzed ）已分析的全文字段，这意味着查询字符串本身也应该被分析。

+ 分析查询字符串 。
  
  将查询的字符串 "QUICK! DOG" 传入标准分析器中，输出的结果是["brown","dog"]。因为 match 查询必须查找两个词（ ["brown","dog"] ），它在内部实际上先执行两次 term 查询，然后将两次查询的结果合并作为最终结果输出。

+ 为每个文档评分 。

  用 term 查询计算每个文档相关度评分 _score ，这是种将 词频（term frequency，即词 quick 在相关文档的 title 字段中出现的频率）和反向文档频率（inverse document frequency，即词 quick 在所有文档的 title 字段中出现的频率），以及字段的长度（即字段越短相关度越高）相结合的计算方式。参见 相关性的介绍 。

  
任何文档只要字段里包含 指定词项中的至少一个词 就能匹配，被匹配的词项越多，文档就越相关.
那么，如果我们只想搜索包含 所有 词项的文档，也就是说，不去匹配 brown OR dog ，而通过匹配 brown AND dog 找到所有文档该怎么办呢？

match 查询还可以接受 *operator* 操作符作为输入参数，默认情况下该操作符是 or 。我们可以将它修改成 and 让所有指定词项都必须匹配：
#+BEGIN_EXAMPLE
  GET /my_index/my_type/_search
  {
      "query": {
          "match": {
              "title": {      
                  "query":    "BROWN DOG!",
                  "operator": "and"
              }
          }
      }
  }
#+END_EXAMPLE

match 查询支持 *minimum_should_match* 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量：
#+BEGIN_EXAMPLE
  GET /my_index/my_type/_search
  {
    "query": {
      "match": {
        "title": {
          "query":                "quick brown dog",
          "minimum_should_match": "75%"
        }
      }
    }
  }
#+END_EXAMPLE

*** bool查询
bool查询与bool过滤器功能类似，但是它除了决定一个文档是否应该被包括在结果中，还会计算文档的相关程度 。

与过滤器一样， bool 查询也可以接受 must 、 must_not 和 should 参数下的多个查询语句。比如：
#+BEGIN_EXAMPLE
  GET /my_index/my_type/_search
  {
    "query": {
      "bool": {
        "must":     { "match": { "title": "quick" }},
        "must_not": { "match": { "title": "lazy"  }},
        "should": [
                    { "match": { "title": "brown" }},
                    { "match": { "title": "dog"   }}
        ]
      }
    }
  }
#+END_EXAMPLE

bool查询与bool过滤器的区别就在于两个 *should* 语句的意义，也就是说：一个文档不必包含 brown 或 dog 这两个词项，但如果一旦包含，我们就认为它们 更相关.

所有 must 语句必须匹配，所有 must_not 语句都必须不匹配，没有 should 语句是必须匹配的，
只有一个例外：*那就是当没有 must 语句的时候，至少有一个 should 语句必须匹配*

我们可以通过 *minimum_should_match* 参数控制需要匹配的 should 语句的数量， 
它既可以是一个绝对的数字，又可以是个百分比：

#+BEGIN_EXAMPLE
  GET /my_index/my_type/_search
  {
    "query": {
      "bool": {
        "should": [
          { "match": { "title": "brown" }},
          { "match": { "title": "fox"   }},
          { "match": { "title": "dog"   }}
        ],
        "minimum_should_match": 2 
      }
    }
  }
#+END_EXAMPLE

