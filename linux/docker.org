#+TITLE: docker
#+AUTHOR: DarkSun
#+CATEGORY: linux
#+DATE: [2016-03-22 周二 14:15]
#+OPTIONS: ^:{}
* docker基础说明
** docker images
image是用于创建container的一个静态模板.
** docker registries
用于管理docker image的地方叫做docker registry.

当我们创建了自己的image之后,就可以使用push命令将之上传docker registry.
下次要在另一个机器上使用这个image时,只需要从仓库上pull下来就行了.
** docker containers
container从image创建. 它可以被启动,开始,停止,删除. 每个容器都是相互隔离,安全的平台.

当我们运行 ~docker run -i -t ubunut /bin/bash~ 时,docker在后台运行的操作如下:

1. 如果本地没有ubuntu这个image,则从公有仓库下载
2. 从image创建容器
3. 分配一个文件系统,并在只读的image层外挂载一层可读写的层
4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
5. 从地址池中配置一个ip地址給容器
6. 执行指定的程序,这里是/bin/bash
7. -i -t 指定标准输入和输出
* docker使用说明
** docker image相关命令
*** 显示本机上的images
#+BEGIN_SRC sh
    sudo docker images
#+END_SRC

在列出的信息中可以看到3个字段信息
  1. 来自哪个仓库
  2. tag标签
  3. 镜像的id号
     
  一个仓库可能有一个image的多个发行版,这样就需要使用tag来指定image. 使用tag的方法是在image后加上冒号和tag: 例如 ~sudo docker run -t -i ubunut:latest /bin.bash~
  
*** 查找images

docker hub上有很多人创建的各种不同的images. 使用 ~docker search~ 来搜索合适的image. 例如
#+BEGIN_SRC sh
    sudo docker search emacs
#+END_SRC

可以看到返回的信息包括image名称,描述,受欢迎程度,是否官方创建,是否自动创建的信息.

*** 获取images

我们可以使用 ~docker pull~ 命令来预先下载我们需要的image
#+BEGIN_SRC sh
    sudo docker pull ubuntu
#+END_SRC

*** 创建自己的image
有两种方法创建自己的image:

+ 使用 ~docker commit~ 扩展一个image

  1. 先使用 ~docker run~ 根据image启动容器
     #+BEGIN_SRC sh
       sudo docker run -t -i ubuntu /bin/bash
     #+END_SRC

  2. 对容器做出修改后,使用 ~docker commit~ 提交结果到新的image
     #+BEGIN_SRC sh
       # sudo docker commit -m="新容器提交信息" -a="新容器作者" 容器ID 新image名称
       sudo docker commit -m="Installed ruby" -a="darksun" 0b2616b0e5a8 lujun9972/ruby:v2
     #+END_SRC
     
+ 从Dockerfile创建
  
  使用docker commit来扩展一个image比较简单,但它不容易在一个团队中分享它. 

  我们还可以使用 ~docker build~ 来根据dockerfile创建一个新image

  1. 创建一个目录和一个dockerfile
     #+BEGIN_SRC sh
       mkdir ruby
       cd ruby
       touch Dockerfile
       echo "#this is a comment
       FROM ubuntu:latest
       MAINTAINER darksun <lujun9972@gmail.com>
       RUN apt-get -qqy update;exit 0
       RUN apt-get -qqy install ruby ruby-dev
       RUN gem install sinatra" > Dockerfile
     #+END_SRC

     #+RESULTS:

  2. 使用 ~docker build~ 来根据dockerfile创建image
     #+BEGIN_SRC sh
       sudo docker build -t="lujun9972/ruby:v2"
     #+END_SRC
     使用-t标记来指定新的image名称及tag

     我们可以看到dockfile中的指令被一条条的执行了. 每一步都创建了一个新的容器,当所有的指令都执行完毕之后,返回一个image id,并且所有的中间步骤所产生的容器都被删除和清理了.

     *注意:一个image不能超过127层*

*** 上传images到公共images仓库
使用docker push上传images
#+BEGIN_SRC sh
  sudo docker push lujun9972/ruby
#+END_SRC

需要注意的是: *若仓库实现了角色控制,则上传前需要使用docker login先登录,下载则无需先登录*

*** 删除本地images
使用 ~docker rmi~ 可以删除本地images
#+BEGIN_SRC sh
  sudo docker rmi lujun9972/ruby
#+END_SRC

** docker container相关命令

** docker中的网络介绍

*** docker网络相关的命令列表

+ -b BRIDGE / --bridge=BRIDGE :: 桥接配置
+ --bip=CIDR :: 定制docker0的掩码
+ -H SOCKET / --host=SOCKET :: 告诉docker从哪个通道来接受控制container的命令,即指定docker api的地址
+ --icc=true|false :: 
+ --ip-forward=true|false ::
+ --iptables=true|false ::
+ --mtu=BYTES :: 指定MTU-接口允许接受的最大传输单元
+ --dns=IP_ADDRESS :: 设定DNS服务器IP
+ --dns-search=DOMAIN :: 设定容器的搜索域
+ -h HOSTNAME / --hostname=HOSTNAME :: 主机配置
+ --link=CONTAINER_NAME:ALIAS :: 与其他容器进行互联,其中其他容器在容器中以ALIAS为名
+ --net=bridge|none|container:NAME_OR_ID|host :: 桥接配置
+ -p SPEC / --publish=SPEC :: 映射容器端口到宿主主机
+ -P / --publish-all=true|false :: 映射容器端口到宿主主机

*** docker创建容器网络的过程

1. 创建一对虚拟接口

2. 宿主主机一端使用一个名字比如veth65f9,它是唯一的. 另外一端桥接到默认的docker0,或其他指定的桥接网卡

3. 主机上的veth65f9这种接口映射到新的新容器中的名称,通常为eth0. 在容器这个隔离的network namespace中它是唯一的.

4. 从主机桥接网卡的地址中获取一个空闲地址給eth0使用,并设定默认路由到桥接网卡

5. 完成这些后,容器可以使用eth0虚拟网卡来连接其他容器和其他网络了

可以为特殊容器设置特定的参数:

+ --net=bridge

  连接到默认的docker0网桥

+ --net=host

  告诉docker不要将容器放到隔离的网络堆栈中,即容器直接使用host相同的网络

+ --net=container:NAME_OR_ID

  告诉docker将新容器进程放到一个已存在容器的网络堆栈中,两者共享ip地址和端口,他们之间还可以通过环回接口通信

+ --net=none

  告诉docker将新容器放在自己的网络堆栈中,但是不要配置它的网络. 其类似vmware的host-only,可以让你创建任何自定义的配置.

*** 配置DNS

docker通过使用host主机上的 ~/etc/hostname~, ~/etc/hosts~, ~/etc/resolv.conf~ 覆盖容器中的这三个文件,这样方式来为容器提供主机和DNS配置.

docker提供了一些选项来动态的配置他们:

+ -h HOSTNAME / --hostname-HOSTNAME

  设定容器的主机名,它会被写到/etc/hostname, /etc/hosts中的ip地址自动写成分配的ip地址, 在/bin/bash中显示该主机名.

  但它不会在docker ps中显示,也不会再其他的容器的/etc/hosts中显示

+ --link=CONTAINER_NAME:ALLIAS

  该选项会在创建容器时时候添加一个其他容器CONTAINER_NAME的主机到/etc/hosts文件中, 让新容器的进程可以使用主机名ALIAS就可以连接它.

+ --dns=IP_ADDRESS

  添加dns服务器到容器的/etc/resolv.conf中,让容器用这ip地址来解析所有不在/etc/hosts中的主机名

+ --dns-search=DOMAIN

  设定容器的搜索域, 例如,当搜索域为.example.com时,会在搜索host主机名时,DNS不仅搜索host,还会搜索host.example.com

*** 映射内部容器端口到host端口
默认情况下,容器可以建立到外部网络的连接,但是外部网络无法连接到容器.

若向容器接受外部连接,则需要在docker run执行的时候就指定对应选项

+ -P --publish-all=true|false

  该选项会映射dockerfile中expose的所有端口,对应的主机端口在49000-49900中随机选择.

+ -p SPEC / --publish=SPEC

  可以指定任意端口从主机映射容器内部

  其中SPEC的格式为 ~[IP:]host-port:container-port~

*docker默认映射了0.0.0.0,标示它接受主机上的所有接口地址. 可以通过 ~-p IP:host_port:container_port~ 或 ~-p IP::port~ 来指定主机上的ip接口*

*如果希望永久改变绑定的主机ip地址,可以在docker配置中指定--ip=IP_ADDRESS*

*** 定制docker0
docker服务默认会创建一个docker0接口,用于在linux内核层桥接所有容器的虚拟网卡和host物理网卡.

docker允许指定docker0的ip地址和子网掩码,还能定义MTU(接口允许接受的最大传输单元)

+ --bip=CIDR

  其中CIDR的格式为 ~IP地址/掩码~ (例如192.168.1.5/24)

+ --mtu=BYTES

  设定MTU大小为BYTES字节,

*可以在docker配置文件中配置DOCKER_OPTS,然后重启来改变这些参数*

当容器启动后,可以使用brctl来确认他们是否已经连接到docker0网桥
#+BEGIN_SRC sh
  sudo brctl show
#+END_SRC

*** 创建自己的桥接
如果希望完全使用自己的桥接设置,可以在启动docker服务的时候,使用 ~-b BRIDGE~ 或 ~--bridge=BRIDGE~ 来告诉docker使用哪个网桥.

如果服务已经启动,旧的网桥还在使用中,那需要先停止服务,再删除旧的网桥

1. 停止旧网桥并删除
   #+BEGIN_SRC sh
     sudo service docker stop
     sudo ip link set dev docker0 down
     sudo brctl delbr docker0
   #+END_SRC

2. 创建自己的网桥
   #+BEGIN_SRC sh
     sudo brctl addbr bridge0
     sudo ip addr add 192.168.5.1/24 dev bridge0
     sudo ip link set dev bridge0 up
   #+END_SRC

3. 确认网桥启动
   #+BEGIN_SRC sh
     ip addr show bridge0
   #+END_SRC

4. 告诉docker桥接设置,并启动docker服务
   #+BEGIN_SRC sh
     echo 'DOCKER_OPTS="-b=bridge0"'>>/etc/default/docker
     sudo service docker start
   #+END_SRC

*** 容器间互联

** Docker数据管理

*** Data Volumes

*** Data Volumes Container

** 搭建自己的私有仓库
* Dockerfile编写说明
