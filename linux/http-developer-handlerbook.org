#+TITLE: http-developer-handlerbook
#+AUTHOR: Administrator
#+TAGS: linux
#+DATE: [2017-01-01 周日 11:16]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* HTTP Definition

** HTTP Requests

*** Request语法
一个http request由三个基础部分组成:

+ Request行
+ HTTP头部
+ 请求内容

HTTP请求的第一行一定是"request"说明行,这一行指明了请求的方法,请求的资源以及使用的HTTP版本号. 
这三个部分使用空格分隔, 像这样:
#+BEGIN_EXAMPLE
GET /index.html HTTP/1.1
#+END_EXAMPLE

HTTP请求的第二部分是HTTP的头部. 它提供了很多关于request的信息. 一般将HTTP header分成三种:

+ General headers :: 那些即可以用于response也可以用于request的头信息.
+ Request headers :: 那些只可以用于request的头信息.
+ Entity headers :: 关于content本身的相关信息.

*** Request Methods
HTTP/1.1总共定义了8种request method,分别是:

+ GET
+ POST
+ PUT :: 用于发送要保存到server上的内容,此时request line中请求的resource表示要修改/保存内容的地址. 
     若成功保存了内容,则服务器会返回 =201 Created=, 若请求的地址已经存在,则返回 =200 OK= 或 =204 No Content=.
+ DELETE :: 删除request line中的resource
+ HEAD :: 与GET类似,但是不要求server返回content
+ TRACE :: 用于诊断客户端与服务器之间经过多少个中间代理,每个中间代理都会把自己添加到 =Via= header中. 而server回应的content,则就是其接收到的request.
+ OPTIONS :: 用于探测web server有哪些能力. 此时request line中的resource并不重要,可以使用 =*= 代替.
+ CONNECT :: 该method保留给中间人服务器来创建与目标服务器之间的通道. 通道对于客户端和服务器来说都是透明的.

*** Request Headers
Request headers只是那些只于请求相关的header,也就是说这些header既不能用于response,也跟content毫无关系.

HTTP/1.1 定义了19种request header,除此之外还有一个很常见的request header: =Cookie=

**** Accpet
=Accept= 主要是通知Web服务器客户端可以接受哪些类型的内容,以及各种内容类型的优先级.

一个 =Accept= header看起来是这样的:
#+BEGIN_EXAMPLE
  Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9, 
          text/plain;q=0.8, video/x-mng,image/png,image/jpeg,image/gif;q=0.2, 
          text/css,*/*;q=0.1 
#+END_EXAMPLE

其中 =q= 后面的值表示优先级,范围从1到0.

=q= 前面的值是content type列表. 每个content type都分成type和subtype两个部分,每个部分都能用 =*= 表示通配.

若服务器不能满足 =Accept= 的要求,那么它应该返回 =406 Not Acceptable=

*所有的Accept家族语法都很类似*

**** Accept-Charset
=Accept-Charset= 通知server,client支持哪些字符编码格式,以及各种编码格式的优先级:

#+BEGIN_EXAMPLE
  Accept-Charset: ISO-8859-1, utf-8;q=0.66, *;q=0.66 
#+END_EXAMPLE

这里 =*= 表示允许任意的编码格式. 虽然 =*= 与 =ISO-8859-1和utf-8= 的优先级一样,不过由于它们被明确指定了,因此它们的优先级还是要高一点.

另外, *不管内容的编码格式会是什么,但是HTTP消息本身是用 =ISO-8859-1= 来编码的*.

**** Accept-Encoding
=Accept-Encoding= 指明了client支持对内容进行何种编码转换的方式.比如用gzip进行压缩.

*它与 =Accept-Charset= 是完全不同的*

**** Accept-Language
=Accept-Language= 指明了用户偏好哪种语言.

#+BEGIN_EXAMPLE
  Accept-Language: en 
#+END_EXAMPLE

**** Authorization
=Authorization= 提供了一种客户端认证的方法.

当client不带 =Authorization= header访问敏感信息时,server会返回一个 =401 Unauthorized= 回应给浏览器,浏览器就会提示用户输入用户名和密码.

由于HTTP本身是无状态的,因此浏览器在之后的每次访问,都需要附上正确的 =Authorization= header.

**** Cookie
Cookie是实现HTTP状态管理至关重要的一种方法. 

Client通过 =Cookie= headr将保存到cookie中的信息传递回server. 一个Cookie header看起来是这样的:

#+BEGIN_EXAMPLE
  Cookie: fname=chris; lname=shiflett 
#+END_EXAMPLE

**** Expect
=Expect= header告诉server需要符合哪些预期,若server无法满足这些预期则需要返回 =417 Expectation Failed= 回应.

此外,中间代理也需要检查自己是否满足这些预期,否则也需要返回 =417 Expectation Failed=

**** From
=From= 告诉server用户的email地址是什么,这个基本没什么用.

#+BEGIN_EXAMPLE
  From: chris@http.org 
#+END_EXAMPLE

**** Host

在同一个IP上有多个hosts的情况下, =Host= 指明要访问的是哪个host上的资源.

#+BEGIN_EXAMPLE
  Host: www.google.com:8080 
#+END_EXAMPLE

**** If-Match
判断request line中请求的资源是否与 =If-Match= header中指定的签名一致. 

=If-Match= 中使用的签名来自于server response 的 =ETag= (即entity tag的缩写) header.

=If-Match= 常用来判断资源自上次请求以来是否发生了改变. 因此在判断cache是否失效和解决多client修改server时同步问题时非常有用.

若 =If-Match= 中的签名与资源不匹配了,则server返回 =412,Precondition Failed=

**** If-Modified-Since
=If-Modified-Since= 咨询server请求的资源自某个时间以来是否发生了改变.

若请求的资源美誉发生改变,则server返回 =304 Not Modified=

需要注意的时, *由于时间的比较是在sever端发生的,因此这个时间必须使用 =Last-Modified= response header中的值*.

**** If-None-Match
=If-None-Match= 正好与 =If-Match= 相反,

当 =If-None-Match= 应用于 =GET= 和 =HEAD= method时,server返回 =304 Not Modified=,否则server返回 =412 Precondition Failed=.

**** If-Range
通过 =If-Range= 和 =Range=, client可以只申请它缺失的那部分资源内容,而无需申请整个的资源.

#+BEGIN_EXAMPLE
  If-Range: "df6b0-b4a-3be1b5e1" 
  If-Range: Tue, 21 May 2002 12:34:56 GMT 
#+END_EXAMPLE

**** If-Unmodified-Since
=If-Modified-Since= 的反义词,若资源自那以后被修改过了,则server返回 =412 Precondition Failed= 错误

**** Max-Forwards
指定最多只能经过多少个内部代理的转发. 每次代理转发报文时都会对 =Max-Forwards= 的值减一.

当代理收到 =Max-Forwards= 为0的请求时会立即回应client而不会转发请求给server.

**** Proxy-Authorization
=Proxy-Authorization= 与 =Authorization= 的用法一样,不同点在于它只能在代理商作验证.

**** Range
通过指定期望接受的字节范围, =Range= 可以抓取资源的部分内容.

若server不支持Range header或Rage header的值不合法,则server可以返回完整的内容

#+BEGIN_EXAMPLE
  Range: 0-499
  Range: bytes 0-499, 1000-1499 
  Range: -1000
  Range: 500-
#+END_EXAMPLE
 
若server成功返回部分内容,则返回 =206 Partial Content=

**** Referer
=Referer= header允许客户端指定自己当前的location.

该header常用于追踪用户的访问轨迹的.

假设你在 =http://127.0.0.1= 上有一个链接连接的是远程URL,那么访问这个连接可能会包含这么个 =Referer= header
#+BEGIN_EXAMPLE
  Referer: http://127.0.0.1/ 
#+END_EXAMPLE

**** TE
=TE= 的语法跟 =Accept-Encoding= 一样. but it references the types of transfer encodings it can accept rather than content encodings

**** User-Agent
=User-Agent= 用来标识浏览器本身. 

#+BEGIN_EXAMPLE
  User-Agent: Mozilla/5.0 Galeon/1.2.0 (X11; Linux i686; U;) Gecko/20020326 
#+END_EXAMPLE

** HTTP Responses

*** Response语法

Response也可以被分成三个部分:

+ Status line
  
  其中status line看起来是这样的:
  #+BEGIN_EXAMPLE
    HTTP/1.1 200 OK
  #+END_EXAMPLE

  其中包含了三个元素: 所使用的HTTP协议版本 =HTTP/1.1=,状态码 =200=,以及状态码的简单描述 =OK=.

+ HTTP headers
  
  在response中也分三种HTTP header:

  - General headers

  - Response headers

  - Entity headers

+ Content
  


*** Response状态码
Response的状态码被分成以下几个组:

+ Informational (100-199)
+ Successful (200-299)
+ Redirection (300-399)
+ Client error (400-499)
+ Server error(500-599)

*** Response headers

**** Accept-Ranges
=Accept-Range= 告诉client,server能够处理client发起的range请求.

=Accept-Range= 只有两种合法的格式,分别用于表示是/否接受range请求
#+BEGIN_EXAMPLE
  Accept-Ranges: bytes 
  Accept-Ranges: none 
#+END_EXAMPLE

**** Age
=Age= 说明了所请求的资源自上次请求以来至今经过了多少秒.

由于网络延时能够显著影响 =Age= 的值,因此每经过一个代理可能都需要重新计算依次 =age= 的值.

**** Authentication-Info
=Authentication-Info= 是HTTP数字验证的最后一步. 该header能让client验证Web server的身份.

=Authentication-Info= 的值是一个由逗号分隔的键值对列表:
#+BEGIN_EXAMPLE
  Authentication-Info: qop="auth-int", rspauth="5913ebca817739aebd2655bcfb952d52",
                       cnonce="f5e2d7c0b6a7f2e3d2c4b5a4f7e4d8c8b7a", nc="00000001"
#+END_EXAMPLE

其中各参数的意义如下:

+ cnonce :: 这个值与client请求中 =Authorization= header中 =cnonce= 参数的值相等.
+ nc :: 这个值与client请求中 =Authorization= header中 =nc= 参数的值相等.
+ qop :: 这个值与client请求中 =Authorization= header中 =qop= 参数的值相等.
+ nextnonce :: server要求client在以后的HTTP请求中用这个参数指定的值作为 =Authorizatioin= 中 =nonce= 的值
+ rspauth :: server的数字签名,用于验证server身份.

**** Content-Disposition
=Content-DIsposition= 用于建议client保存文件时使用的用户名.

#+BEGIN_EXAMPLE
  Content-Disposition: attachment; filename="example.pdf"
#+END_EXAMPLE

**** ETag
=Etag= 用于标示某资源某一版本的签名. 它常用于决定缓冲中的资源副本是否已经过时.

ETag headr有两种格式:

1. strong entity tag:
   #+BEGIN_EXAMPLE
     ETag: "xxxxxx"
   #+END_EXAMPLE
     
   这种格式表示ETag保证对该资源的每个存在过的版本都有唯一的一个标示.

2. week entity tag:
   #+BEGIN_EXAMPLE
     ETag: W/"xxxxxxx"
   #+END_EXAMPLE
     
   这种格式比较少见,它不保证每个版本都会有一个唯一标示, 它只说当版本间存在巨大改变时会有不同的标示.

**** Location
=Location= 告诉客户端需要访问哪个地址才能获取需要的资源. 常用于redirection
#+BEGIN_EXAMPLE
  Location: http://httphandbook.org/
#+END_EXAMPLE

要注意: 根据HTTP说明,这里的地址必须是 *绝对路径* 的

**** Proxy-Authenticate
=Proxy-Authenticate= 与 =WWW-Authenticate= 很类似,不过是给代理用的. 它常与 =407 Proxy Authentication Required= 状态码联用

**** Refresh
等待一段时间后跳转到其他页面

#+BEGIN_EXAMPLE
  Refresh: 3; url=http://httphandbook.org/ 
#+END_EXAMPLE

它与下面的HTML是等价的:
#+BEGIN_SRC html
  <meta http-equiv="refresh" content="3; url=http://httphandbook.org/"> 
#+END_SRC

**** Retry-After
=Retry-After= 经常与3xx重定向状态码联用,表示让client至少等待一段时间后才开始下一个请求.

=Retry-After= 有以下两种格式:
#+BEGIN_EXAMPLE
  Retry-After: Tue, 21 May 2002 12:34:56 GMT 
  Retry-After: 600 
#+END_EXAMPLE

**** Server
=Server= header提供给client关于server使用软件的一些信息.
#+BEGIN_EXAMPLE
  Server: Apache/1.3.22 (Unix)  (Red-Hat/Linux) mod_python/2.7.8 Python/1.5.2 mod_ssl/ 
  This document was created by an unregistered ChmMagic, please go to http://www.bisenter.com to register it. Thanks .
  2.8.5 OpenSSL/0.9.6b DAV/1.0.2 PHP/4.0.6 mod_perl/1.26 mod_throttle/3.1.2 
#+END_EXAMPLE

**** Set-Cookie
告诉client设置cookie值
#+BEGIN_EXAMPLE
  Set-Cookie: fname=chris; domain=.httphandbook.org; path=/; expires=Tue, 21 May 2002 12:34:56 GMT; secure
#+END_EXAMPLE

每个 =Set-Cookie= header只设置一个cookie键值对. 

上例中虽然出现了多个键值对,但只有第一个键值对是真正要设置的键值对.

+ domain属性设置了该cookie生效的域名
+ path属性设定个了该cookie生效的路径
+ expires属性设置了该cookie什么时候失效, 若没有该属性则说明client关闭后即失效
+ secure属性说明该cookie只有在通过安全连接发送的HTTP请求时才发送.

**** Vary
The Vary header  indicates to an intermediate proxy the request headers for which the proxy is not allowed to tolerate fluctuation.

#+BEGIN_EXAMPLE
  Vary: Accept-Language, User-Agent 
#+END_EXAMPLE

**** WWW-Authenticate
=WWW-authenticate= 常与 =401 Unauthorized= 状态码联用,表示所请求的资源需要进行验证.

** General Headers

*** Cache-Control
=Cache-Control= header 用于控制缓存系统的行为,缓存系统一般就是架设在client和server之间的缓存代理.

一个 =Cache-Control= header可以指定多个参数,参数之间用逗号分隔:
#+BEGIN_EXAMPLE
  Cache-Control: max-age=600, no-cache="Set-Cookie"
#+END_EXAMPLE

=Cache-Control= 常用的参数有:

+ no-cache

  =no-cache= 并不是让缓存系统不要保留缓存副本(这是no-store的工作),而是说让它们在吧副本发送给client之前先要验证一下这些副本内容.

  =no-cache= 可以不带参数也可以带参数,其带参数的形式为: ~no-cahe="header名称1,header名称2..."~
  其表示缓存系统保留的缓存副本中不要包括这些header信息.

+ no-store
  
  =no-store= 指明了该交易的所有信息都不要保留缓存副本.

+ max-age
  
  =max-age= 指明了缓存副本在多少秒后过期

  #+BEGIN_EXAMPLE
    max-age=600
  #+END_EXAMPLE

+ max-stale
  
  该参数可以接参数也可以不接参数:
  
  1. 接参数的情况下,表示即时缓存副本已经过期了,但是在多少秒呢,缓存系统依然可以发送缓存副本给客户端而无需重新验证.
     #+BEGIN_EXAMPLE
       max-stale=600
     #+END_EXAMPLE

  2. 在不接参数的情况下,表示即时缓存副本已经过期了,但是缓存系统依然可以发送缓存副本给客户端而无需重新验证.

+ min-fresh
  
  #+BEGIN_EXAMPLE
    min-fresh: 600 
  #+END_EXAMPLE
  =min-fresh= indicates that the caching system can only send a cached copy of the resource to the Web client if the resource is not within 10 minutes (in this example) of being expired

+ no-transform
  
  =no-transform= 明确告诉缓存系统不要修改HTTP respons的内容

+ only-if-cached
  
  告诉缓存系统不要联系server,而是使用自己的缓存副本回复client

+ cache的其他自定义指定

  若代理不清楚这些自定义指令的意义,那么就忽略这些指令.

+ public
  
  允许任何缓存系统缓存任何东西

+ private
  
  The =private= directive  allows caching, but not on shared caches.

+ no-cache
  
  =no-cache= 并不是说让缓存系统不保存缓存了,而是说它需要在发送缓存副本回client之前需要先校验一下缓存是否可用.

+ no-store
  
  让缓存系统不要缓存该交易

+ no-transform
  
  明确要求缓存系统不能修改HTTP回应的content部分.

+ must-revalidate
  
  要求缓存总是去验证它的有效性,以防过期

+ proxy-revalidate
  
  与 =must-revalidate= 一样,只不过不需要校验 private cache的有效性.

+ s-maxage

  与 =max-age= 一样,只不过对private cache无效.

*** Connection
HTTP中的连接管理主要靠 =Connection= header来实现. 该header通常有两种值:

#+BEGIN_EXAMPLE
  Connection: Keep-Alive 
  Connection: Close 
  Connection: Upgrade
#+END_EXAMPLE

在HTTP/1.1中,持久化连接是默认的行为,因此 =Connection: Keep-Alive= 很少用.

一般只是在完成当前交易后用 =Connection: Close= 来关闭该持久连接.

而 =Connection: Upgrade= 用于升级协议时的请求和回复中.

*** Date
=Date= header指明了产生该HTTP消息时的系统时间.

#+BEGIN_EXAMPLE
  Date: Tue, 21 May 2002 12:34:56 GMT 
#+END_EXAMPLE

*** Pragma
Pragma在HTTP/1.0时常用于控制缓存行为,但是在HTTP/1.1时引入了更灵活的 =Cache-Control=,因此现在 =Pragma= 已经不太常用了.

*** Keep-Alive
=Keep-Alive= 基本上也被废弃不用了. 

有些浏览器会接受类似 =Keep-Alive: 300= 这样的写法,表示TCP连接最多保持300秒

*** Trailer
使用 =Trailer= header允许HTTP消息在content之后再添加一些额外的header. 即

HTTP消息原本格式应该是:
#+BEGIN_EXAMPLE
  Request line (HTTP requests)/Status line (HTTP responses)
  HTTP headers
  Content
#+END_EXAMPLE

使用了 =Trailer= header之后可以是这样的:
#+BEGIN_EXAMPLE
  Request line (HTTP requests)/Status line (HTTP responses)
  HTTP headers
  Content
  HTTP headers
#+END_EXAMPLE

使用 =Trailer= header需要注意两点:

1. 必须与 =Transfer-Encoding: chunked= 联用
2. 哪些header能在content后,由 =Trailer= header的值决定.

下面是一个使用了 =Trailer= header的例子
#+BEGIN_SRC html
  HTTP/1.1 200 OK 
  Content-Type: text/html 
  Transfer-Encoding: chunked 
  Trailer: Date 
  7f 
  <html> 
  <head> 
  <title>Transfer-Encoding Example</title> 
  </head> 
  <body> 
  <p>Please wait while we complete your transaction ...</p> 
  2c 
  This document was created by an unregistered ChmMagic, please go to http://www.bisenter.com to register it. Thanks .
  <p>Transaction complete!</p> 
  </body> 
  </html> 
  0 
  Date: Tue, 21 May 2002 12:34:56 GMT
#+END_SRC

*** Transfer-Encoding
在没有持久连接的情况下,Web client可以认为当TCP连接断了就说明Server已经发送完了所有的回复内容.

但是在开启了持久连接的情况下,Web Server就需要有一种方式告诉Web client是否已经发送完了所有的回复内容,这种方式就是告诉client要发送的content的长度是多少.

而者带来的一个缺点就是,若server回复的内容是动态生成的话,server就不得不等待所有内容都生成后才开始回应.

为了解决这个缺陷,于是引入了 =Transfer-Encoding= header,实际使用中,它只有一种使用形式: 
#+BEGIN_EXAMPLE
  Transfer-Encoding: chunked
#+END_EXAMPLE

它允许server将一个response切成几片来回复. 下面是一个例子:
#+BEGIN_SRC html
  HTTP/1.1 200 OK 
  Date: Tue, 21 May 2002 12:34:56 GMT 
  Content-Type: text/html 
  Transfer-Encoding: chunked 
  7f 
  <html> 
  <head> 
  <title>Transfer-Encoding Example</title> 
  </head> 
  <body> 
  <p>Please wait while we complete your transaction ...</p> 
  2c 
  <p>Transaction complete!</p> 
  </body> 
  </html> 
  0
#+END_SRC

可以看到,回复中无需 =Content-Length= header. 另外当出现大小为0的切片时,表示回复结束了.

*** Upgrade
=Upgrade= header提供了一种web server与web client之间协商更改协议的途径.

一般来说协商都会由client发起的:
#+BEGIN_EXAMPLE
  GET / HTTP/1.1 
  Host: 127.0.0.1 
  Upgrade: TLS/1.0 
  Connection: Upgrade
#+END_EXAMPLE

随后Server会回复一个 =101 Switching Protocols= 的状态码,以及同样的 =Upgrade= header与 =Connection= header
#+BEGIN_EXAMPLE
  HTTP/1.1 101 Switching Protocols 
  Upgrade: TLS/1.0, HTTP/1.1 
  Connection: Upgrade 
#+END_EXAMPLE

随后,所有client发送的消息都需通过新协议来进行了.

*** Via
常与 =TRACE= header联用, 中间代里将自己作为节点添加到 =Via= header中

*** Warning
在回复中提供潜在问题的警告. 一般常用于缓存代理回复client时

一个warning的格式一般是这样的:
#+BEGIN_EXAMPLE
  Warning: 警告代号 HOST 警告描述
#+END_EXAMPLE

常见的警告代号有:

+ 110 :: Response is stale
+ 110 :: Revalidation failed
+ 112 :: Disconnected operation
+ 113 :: Heuristic expiration
+ 199 :: Miscellaneous warning
+ 214 :: Transformation applied
+ 299 :: MIscellaneous persistent warning
