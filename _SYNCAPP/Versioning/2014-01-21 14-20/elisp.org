* 若interactive的参数以*开头，则意义是，如果当前buffer是只读的，则不执行该函数
* 变量本地化
  * 普通变量通过make-localvariable或make-variable-buffer-local变为buffer－local的
	* make-variable-buffer-local使指定的变量在每个buffer中都是独立的
	* make-local-variable使变量在当前buffer是独立的，而其他buffer依然共享全局变量
  * hook变量智能通过make-local-hook变为buffer-local的
* 有三种方式可以加载文件：
  * load
  * autoload
  * require
* 使用eval-after-load可以推迟一段代码的执行
  (eval-after-load "触发条件的文件" 待执行的代码)
  这里，第一个参数的值必须跟上面三种方式加载文件时的值一模一样
* 可以直接使用(a . b)产生一个cons，注意a . b之间的空格
* MAX值
  * most-positive-fixnum和most-negative-fixnum定义了整数的范围
  * 
* 和C语言类似，如果参数都是整数，做除法时要记4(/ 5 6)是会等于0的，这跟common lisp不同
* elisp中，字符的读入语法为?字符，而common lisp中是#\字符.
  字符前也可以加上\来转义,如?\a表示控制字符
  另外,\M-代表Meta建,\C-代表control建
* 没有charp,因为字符就是整数,但是有char-or-string-p函数
* 使用char-equal比较字符时,需要注意case-fold-search变量的值,t表示忽略大小写
* 只有string=,string<函数,没有string>函数
* 转换函数
  * char-to-string / string-to-char
  * number-to-string / string-to-number
  * concat可以将序列转换成字符串
	#+BEGIN_SRC elisp
      (concat '(?a ?b ?c ?d ?e)) ; => "abcde"
      (concat [?a ?b ?c ?d ?e]) ; => "abcde"
	#+END_SRC
  * vconcat可以把字符串转换成向量
	#+BEGIN_SRC elisp
    (vconcat "abdef") ; => [97 98 100 101 102]
	#+END_SRC
  * append可以把字符串转换成一个列表
	#+BEGIN_SRC elisp
    (append "abcdef" nil) ; => (97 98 99 100 101 102)
	#+END_SRC
  * downcase / upcase
* length不能对点列表和环形列表求长度,但是可以用safe-length代替
* copy-sequence不能用于点列表和环形列表,可以用copy-tree函数拷贝点列表,但无法复制环形列表
* vector的读入语法为:
  [val1 val2 val3]
* 使用elt取序列中第n个元素,nth取列表中第n个元素,aref取数组的第n个元素
* 使用aref和aset访问或修改数组元素时,下标超出数组长度的话,会产生错误,所以要先确定数组的长度
* elisp中,使用一个名为obarray的向量来存放符号,lisp每读入一个符号都会intern到obarray中,如果想避免,可以在符号名前加上#::
  #+BEGIN_SRC elisp
    (intern-soft "abc") ; => nil
    'abc ; => abc
    (intern-soft "abc") ; => abc
    (intern-soft "abcd") ; => nil
    '#:abcd ; => abcd
    (intern-soft "abcd") ; => nil
  #+END_SRC
  obarray也是一种类型名称
* obarray类似common lisp中的package,我们也可以使用其他向量代替obarray,相关函数有
  * intern
  * intern-soft
  * unintern
  * mapatoms
* 符号的组成
  * 符号名称:symbol-name
  * 符号值:  symbol-value
	* 使用boundp测试符号是否有值
  * 函数:    symobl-function
	* 使用fboundp测试符号是否设置了函数
  * 属性列表:symbol-plist
	* 使用get/put来访问/修改某个属性值
	* 使用plist-get/plist-put来访问/设置属性列表中的属性
	* 属性列表是一个形如(prop1 value1 prop2 value2)的关联列表,但无法删除一个属性
* 列表的第一个表达式如果是一个符号,解释器会查找这个表达式的函数值.如果函数值是另一个符号,则会继续查找这个符号的函数值
* buffer-local变量
** 声明buffer-local变量
   * make-variable-buffer-local
	 各个缓冲区都有各自的buffer-local变量
   * make-local-variable
	 当前缓冲区产生一个局部变量,其他缓冲区仍然使用全局变量(推荐使用)
** buffer相关函数
*** with-current-buffer
   	#+BEGIN_SRC elisp
      ;使其中的body表达式在指定的缓冲区里执行(使用指定buffer的配置信息执行body表达式)
      (with-current-buffer buffer
      body)
   	#+END_SRC
*** get-buffer
	#+BEGIN_SRC elisp
      ;得到缓冲区名字的对应缓冲区对象,如果没有这个名字的缓冲区,返回nil
      (get-buffer buffer-name)
	#+END_SRC
*** default-value
	#+begin_src elisp
      ;访问符号的全局变量的值
      (default-value symbol)
	#+end_src
*** setq-default
	#+begin_src elisp
      ;修改符号作为全局变量的值
      (setq-default symbol-name)
	#+end_src
*** local-variable-p
	#+begin_src elisp
      ;测试变量是不是buffer-local的
      (local-variable-p symbol [buffer对象])
	#+end_src
*** buffer-local-value
	#+begin_src elisp
      ;得到其他缓冲区内的buffer-local变量值
      (buffer-local-value 符号 buffer对象)    
	#+end_src
*** default-boundp
	#+begin_src elisp
      ;判断符号是否有全局值
      (default-boundp 符号)    
	#+end_src
*** makunbound
	#+begin_src elisp
      ;使一个变量的值重新为空
      (makunbound 符号)
	#+end_src
*** kill-local-variable
	#+begin_src elisp
      ;清除一个buffer-local变量
      (kill-local-variable 符号)    
	#+end_src
*** kill-all-local-variables
	#+begin_src elisp
      ;清除所有的buffer-local变量,但是带有属性permanent-local的不会清除,带有这些标记的变量一般都是和缓冲区模式无关的
      (kill-all-local-variables)    
	#+end_src
* 变量名命名习惯
  * -hook 一个在特定情况下调用的函数列表，比如关闭缓冲«时，进入某个模式时。
  * -function值为一个函数
  * -functions 值为一个函数列表
  * -flag 值为nil或non-nil
  * -predicate 值是一个作判断的函数，返回nil或non-nil
  * -program 或-command 一个程序或shell名令名
  * -form 一个表达式
  * -forms 一个表达式列表。
  * -map 一个按键映射（keymap）
  * 命名以空格开头的缓冲区是临时的,用户不需要关系的缓冲区
* docstring
  * 字符串的第一行最好独立的,因为apropos命令只显示第一行的文档
  * docstring以*开头的defvar变量被认为是用户选项（user option）
	* 用户选项可以通过命令set-variable交互设置
	* 可以使用edit-options命令编辑*scratch*
  * '符号名'生成一个链接
  * \\{major-mode-map}可以显示扩展成镇魂歌模式按键的说明
  * docstring最后那个的\[ command ]会被command的绑定键所代替
  * 如果不想要这种代替，需要用\=转义，当然，在Emacs的docstring中，真正的写法应该是
    #+begin_src elisp
      "\\=\\{major-mode-map}"
      "\\=\\[command]"
    #+end_src
* interactive
  * interactive可以后接字符串,表示获得参数的方式
  * interactive可以后接一个form,form的求值结果应该是一个list,这个list的值作为参数的实参
* 缓冲区
** 获取buffer对象
*** current-buffer
	得到当前buffer对象(*当前buffer不一定是在屏幕上显示的哪个缓冲区,另外,当命令执行完成后,光标所在的buffer自动成为当前buffer* )
*** get-buffer-create
	若缓冲区存在则返回该缓冲区对象,否则新建缓冲池对象返回
*** generate-new-buffer
	若有同名缓冲区存在,则新建的缓冲区后会加上后缀
*** buffer-list
	获得所有buffer的列表
*** window-buffer
	获得窗口对应的buffer
*** 
** 函数
*** buffer-name
	#+begin_src elisp
      ;获得指定/当前buffer的名字
      (buffer-name [buffer对象])
	#+end_src
*** rename-buffer
	重命名缓冲区
*** generate-new-buffer-name
	产生一个唯一的缓冲区名
*** set-buffer
	设置指定buffer为当前buffer
*** save-current-buffer
	保存当前buffer,执行其中的表达式,然后回复为原来的buffer
	#+begin_src elisp
      (save-current-buffer
        表达式)
	#+end_src
*** with-current-buffer
	在不改变当前状态下,临时用另一buffer的变量代替现有变量执行语句
	#+begin_src elisp
      (with-current-buffer buffer对象或buffer名称
      表达式)
	#+end_src
*** save-execursion
	不仅保存当前缓冲区,而且保存当前的位置和mark
	#+begin_src elisp
      (save-excursion
       表达式)
	#+end_src
*** kill-buffer
	关闭缓冲区,如果要用户取人是否要关闭缓冲区，可以加到kill-buffer-query-functions里。如果要作善后处理，可以用kill-buffer-hook
*** buffer-live-p
	确认缓冲区是否存在
*** with-temp-buffer
	使用临时buffer执行相应代码
*** make-marker
	创建新的空标记
	#+begin_src elisp
      (make-marker)    
	#+end_src
*** set-marker
	设置标记的位置和缓冲区
	#+begin_src elisp
      (set-marker foo (point))     
	#+end_src
*** point-marker
	得到point处的标记
	#+begin_src elisp
      (point-marker)    
	#+end_src
*** copy-marker
	复制标记或直接用位置生成一个标记
	#+begin_src elisp
      (copy-marker 位置/marker对象)    
	#+end_src
*** maker-position / marker-buffer
	得到一个marker的内容
	#+begin_src elisp
      (maker-position marker对象)
      (marker-buffer marker对象)
	#+end_src
*** buffer-size
	buffer大小
*** point /point-max /point-min
*** mark-marker
	返回当前缓冲区的mark(*注意mark与marker的区别,mark是用来与point一起定义一个region的,而marker是一个标记位置*)
*** set-mark
	设置mark的值,并激活mark
*** push-mark / pop-mark
	加入/删除mark-ring的元素
*** region-beginning / region-end
	取得region的起点和终点
** 缓冲区内容相关函数
*** buffer-string
	得到整个缓冲区的文本
*** buffer-substring
	得到buffer某个区间的文本
*** char-after / char-before
	得到point附件的字符
*** current-word
	point处的词
*** thing-at-point
	得到point处的其他类型的文本
** 修改buffer内容
*** insert / insert-char /insert-buffer-substring
	插入操作
*** delete-char /delete-backward-char /delete-region /delete-and-extract-region
	删除操作
*** re-search-forward / re-search-backward
	搜索操作
	#+begin_src elisp
      (re-search-forward REGEXP &optional BOUND NOERROR COUNT)
      (re-search-backward REGEXP &optional BOUND NOERROR COUNT)    
	#+end_src
*** replace-match
	替换操作
* 光标移动
** 函数
*** goto-char /forward-char /backward-char
	按单个字符移动
*** beginning-of-buffer / end-of-buffer
	跳到buffer的开头/末尾
*** forward-word /backward-word
	按词移动
*** forward-line
	按行移动(没有backward-line,而且每次移动都是移动到行首的,所以(forward-line 0)可以移动到当前行的行首)
*** line-beginning-position / line-end-position
	得到行首/行尾的位置
*** line-number-at-pos
	得到行号
*** bobp(beginning of buffer predicate)和eobp(end of buffer predicate)
	测试是否在buffer头/尾
*** bolp(beginning of line predicate)和eolp(end of line predicate)
	测试是否在行首/尾
* 窗口
** 获得窗口对象
*** selected-window
	得到当前光标所在的窗口对象
*** window-list
	得到当前frame里的所有窗口
*** next-window / previous-window
	window-lists里排在某个window之后/之前的窗口对象
*** get-window-with-predicate
	查找符合某个条件的窗口
*** get-buffer-window
	根据buffer获得window(如果有多个窗口显示同一个缓冲区,那么函数由window-list决定返回哪个).
*** get-buffer-window-list
	根据buffer获得全部的相应window
** 窗口操作
*** split-window
	分割window
*** delete-window
	删除当前选中的窗口
*** delete-other-windows
	删除其他窗口
*** current-window-configuration
	得到当前窗口配置信息,可以用setq保存起来
*** set-window-configuration
	设置当前窗口配置信息
*** select-window
	使某个窗口对象变成选中的窗口
*** save-selected-window / with-selected-window
	执行的语句结束后,选择的窗口仍留在执行语句之前的窗口
*** walk-windows
	遍历窗口操作
** 窗口信息
*** window-tree
	得到当前窗口的结构
*** window-live-p
	判断窗口对象是否存在
*** window-height
	获得窗口的高度(包括了mode line和 header line)
*** window-body-height
	获得窗口的高度(排除了mode line和 header line)
*** window-width
	窗口的宽度,不包括滚动条和边缘
*** window-edges
	返回各顶点的坐标信息(包括滚动条,边缘,mode line ,header line)
*** window-inside-edges
	返回窗口的文本区域的坐标信息
*** window-pixel-edges / window-inside-pixel-edges
	用像素表示的window位置
*** 
