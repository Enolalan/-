* 总介
** 摘要            : org大概能够做什么的摘要
   Org是一种通过纯文本方式来快速而有效地记录笔记,处理待办列表,做项目计划的mode.
   
   Org通过一些NOTE文件来组织任务,这些NOTE文件用纯文本的方式包含了一些列的项目信息. Org是建立在Outline mode的基础之上的,Outline mode能够很好地组织大型文件的内容. 你可以使用可视的循环和结构编辑功能来帮助你编辑大纲树结构. 通过使用内置的表格编辑器,你也可以很容易地创建出一个表格. Org可以管理代办列表,设置最后期限,加时间戳,制定规划. 它动态的把这些东西显示在一个agenda中,在这个agenda中很好地集成了Emacs calendar和diary功能. 你可以用纯文本的方式记录各种类URL的连接,这些连接可以链接到网站,email,Usenet消息,BBDB(The insidious Big Brother Database)条目,和任何与项目有关的文件. 如果你想打印和分享这些记录,你可以把org导出为结构化的ASCII文件,比如HTML,或者iCalendar文件(仅限于TODO和日程条目). 它也可以作为发布工具,为一堆的相互链接的网页提供发布服务.

   作为一个项目计划的环境,Org通过为大纲节点增加元数据的方式工作. 正是基于这些元数据,我们可以通过查询抽取特定的记录并且动态地创建agenda视图.

   Org模式中也可以包含其他非org环境,这些环境运行你编辑文件中的内嵌源代码,更便利地执行代码,记录文档,进行文学化编程.

   通过激活Orgtbl mode,任何major mode都能拥有Org的表格编辑功能,这些表格编辑功能不仅自动化,上下文敏感,而且具有电子表格(spreadsheet)的运算能力. 通过一个转换步骤,就可以用它来包含一个表格到任意文件类型中(比如LaTeX). 通过minor Orgstruct mode,可以在非Org mode中使用Org的结构编辑和列表创建功能.

   Org保持简单的事情简单化. 当第一次使用它时,感觉它就是个简单易用的大纲编辑器. 它不强加给你复杂性,但是当你需要的时候,却会发现有大量的功能可以使用. Org就是一个工具盒,你可以为了不同的目的,通过的不同的途径来使用它,例如你可以把它看成是:
   #+BEGIN_EXAMPLE     
     • 一个具有可见性的转换和结构编辑能力的outline mode扩展
     • 一个记录结构化记录的ASCII系统和表格编辑器
     • 一个TODO列表的编辑器
     • 一个完整的日程表和计划规划工具,你可以设定工作的最后截止日期和规划执行日期.
     • 一个GTD系统
     • 一个简单的超文本系统,可以导出HTML和LaTeX格式的文件
     • 一个发布工具,可以用来创建一套相互链接的网页
     • 一个进行文学化编程的环境
   #+END_EXAMPLE

   有一个网站提供了最新版本的Org连接,还有附加信息,FAQ,和入门指导.这个网页就是http://orgmode.org
** 安装            : 下载org后,如何安装
   *注意*:如果你使用的是Emacs或者XEmacs中自带的Org版本,请跳过这一步直接前往[[Activition][激活]]. 如果需要查看你Emacs中自带的Org是什么版本的,按下 /M-x load-library RET org/ 然后再 /M-x org-version/.

   如果你从网站上下载了Org,不管它是zip还是tar格式的分发包,也不管它是不是Git存档,你必须遵照下面的步骤来安装它:
   解压Org分发包并进入解压的目录中,然后编辑顶层目录中的'Makefile'文件. 你必须设置Emacs的二进制执行文件的名字(一般是'emacs'或者'xemacs'),设置Lisp和Info文件存放的路径. 如果你没有权限访问全系统的目录,你只需要简单地把'lisp'子目录加入Emacs的load-path中,然后就可以运行org mode了.如果你用这种方法,需要把下面这一行加入'.emacs'文件中
   #+BEGIN_SRC emacs-lisp    
     (setq load-path (cons "~/path/to/orgdir/lisp" load-path))          
   #+END_SRC
   如果你想使用'contrib'子目录中的代码,你只需要加这么一句
   #+BEGIN_SRC emacs-lisp
        (setq load-path (cons "~/path/to/orgdir/contrib/lisp" load-path))
   #+END_SRC
   现在用下面的shell命令来把lisp文件编译为字节格式
   #+BEGIN_SRC sh
     make
   #+END_SRC
   如果你只是从发布目录运行Org,这就是所有的步骤了. 如果你想要安装Org到系统目录中,指向下面命令(需要系统管理员权限)
   #+BEGIN_SRC sh
     make install
   #+END_SRC
   安装Info文件是系统依赖的,不同的系统使用的是不同的'install-info'程序. 下面的命令理论上应该可以正确的安装Info文件到大多数系统中,但如果没有正确的安装的话,欢迎发送BUG报告给我们[fn:1]
   #+BEGIN_SRC sh
     make install-info
   #+END_SRC
   然后把下面一行添加到'.eamcs'文件中. 这使得Emacs可以在需要的时候自动加载文件中的函数,而不用在Org mode已启动的时候就加载
   #+BEGIN_SRC emacs-lisp
     (require 'org-install)
   #+END_SRC
   不要忘了激活Org,具体操作见下一节.
** 激活            : 如何为指定的buffer激活org模式 #<<Activition>>
   为了保证后缀为'.org'的文件会使用Org mode,在'.emacs'文件中增加下面一行
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
   #+END_SRC
   Org-mode缓冲区需要打开font-lock选项,默认情况下Emacs已经打开次选项[fn:2]. 有4个Org命令应该定义全局的快捷键(也就是说作用于在Emacs的任何地方,而不仅仅是Org缓存区),这四个org命令为'org-store-link','org-capture','org-agenda'和'org-iswitchb'. 下面是建议的绑定键设置,你可以按照自己喜欢的来修改键配置
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-cl" 'org-store-link)
     (global-set-key "\C-cc" 'org-capture)
     (global-set-key "\C-ca" 'org-agenda)
     (global-set-key "\C-cb" 'org-iswitchb)
   #+END_SRC
   
   经过上面这些配置,所有后缀为'.org'的文件在打开时会直接进入Org-mode. 如果你想不这么配置,作为替代,把下面这句放到文件的一行也可以.
   #+BEGIN_EXAMPLE
     MY PROJECTS    -*- mode: org; -*-
   #+END_EXAMPLE
   这样,不管文件名是什么,在打开时都会进去Org-mode. 参见变量'org-insert-mode-line-in-empty-file'.

   很多Org命令在选定文本块时会对文本块进行操作. 为了保证该特性被启用,你需要开启'transient-mark-mode'(在XEmacs总是'zmacs_regions'). 在Emacs23中默认是打开的,但是在Emacs22中,你需要自己打开,自己打开的命令为
   #+BEGIN_SRC emacs-lisp
     (transient-mark-mode 1)
   #+END_SRC
   
   如果你不想使用transient-mark-mode,你可以通过鼠标选择一个区域,以这种方式来建立一个选定的文本块,或者在一定光标之前安两下'C-<SPC>'
** 反馈            : BUG报告,好的想法,补丁等等
   如果你发现了Org有问题,或者你有疑问,建议和好的想法,请发邮件到Org的mailing list [[emacs-orgmode@gnu.org]]. 如果你还不是这个mailing list的会员, 那么在版主批准之后,你的mail会被加入到mailing list中[fn:3]. 

   如果你想报告BUG,请首先在最新版本的Org上复现这个BUG--如果你允许一个老旧版本的Org,很可能这个Bug已经被修复了. 如果依旧有问题,请写好报告并提供尽可能多的信息,包括Emacs的版本信息(用M-x emacs-version <RET>)和Org的版本信息(用M-x org-version <RET>),以及'.emacs'中Org的相关配置. 最简单的提交报告的方法就是执行命令'M-x org-submit-bug-report'. 这个命令会收集所有必要的信息并放到一个Emacs的mail缓存区中,这样你只需要添加你自己的描述就可以了. 如果你不会在Emacs中发送email,请拷贝这些内容并粘贴到自己常用的Email程序中.

   有时候你面对的错误可能是由于Emacs或Org-mode配置错了. 在报告BUG之前,最后以最小客户化的形式启动Emacs然后复现这个BUG. 这样做常常能够帮助你确定这个问题是因为配置的关系还是Org-mode本身有问题. 你可以用下面这个命令来开启一个最低客户化的session
   #+BEGIN_SRC sh
     emacs -Q -l /path/to/minimal-org.el
   #+END_SRC
   
   如果你使用的是Emacs中自带的Org mode,那么上面哪个最小客户化的配置就没有必要了. 你可以直接用'emacs -Q'来打开Emacs. 一个典型的'minimal-org.el'配置文件可能包含如下内容
   #+BEGIN_SRC emacs-lisp
     ;;; Minimal setup to load latest `org-mode'
     
     ;; activate debugging
     (setq debug-on-error t
           debug-on-signal nil
           debug-on-quit nil)
     
     ;; add latest org-mode to load path
     (add-to-list 'load-path (expand-file-name "/path/to/org-mode/lisp"))
     (add-to-list 'load-path (expand-file-name "/path/to/org-mode/contrib/lisp"))
     
     ;; activate org
     (require 'org-install)
   #+END_SRC
   如果有错误发生,一个错误的跟踪栈对查找问题很有帮助(下面说明了如何创建一个跟踪栈). 通常提供一个简单的造成错误的简单例子会很有帮助, 再加上以下这些信息:
   #+BEGIN_EXAMPLE
     1. 你做了什么
     2. 你希望的结果是什么
     3. 实际上的结果是什么
   #+END_EXAMPLE
   
   感谢您帮助我们改进这个程序.
*** 如何创建一个有用的跟踪栈
    如果Org报出了一个i额你不明白的出错信息,你可能发现了BUG. 报告这个BUG的最好方法是提供一个跟踪栈(backtrace). 跟踪栈使用内置的调试信息来收集一些信息,这些信息包括错误发生的地点和方式. 下面是提供一个有用跟踪栈的步骤
    1. 重新加载未编译的所有Org mode的Lisp源文件. 如果错误是在未编译的脚本中产生时,跟踪栈能够提供多得多的信息. 要做到这一步,执行
       #+BEGIN_EXAMPLE
         C-u M-x org-reload RET
       #+END_EXAMPLE
       或者在Emacs菜单上选择'Org -> Refresh/Reload -> Reload Org uncompiled'
    2. 在'Options'菜单中选择'Enter Debugger On error'(如果是使用XEmacs,需要在'Troubleshooting'子菜单中选择此项).
    3. 复现错误,别忘了记录操作的每个步骤
    4. 当错误产生了,一个名为*Backtrace*的缓存区会显示出来,保存这个缓存区到文件中(一般是用C-x C-w命令)然后附加在你的错误报告中.
** 手册中的排版约定  : 手册中的排版约定
   Org使用三种类型的关键字:TODO关键字,标签和属性名称. 在该手册中我们使用如下约定:
   #+BEGIN_EXAMPLE
   TODO
   WAITING
   #+END_EXAMPLE
   TODO关键字全部大些,即使它们可以用户随意定义的.
   
   #+BEGIN_EXAMPLE
   boss
   ARCHIVE
   #+END_EXAMPLE
   
   用户自定义的标签使用全小些;内置的标签具有特定的意义,使用全大些形式
   #+BEGIN_EXAMPLE
   Release
   PRIORITY
   #+END_EXAMPLE
   用户自定义的属性使用首字母大些;内置属性有特定意义的,使用全大些形式.
   
   该手册列出特定功能的键序列和相应的命令. Org mode经常使用相同的键序列来在不同的上下文中触发不同的功能. 绑定到这些键序列的命令都有一个通用的名称,比如'org-metaright'. 在该手册中,我们会尽可能的给出通用命令内部调用的函数名称. 例如,在文件结构的章节上按下'M-<right>'会被指明调用的是'org-do-demote'程序,而在表标题上按下相同的键序列时,我们会指明调用的是'org-table-move-column-right'.

   如果你愿意,你可以编译这份手册使之不带有命令名称,方法是在'org.texi'中取出'cmdnames'标志.
* 文档结构
  Org是基于Outline-mode的,它提供了大量的命令来编辑文档的结构.
** 大纲                  :Org是基于Outline-mode的
   Org的实现是基于Outline-mode的.Outline运行文档按照分级结构的方式来组织,这种方式(至少对于我来说)是用来展示记录和想法的最佳方式.通过折叠(隐藏)绝大部分的文档内容而只显示文档的大致结构和正在编辑的这一部分内容,一个文档结构的总览被完美地展示出来. Org极大地简化了对大纲的操作,它把整个显示/隐藏功能都通过一个命令来完成:'org-cycle',这个命令被绑定到了<TAB>键上.
** 标题                  :如何排版Org的树状标题
   标题定义了大纲树的结构. Org的标题以一个或多个星号开头,向左对齐[fn:4]. 例如:
   #+BEGIN_SRC org
     ,* Top level headline
     ,** Second level
     ,*** 3rd level
     ,    some text
     ,*** 3rd level
     ,    more text
     
     ,* Another top level headline
   #+END_SRC

   有些人觉得太多的星号眼花缭乱,它们可能更喜欢Outline-mode使用空格加星号的格式作为标题的开始标识.[[A cleaner outline view][一个更简洁的大纲显示]]中描述了如何配置.

   在子树的末尾的空行,被认为是子树的一部分,它会随着子树的折叠而被隐藏. 然而,如果你放了两个空行,那么在折叠这个子树的时候,还会有一个空行是可见的,这样做的目的常常是为了构造分割的视图. 要改变这种行为,需要配置变量'org-cycle-separator-lines'
** 可见性的转换           :显示和隐藏,很简单
   Outline使得隐藏缓存区中的一部分文本成为可能. Org仅仅使用两个命令来切换缓存区的可见性,这两个命令被绑定到了'<TAB>'和'S-<TAB>'上.
   * <TAB> (org-cycle) :: 子树循环:以下面的循环状态来切换当前子树的状态
	#+BEGIN_EXAMPLE
	,-> FOLDED -> CHILDREN -> SUBTREE --.
	'-----------------------------------'
	#+END_EXAMPLE
	为了执行子树的切换,光标位置必须在子树的标题上[fn:5]. 若光标在缓存区的最前端,而这第一行又不是标题,那么<TAB>实际上执行的是'全局循环'(具体情况见下文)[fn:6]. 同样的,如果使用的是带前缀参数的<TAB>(C-u <TAB>),调用的也是'全局循环'
   * S-<TAB> / C-u <TAB> (org-global-cycle) :: 全局循环:使整个缓存区在在不同状态间切换
	#+BEGIN_EXAMPLE
	 ,-> OVERVIEW -> CONTENTS -> SHOW ALL --.
	'--------------------------------------'
	#+END_EXAMPLE
	若再S-<TAB>前加了一个数字前缀N,那么CPMTEMTS一直到第N个层次的内容都会显示出来. 需要注意的是,若是在编辑表格中,S-<TAB>的作用是跳到上一个域.
   * C-u C-u <TAB> (show-all) :: 
	显示所有信息,包括'抽屉'内的信息
   * C-c C-r (org-reveal) :: 
	显示光标周围的上下文,也就是显示当前条目,以及所有上层标题. Useful for working near a location that has been exposed by a sparse tree command (see section Sparse trees) or an agenda command (see section Commands in the agenda buffer). With a prefix argument show, on each level, all sibling headings. With a double prefix argument, also show the entire subtree of the parent. (TODO 真没看懂什么意思,在实验C-c C-r的时候我的Org居然没反应...)
   * C-c C-k (show-branches) :: 
	展开所有子树的标题,如果只有一个子树,那么内容也显示出来.
   * C-c C-x b (org-tree-to-indirect-buffer) :: 
	把当前子树显示在indirect buffer中[fn:7]. 如果加了一个前缀参数N,它会向下进入地N层子树并在indirect buffer中显示该子树. 如果N是负数,那么就是向上进入N层的父节点. 如果命令执行前加了C-u前缀,则打开新的indirect buffer,而不会关闭之前打开的indirect buffer.
   * C-c C-x v (org-copy-visible) :: 
	拷贝文本块中的可见文本到kill ring中
	
   当Emacs第一次打开一个Org文件时,全局状态为OVERVIEW,也就是说,只有顶层的标题是可见的. 这个行为可以通过配置'org-startup-folded'变量来改变.或者可以在文件的任何地方添加下面所列出的任何一句,Emacs就会根据这句配置信息自动设置初始的状态.
   #+BEGIN_SRC org
     ,#+STARTUP: overview
     ,#+STARTUP: content
     ,#+STARTUP: showall
     ,#+STARTUP: showeverything
   #+END_SRC

   此外,任何带有'VISIBILITY'属性名的条目(参考[[#Properities and columns][属性与列]])会相应地按照该属性值来设置可见性. 该属性的有效值可以使'folded','children','cotent'和'all'
   * C-u C-u <TAB> (org-set-startup-visiblity) ::
     重置该buffer的可见性为该buffer在启动时的可见性,也就是说根据buffer的'startup'选项和各个单独条目的'VISIBILITY'属性来重新设置整个buffer的可见性.
** 移动                  :跳转到其他标题
   下面的命令跳转到buffer中的其他标题
   * C-c C-n (outline-next-visible-heading) ::
     下一个标题
   * C-c C-p (outline-previous-visible-heading) :: 
	上一个标题
   * C-c C-f (org-forward-same-level) :: 
	同一级的下一个标题
   * C-c C-b (org-backward-same-level) :: 
	同一级的上一个标题
   * C-c C-u (outline-up-heading) :: 
	回到上一级标题
   * C-c C-j (org-goto) :: 
	跳转到其他位置的同时不改变当前大纲的可见性. 在一个临时buffer中显示文档的结构,在这个临时buffer中你可以使用下面的快捷键来定位:
	#+BEGIN_EXAMPLE
	<TAB>           切换可见性
	<down> / <up>   下一个/上一个可见的标题
	<RET>           选定当前位置
	/               在树中作一个匹配查询
	如果你关掉了org-goto-auto-isearch选项,下面这些快捷键才可用
	n / p           下一个/上一个可见的标题
	f / b           同级别的上一个/下一个标题
	u               回到上一级标题
	0-9             数字参数
	q               退出这个临时buffer
	#+END_EXAMPLE
	参见变量'org-goto-interface'
** 结构编辑               :改变标题的次序和层次
   * M-<RET> (org-insert-heading) ::
     插入一个与当前位置同级别的新标题. 如果光标位于一个普通的列表项,新的列表项被创建(参见[[#Plain list][普通列表]]). 要强制创建新标题,则需要使用前缀参数. 如果在一行的中间执行这个命令,那么这一行会被分割成两行,光标到行尾的内容会成为新的标题[fn:8]. 如果实在一个标题的开头执行这个命令,那么新标题会天骄到当前行的前面. 如果是在所有行的前面执行这个命令,那么就创建了一个新的文件头. 如果是在折叠起来的子树末尾使用这个命令(也就是说,是在标题末尾的省略号之后),那么与当前标题类似的标题会被插入到这个子树的末尾.
   * C-<RET> (org-insert-heading-respect-content) :: 
	类似与M-<RET>,不同之处在于,当在当前标题后增加一个新标题时,M-<RET>会在当前标题的内容前增加一个新标题(内容成为这个新标题的内容),而C-<ERT>则在内容后增加一个新标题(内容还是原标题的内容). 这个命令在条目的任何地方都是一样的行为.
   * M-S-<RET> (org-insert-todo-heading) :: 
	插入一个与当前标题同级别的TODO事项. 参见变量'org-treat-insert-todo-heading-as-state-change'
   * C-S-<RET> (org-insert-todo-heading-respect-content) :: 
	插入一个与当前标题同级别的TODO事项, 与C-<RET>类似,新的标题会插在当前子树的后面.
   * <TAB> (org-cycle) :: 
	在一个未输入内容的标题上,第一次按<TAB>,这个标题成为了上一个标题的子标题,再按一下<TAB>,这个标题的级别变成了上一个标题的父标题,然后每按一次<TAB>级别就上升一级,一直到最高级.到了最高级再按一次<TAB>,又会回到初始的级别.
   * M-<left> (org-do-promote) :: 
	提升当前标题一级
   * M-<right> (org-do-demote) :: 
	降低当前标题一级
   * M-S-<left> (org-promote-subtree) :: 
	提升当前子树一级
   * M-S-<right> (org-demote-subtree) :: 
	降低当前子树一级
   * M-S-<down> (org-move-subtree-up) ::
        上移当前子树(与同级别的上一个子树交换位置)
   * M-S-<down> (org-move-subtree-down) ::
        下移当前子树(与同级别的下一个子树交换位置)
   * C-c C-x C-w (org-cut-subtree) :: 
	剪切当前子树,也就是说把当前子树从buffer移到kill ring中. 加一个前缀参数N,会剪切N个连续的子树.
   * C-c C-x M-w (org-copy-subtree) :: 
	把当前子树拷贝入kill ring中, 加上一个前缀参数N,会拷贝N个连续子树
   * C-c C-x C-y (org-paste-subtree) :: 
	从kill ring中粘贴子树. 该操作会自动更改被粘贴子树的级别以便它能够使用粘贴的位置. 你也可用在粘贴时就指定好级别,方法有两个,一个是在粘贴命令前加一个数字前置参数,第二种方法是在已经标示好的标题(比如'****')后粘贴子树.
   * C-y (org-yank) :: 
	根据变量'org-yank-adjusted-subtrees'和'org-yank-folded-subtrees'的值,org-yank可用很智能地用与命令C-c C-x C-y一样的方式来粘贴折叠起来的子树. 在缺省的配置中,org-yank不会调整级别,并且除非会把原先可见的文本折叠起来,否则被粘贴的子树会子的那个被折叠起来. 任何前缀参数会让这个命令强制执行一个带着前缀参数的普通的yank操作. 要强制执行普通yank的一个好方法是按下C-u C-y. 如果在yank之后,你紧接着执行yank-pop命令,就会yank当前kill-ring前一个的内容,而且不会作调整和折叠动作.
   * C-c C-x c (org-clone-subtree-with-time-shift) :: 
	拷贝一堆的同级副本. 你可以一次性拷贝多个同级副本,并且你若拷贝的条目中含有时间戳信息的化,你还可以定义时间戳信息如何变化. 这项功能十分有用,例如,当你要分配任务来准备一系列的课程时. 更多细节参见命令'org-clone-subtree-with-time-shift'的文档字符串.
   * C-c C-w (org-refile) :: 
	转存指定条目或文本块到另一个地方.参见章节[[#Refiling note][转存记录]].
   * C-c ^ (org-sort-entries-or-items) :: 
	对同级条目进行排序. 如果选择了一块文本块,所有文本块中的条目都会被排序. 否则当前标题下的子节点进行排序. 该命令会提示你选择排序的方法,可选择的方法有按字母顺序排序,按数字顺序排序,按时间排序(创建时间,规划时间,最后期限),按优先级排序,按TODO的关键字排序(需预先在配置中定义好关键字的排序顺序),按属性值排序. 你也可以采取逆排序的方式排序. 你甚至可以提供自己的函数来对其他的关键字进行排序. 如果加了C-u前缀,排序是大小写敏感的.
   * C-x n s (org-narrow-to-subtree) :: 
	缩减buffer只显示当前的子树的内容
   * C-x n s (org-narrow-to-block) ::
        缩减buffer只显示当前块的内容
   * C-x n w (widen) :: 
	回复被缩减的buffer
   * C-c * (org-toggle-heading) :: 
	该命令把正文转变为一个标题(正文在它的位置成为上一个标题的一个子标题). 也会把一个标题转变为正文. 如果选择了一个文本块,那么文本块中的所有行都变成标题. 如果该文本块中第一行是一个item(什么意思??),那么只把这个item转换为标题. 最后,如果文本块中第一行是一个i额标题,那么该文本块中所有的标题都变成正文.

   当对一个选定的文本块(Transient Mark mode)作升级/降级操作时,会影响到文本块中所有的标题.  要选择一个包含很多标题的文本块,最好是把point和mark都放在行首,mark放在第一个标题的行首,point放在要改变的最后哪个标题的下一行的行首. 需要注意的是,如果光标在表格内部(参见[[#tables][表格]]). Meta-光标键的操作有不同的作用.
        
** Sparse树              :与情景有关的匹配
   Org-mode的一个很重要的功能是它可以根据一系列的条件,将一棵大纲树中所匹配出来的一部分形成一棵sparse树,也就是说,整个文档都会尽可能的折叠起来,唯独所匹配的信息和上级标题是可见的[fn:9]. 你只要尝试以下,就立刻能够明白它是怎么工作的. 

   Org-mode有很多命令可以创建Sparse树,所有这些命令都可以通过dispatcher来触发.

   * C-c / (org-sparse-tree) ::
        它会提示你输入一个额外的快捷键来选择特定的sparse树的创建命令
   * C-r / r (org-occur) :: 
	提示输入一个正则表达式,然后显示所有匹配的sparse树. 如果有标题匹配,那么只有这个标题可见. 如果是正文匹配,那么标题和正文同时可见. 为了提供最低限度的上下文信息,所有上层标题和紧跟者匹配部分的标题都会被显示. 每个匹配的部分都被高亮; 若这是你对文档进行编辑动作,则高亮会消失[fn:10]. 同样你也可以通过C-c C-c来取消高亮. 如果执行C-u C-c / r则以前匹配的高亮会被高持,这样多次调用这个命令的结果就被保存了下来.
   * M-g n 或者 M-g M-n (next-error) :: 
	跳到当前buffer中匹配的下一个sparse树
   * M-g p 或者 M-g M-p (previous-error) :: 
	跳到当前buffer中匹配的上一个sparse树

   对于那些常用的sparse树查询,你可以在变量'org-agenda-custom-commands'中定义快捷键,直接执行这些sparse树查询. 然后就可以在agenda dispatcher中使用这些快捷键来快速查询了.例如
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-custom-commands
           '(("f" occur-tree "FIXME")))
   #+END_SRC
   会定义一个键序列为'C-c a f'的快捷方式,这个快捷方式会通过匹配字符串'FIXME'来创建sparse树.

   其他的sparse树命令(例如通过TODO关键字,标签或者属性来查找)会在手册后一点的位置提到.

   要打印出sparse树,你可以使用emacs命令'ps-print-buffer-with-faces',这个命令不会把不可见部分给打印出来[fn:11]. 或者你可以用命令'C-c C-e v'把可视化的部分导出到文档中,然后打印导出文档.
** 纯文本列表             :条目中的附加结构
   在大纲树的正文内容中,手工排列好的列表被认为是带有一定结构的. Org提供了一种方式来创建带复选框的列表(参见[[#Checkboxes][复选框]]),它提供工具来编辑这种列表,并且在导出时(参见章节[[Exporting][导出]])能够解析并且格式化这些列表.

   Org支持有序列表,无序列表和描述列表
   * 无序列表,以'-','+'或者'*'[fn:12]开头
   * 有序列表以数字开头,后接句号或者右括[fn:13](像这样'1.','1)')[fn:14]. 如果你想让列表以其他值作为初始值开始计数,需要以类似[@20]这样的文本开头[fn:15]. 这样的用法可以用在列表的任何一项上(而不需要仅仅是第一项),以强制从指定数字顺序开始.
   * 描述列表是一种无序列表,它包含'::'作为分隔符来分割术语和描述.
     
   同一个列表中的列表项必须有相同的缩进. 尤其当一个有序列表的计数达到了'10'的时候,那么这两位的计数必须与列表中的其他计数左对齐. (一个列表项可以是多行的.)当一个列表项的下一行的缩进与该列表项本身的缩进相等甚至跟少时,才表示该列表项结束了.

   当所有的列表项结束时,一个列表才被认为是结束了的,这意味在有一行的缩进等于或者小于列表第一项的缩进前,该列表都没有结束. 当然,你也可以用两个空白行[fn:16]来强制结束列表. 这种情况下,所有的列表项都被关闭了.下面是一个例子.
   #+BEGIN_SRC emacs-lisp
     ,** Lord of the Rings
        My favorite scenes are (in this order)
        1. The attack of the Rohirrim
        2. Eowyn's fight with the witch king
           + this was already my favorite scene in the book
           + I really like Miranda Otto.
        3. Peter Jackson being shot by Legolas
           - on DVD only
           He makes a really funny face when it happens.
        But in the end, no individual scenes matter but the film as a whole.
        Important actors in this film are:
        - Elijah Wood :: He plays Frodo
        - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
          him very well from his role as Mikey Walsh in The Goonies.   
   #+END_SRC

   Org能正确地对这些列表进行filling和warpping调整[fn:17], 而且能够以一种恰当的方式导出这些列表(参见[[#Exporting][导出]]). 由于缩进决定了这些列表的结构,许多像#+BEGIN_...这样的block可以通过缩进来表明它们是属于哪一个列表项的一部分的.

   如果你觉得为子列表使用不同的标示(而不使用当前列表项的标示)可以增加可读性,你可以自定义变量'org-list-demote-modify-bullet'. 如果你想改变缩进程度,自定义变量'org-list-indent-offset'

   当光标处于某列表项的第一行(即带有列表项标示的那一行),可以用下面这些命令来对列表项进行操作. 其中有些命令暗含某些规则来保证列表结构是正确的. 如果你想让这些命令妨碍了你,可以通过配置'org-list-automatic-rule'来禁用其中的某些命令.
   * <TAB> (org-cycle) ::
        列表项可以像标题一样具有折叠的功能. 正常情况下,只有当光标处在plain list item上时才能进行这种折叠操作. 欲了解更多的细节,请看变量'org-cycle-include-plain-lists'. 如果该变量的值为'integrate'. plain list items会被当成是低层次的标题看待. 而*号和数字缩进层次则决定了把它当成几级标题来看待. 列表项的等级总是要低于真正的标题, 然而列表的等级制度与标题的等级制度是完全分开的. 在一个新的还未写内容的列表项上,第一次按<TAB>会把它变成上一个列表项的子项.再按一次<TAB>会上升一个层级,并且下去直到最顶列表项的层级,再按一次则返回最原始的层级位置.
   * M-<RET> (org-insert-heading) :: 
	插入新列表项到当前层级. 若在前面加了前缀参数,则强制插入的是标题(参见[[#Structure editiong][结构编辑]]). 如果在一个列表项的中间位置执行这条命令,这个列表项会被分为2部分,而第二部分则变成了一个新的列表项[fn:18]. 如果在列表项的内容前执行这个命令,则新列表项插入在当前列表项前.
   * M-S-RET :: 
	插入带复选框的列表项(见[[#Checkboxes][复选框]])
   * S-up 和 S-down :: 
	跳转到当前列表的上一个/下一个列表项上去[fn:19],不过该命令只有在'org-support-shift-select'被关闭的情况下才能用. 如果不是的话,你可以使用段落跳转命令代替,快捷键为C-<up>和C-<down>
   * M-up 或 M-down :: 
	向上或者向下移动列表项及其子项[fn:20](与上一个/下一个同缩进的列表项交换). 如果列表是有序列表,会自动重新计算序号.
   * M-S-left 和 M-S-right ::
        减少/增加列表项(联通其子项)的缩进. 在第一次开始改变缩进时Org就会记住缩进的范围,并且在以后的多次缩进中都以次范围为准进行缩进,即使在缩进过程中可能会形成新的继承体系也不管. 如果你想在新的继承体系上进行缩进,那么你可以移动以下光标或者其他方法来先中端命令链,重新开始新的缩进过程.

        作为一种特殊的情况,在列表的第一个列表项上用这个命令会移动整个列表. 你可以通过配置'org-list-automatic-rules'来禁止这种行为. 一个列表的总体缩进对列表后面的文本并无影响力(什么意思??)
   * C-c C-c :: 
	如果所在的列表项是带复选框的(参见[[#Checkboxes][复选框]]),那么就会转换复选框的状态. 在任何情况下,该命令都会校验整个列表序号和缩进的一致性.
   * C-c - :: 
        循环更改整个列表的列表项标志(对于无需列表:'-','+','*';对于有序列表:'1.','1)'),更改的具体方式依据'org-plain-list-ordered-item-terminator',列表的类型和列表项的位置来决定的[fn:21]. 如果加了一个数字前缀N,就会选择'+,*,1.,1),-'中第N个标识作为列表项的标识. 如果在调用该命令时选择了一个文本块,那么整个文本块会转换成一个列表项. 如果加了前缀参数,那么文本块中所有的行各自转换成为列表项. 如果第一行依据是一个列表项,那么文本块中所有的列表项标识都被删除. 最后,即使没有选择文本块,一个普通的文本行也会转换成列表项.
   * C-c * :: 
	把一个普通列表转换为标题(这样它就原地转换为了一个子标题). 更详细的扩展参见[[#Structure editing][结构编辑]].

   * C-c C-c * :: 
	把整个列表转换成当前标题下的子树. 带复选框的列表项(参见[[#Checkboxes][复选框]])会转换成TODO(复选框没被选上)或者DONE(复选框被选上)关键字.
   * S-left 或 S-right :: 
	当光标处于列表项的任意位置上时,这个命令也会起到循环转换列表项标志的作用. 具体怎么转换依赖于'org-support-shift-select'
   * C-c ^ :: 
	对列表进行排序. 你会被提示输入排序方法,有按数字排序,按字符排序,按时间排序或自定义方法排序.
** 抽屉                  :收缩起所有的资料
   有时候你想记录下一项事务的某些信息,但是这些信息在一般情况下是没必要显示出来的. 为了实现这个目的,Org mode提供了drawers功能. drawers需要在变量'org-drawers'[fn:22]中进行配置. Drawers看起来就像这样:
   #+BEGIN_SRC org
     ,** This is a headline
     ,   Still outside the drawer
     ,   :DRAWERNAME:
     ,   This is inside the drawer.
     ,   :END:
     ,   After the drawer.
   #+END_SRC

   无论如何在标题上切换可见性(参见[[#Visibility cycling][切换可见性]]),drawer都是收缩为一行显示的. 要看drawer内的信息,你需要移动鼠标到drawer这一行,然后按<TAB>键. Org-mode使用名为'PROPERTIES'的drawer来存放属性(参见[[#Properties and columns][属性与列]]), 你也可以把状态改变记录(参见[[Tracking TODO state changes][跟踪TODO状态变化]])和计时时间(参见[[#Clocking work time][记录工作时间]])存放在名为'LOGBOOK'的drawer中. 如果你想像状态变化信息一样把自己的一段记录也存放到名为'LOGBOOK'的这个drawer中,使用
   * C-c C-z ::
        添加一个带有时间戳信息的记录到名为'LOGBOOK'的drawer中
** 区块                  :折叠的区块
   Org-mode使用begin...end块来实现很多功能,比如引入源代码(参见[[#Literal examples][文学化例子]]),记录计时信息(参见[[#Clocking work time][记录工作时间]]). 在这些区块的第一行上按TAB键可以折叠/扩展该区块. 你也可以在设置在启动时自动折叠所有的块,方法是配置变量'org-hide-block-startup'或者在每个文件加上
   #+BEGIN_SRC org
     ,#+STARTUP: hideblocks
     ,#+STARTUP: nohideblocks
   #+END_SRC
** 注脚                  :如何用Org标签定义注脚
   Org-mode支持创建注脚. 与'footnote.el'包相反,Org-mode中的注脚功能是专门设计在大型文档来使用的,而不仅仅是用在类型email这样的一次性文件上的. org-mode中注脚的基本语法类似于'footnote.el'中的语法,即,要在段落中定义一个注脚,它需要顶格(不能有缩进)以方括号作为注脚的标记. 如果你需要在注脚内分段,使用LaTeX语法'\par'. 要定义注脚引用,只需要简单的在文本中用方括号做一个标记. 例如
   #+BEGIN_SRC org
     ,The Org homepage[fn:1] now looks a lot better than it used to.
     ,...
     ,[fn:1] The link is: http://orgmode.org
   #+END_SRC
   
   Org-mode会把'footnote.el'中基于数字的语法扩展为可以为注脚命名并且可以选择给注脚提供内部定义. 使用纯数字作为注脚标注(footnote.el就是这样作的)是为了提供向后兼容性,但是这种方式不鼓励使用,因为这种方式可能会与LaTeX snippets(参见[[#Embedded LaTeX][内嵌LaTeX]])冲突. 下面列举几种有效的注脚引用:
   * [ 1 ] ::
        一个纯数字的注脚标记. 与'footnote.el'兼容,但是不推荐使用,因为像'[ 1 ]'这样的东西,很可能是code snippet的一部分.
   * [ fn:name ] :: 
	一个带有名字的注脚引用,这里name是一个唯一的标签.如果是自动创建的注脚引用的化,则会是一个数字.
   * [ fn:: This is the inline definitiion of this footnote ] :: 
	这是一个类似LaTeX的匿名注脚,其中注脚的定义直接放在引用的位置.
   * [ fn:name:a definition ] ::
        这是一个带有名字的自定义的注脚. 由于Org-mode允许从多处引用到同一个说明,你可以使用[ fn:name ]来创建更多的引用.

   注脚标记可以被自动创建,你也可以自定义标记自动创建时的名字. 这是由变量'org-footnote-auto-label'变量和变量相应的'#+STARTUP'关键字来决定的. 欲了解详情请查看该变量的文档字符串.

   下面这些都是操作注脚的命令
   * C-c C-x f ::
     注脚行为命令

     当光标位于注脚引用处,该命令会跳转到注脚定义处. 若光标处于注脚定义处,跳转到(第一个)引用处.

     否则,创建一个新的注脚. 根据变量'org-footnote-define-inline[fn:23]'的不同,该注脚的定义可能是作为引用的一部分,会放在文本中, 也可能放在另外的其他位置,这个位置由变量'org-footnote-section'决定.

     当使用带前置参数的方式调用该命令, 会显示出一个附加选项菜单供你选择:
     #+BEGIN_EXAMPLE
       s   以引用顺序为依据对注脚的定义进行排序. 在编辑过程中,Org不会对注脚的定义进行排序操作. 如果你向对这些注脚的定义进行排序,使用这个命令,在对注脚定义进行排序的同时,也会根据'org-footnote-section'来移动整个条目. 用户可以通过配置变量'org-footnote-auto-adjust'来实现在每次插入/删除一个注脚后自动对注脚定义进行重新排序.
       r   对类型fn:N这样的以简单数字命名的注脚进行重新编号. 可以通过配置变量'org-footnote-auto-adjust'来实现每次插入/删除一个标注就自动对标注进行重新编号.
       S   先执行r操作,然后执行s操作
       n   标准化所有的标准,方法为先收集所有的标注定义(包括自定义的标注定义)并移动到一个特定的区域中,然后按顺序对这些定义进行编号. 那些标注引用随后也会转换为相应的数字. 这常常是在完成一篇文档前的最后一个步骤(例如,要发送email时). 在导出文档时,exporter会自动作这一步.或者当触发类似message-send-hook时,类似的动作也会自动触发.
       d   删除当前位置的标注,连同所有的标注定义和标注引用
     #+END_EXAMPLE

     根据变量'org-footnote-auto-adjust[fn:24]'的值,可以设定每插入或删除一个注脚后,自动重编码和排序文档中的所有注脚.

   * C-c C-c :: 
	当光标位于注脚引用处时,跳转到注脚定义处. 若光标处于注脚定义处,则跳转回注脚引用处. 若在标注位置上用带前置参数的方式调用该命令,则弹出一个与C-c C-x f一样的菜单.

   * C-c C-o 或 鼠标左键 或鼠标右键 :: 
	注脚标签也是注脚定义与注脚引用相互之间的一种链接,你可以使用跳转链接的一般命令来在注脚定义/引用间相互跳转.
** Orgstruct的minior模式 :在Org之外进行结构编辑
   如果你喜欢Org-mode编辑结构和格式化列表时的这种直接了当的感受,你可能希望在其他mode下(比如Text-mode或者mail-mode)也能使用这些命令. 这时你可以使用名为'orgstruct-mode'的minor mode. 使用'M-x orgstruct-mode'来切换mode. 如果你想在默认情况下启用'orgstruct-mode',例如设置在Message-mode下默认启用该mode,可以在配置文件中添加下面中的任一句
   #+BEGIN_SRC emacs-lisp
     (add-hook 'message-mode-hook 'turn-on-orgstruct)
     (add-hook 'message-mode-hook 'turn-on-orgstruct++)
   #+END_SRC

   'orgstruct-mode'被激活后,当光标在一行(对org来说)看起来像是标题或列表项的第一行的文本行上时,大多数的结构编辑命令都可以被使用,即使在major mode原本定义的功能键跟'orgstruct-mode'提供的功能键有冲突时,也一样. 如果光标所在行看起来不是那种特殊的行,Orgstruct mode不会有任何作用,就跟没有开启Orgstruct mode一样. 若你使用的是'orgstruct++-mode',Org也会在major mode中引入缩进和填充设置,并且会探测列表项第一行后面的列表项内容.
* 表格
  Org自带一个快速而且直观的表格编辑器. 借助Emacs的'calc'包(参见<Gnu Emacs calculator manual>中的'Top'部分)甚至可以具备类似电子表格的计算能力.
** 内置的表格编辑器        :编辑简单的表格
   Org可以很容易的使用纯文本来格式化表格. 任何以'|'为非空白字符开头的行都被认为是表格的一部分. '|'也是列的分隔符[fn:25].一个表格看起来类似于这样:
   #+BEGIN_SRC org
     ,| Name  | Phone | Age |
     ,|-------+-------+-----|
     ,| Peter |  1234 |  17 |
     ,| Anna  |  4321 |  25 |     
   #+END_SRC
   
   每次在表格内按<TAB>,<RET>或'C-c C-c'都会自动对表格进行重排. <TAB>也使光标移动到下一个域(<RET>使光标移动到下一行)并且会在表格的最后一行或者在水平线之前的位置上添加一行新行.表格的缩进是由第一行来决定的. 任何以'|-'开头的行都被认为是水平分割行,并且在下一次表格重排时会扩展到整个表格的长度. 所有要创建上面的表格,你只需要键入
   #+BEGIN_SRC org
     ,|Name|Phone|Age|
     ,|-    
   #+END_SRC
   然后按下<TAB>来对齐表格并且开始在表格域内进行填充操作. 更快的操作是输入"|Name|Phone|Age"然后紧接着输入'C-c <RET>'.

   当在表格域内输入文本时,Org以一种特殊的方法来处理<DEL>,<Backspace>,和所有的字符键,这种方法保证了插入和删除操作可以避免对其他域产生影响. 另外,如果是在光标通过<TAB>,S-<TAB>或<RET>的方式移动到新表格域后立即输入,那么新表格域中的文本会被自动清空. 如果这种行为对你产生了困扰,可以配置变量'org-enable-table-editor'和'org-table-auto-blank-field'来取消这种行为.

   * 创建和转换命令
     * C-c | (org-table-create-or-convert-from-region) ::
          转换选定域为表格. 如果每个行都包含了至少一个TAB键,那么该函数假设选定域的值是以tab键作为分隔符的. 如果每一行都包含了一个逗号,那么选中域被假设为是CSV文件内容. 如果即没有TAB,也没有逗号,那么就认为选中域是以空格为分隔符的. 你可以使用前置参数来告诉函数使用哪种分隔符:C-u使用CSV格式,C-u C-u使用TAB为分隔符,前置参数N标示至少N个连续的空格或TAB键作为分隔符.

          如果没有选定域,这个命令会创建一个空的Org表格. 至少它比输入"|Name|Phone|Age<REt>|-<TAB>"这样来的简单.
   * 重对齐和表格域之间的移动
     * C-c C-c (org-table-align) ::
          对表格进行重对齐操作但不移动光标的位置
     * <TAB> (org-table-next-field) :: 
	  重对齐操作,光标移动到下一个域中. 如果需要的话创建一个新行.
     * S-<TAB> (org-table-previous-field) :: 
	  重对齐操作,光标移动到上一个域中.
     * <ERT> (org-table-next-row) :: 
	  重对齐表格,并且光标移到下一行. 如果需要的话会新键一行. 若光标在一行的开头或末尾,<ERT>也会新建一行,因此该功能可以用来分割表格.
     * M-a (org-table-beginning-of-field) :: 
	  移动到光标当前域的开头位置,或者(若已经在当前域的开头位置)上一个域的开头位置
     * M-e (org-table-end-of-field) :: 
	  移动到光标当前域的结尾位置,或者(若已经在当前域的结尾位置)下一个域的结尾位置
   * 列和行的编辑
     * M-<left> (org-table-move-column-left) ::
          移动当前列到左方(与左列交换位置)
     * M-<right> (org-table-move-column-right) ::
          移动当前列到右方(与右列交换位置)
     * M-<up> (org-table-move-row-up) :: 
	  移动当前行到上方(与上行交换位置)
     * M-<down> (org-table-move-row-down) :: 
	  移动当前行到下方(与下行交换位置)
     * M-S-<up> (org-table-kill-row) :: 
	  删除当前行或水平分隔行
     * M-S-<down> (org-table-insert-row) :: 
	  在当前行上面插入一新行. 如果加上前置参数,就在当前行下方插入新行.
     * C-c - (org-table-insert-hline) :: 
	  在当前行下面插入一新水平分隔行. 如果加上前置参数,就在当前行上方插入新水平分隔行.
     * C-c <RET> (org-table-hline-and-move) :: 
	  在当前行下方插入一水平分隔行,并且移动光标到该分隔行的下一行
     * C-c ^ (org-table-sort-lines) :: 
	  对当前块的表格行进行重新排序. 光标的位置指明根据哪一列来排序, 排序的范围就是上下两个最近的水平分隔行之间所包含的行,或者是整个表格. 如果光标处于第一列的前面,你会被提示需要输入按照哪一列来进行排序. 如果存在一个被选定的块,那么文本块的标记位置就指定了要排序的起始行,并且根据标记所在的列来进行排序,而光标所在的列(包括该列)为要排序的结束行. 该命令会提示您输入排序的类型(按字母排序,按数字排序或这按时间排序). 当该命令带有前置参数的时候,按字母排序是大小写敏感的.
   * 区域
     * C-c C-x M-w (org-table-copy-region) ::
          从表格中拷贝一个矩形区域到粘贴板. 光标所在的位置和标记的位置决定了矩阵的边界. 如果没有选定的区域,就把整个当前域拷贝到粘贴板中. 该操作会忽略水平分隔行.

     * C-c C-x C-w (org-table-cut-region) :: 
	  拷贝表格中的矩形区域的内容到剪贴板,并且对该矩形其余进行填空操作.因此这其实是个剪切操作

     * C-c C-x C-y (org-table-paste-rectangle) :: 
	  粘贴矩形区域内容到表格中. 该区域的左上角放置在当前域. 所有涉及到的域都会被覆盖掉. 如果矩阵不能合适地放到当前表格中,那么当前表会根据需要扩大. 该操作会忽略水平分隔行的存在.

     * M-<RET> (org-table-wrap-region) :: 
	  以光标位置为界限分割当前域,并且把剩下的部分移动到下一行. 如果存在已选定的文本块,并且光标和标记处于同一个列中,the text in the column is wrapped to minimum width for the given number of lines. 如果存在一个数字的前置参数,那么该参数会用来指定操作的行数. 如果没有选定的区域,而你又指定了前置参数,当前域会被清空,并且原先的内容会粘贴在当前域的上个域的内容后面.
   * 计算
     * C-c + (org-table-sum) ::
          把当前列(或选定区域)的数字求总和.求和的结果会在echo区域显示,并且可以用C-y命令插入结果

     * S-<RET> (org-table-copy-down) ::
          若当前域是空的,就会拷贝上方的第一个非空域的值. 如果当前域不是空的,则拷贝当前域的值覆盖下一行的值,并且鼠标也跟着下移. 根据变量'org-table-copy-increment'的设置,若域中的值是整数,则拷贝时会自增. 若域中的整数值太过巨大了,则该值不会被增加. 另外,若前置参数为0,则会暂时地禁止这种增加行为. 该键序列在shift-selection和相关模式中也有定义,因此可能会有冲突(参见[[#Packages that lead to conflicts with org mode][与org-mode冲突的包]])
   * 杂项
     * C-c ` (org-table-edit-field) ::
          在另一个窗口中编辑当前域. 这在编辑显示不下内容的域时非常有用(参见[[#Column width and alignment][列宽度与对齐]]). 当添加了C-u前缀时,仅仅只是把当前域的内容全部显示出来,这样就能在本地编辑该域了. 如果加了两个C-u前缀则会保持一个编辑窗口,该窗口的内容随着光标的所在域不同而动态改变. 这种模式会一直持续到光标离开表格,或者你重复输入该命令'C-u C-u C-c `'

     * M-x org-table-import :: 
	  把一个文件当作表格导入进来. 文件内容必须是以TAB或空格分隔的(通常从电子表格或数据库中导出的数据是可以定义为以TAB分隔的文本文件的). 该命令先插入文件内容到缓冲区内然后调用转换命令(org-table-create-or-convert-from-region)将内容为一个表格. 任何前缀参数都会被传递给转换命令作为决定分隔符的参数.

     * C-c | (org-table-create-or-convert-from-region) :: 
	  也可以通过粘贴以tab分隔的文本到Org缓冲区的方式来导入表格.方法是,先用C-x C-x选择(也可以用其他方法)要粘贴的文本,然后使用'C-c |'命令

     * M-x org-tableexport :: 
	  导出表格,默认是以TAB作为分隔符. 常常用来与电子表格或数据库程序作数据交换. 导出文件的格式可以在变量'org-table-export-default-format'中配置. 你也可以在子树中用属性'TABLE_EXPORT_FILE'来定义导出文件的名字和属性'TABLE_EXPORt_FORMAT'来定义导出文件的格式. Org支持将表格导出为许多格式. 导出的格式与Orgtbl radio表格的格式是一样的. 详细描述请参见'[[#Translator functions][转换功能]]'.

     如果你不喜欢Org的表格功能(因为你可能象要有记录一些以|开头的行,而不作为表格),你可以用下面的配置语句关掉该功能
     #+BEGIN_SRC emacs-lisp
       (setq org-enable-table-editor nil)
     #+END_SRC
     这样一来,唯一可用的表格命令就是C-c C-c,该命令用来作人工的重对齐

** 列的宽度与对齐          :不使用自动化的设置
   列的宽度是有表格编辑器自动决定的. 列的对齐方式也是由列中的值的类型来自动决定的,若值类似于数字则默认右对齐,否则默认为左对齐.

   有时候,一个或多个域会由于包含了太多的文本而导致列的宽度看起来很不方便. 又或者你想象让多个列不管内容多少都保持固定的宽度. 要设置[fn:26]列的宽度, 在列的任何一个域中包含类似'<N>'这样的字符串即可. 这里N的意思代表了该列的宽度限定为N个字符长度. 下一次重排时,该列的宽度会调整为这个值.例如
   #+begin_example
     |---+------------------------------|               |---+--------|
     |   |                              |               |   | <6>    |
     | 1 | one                          |               | 1 | one    |
     | 2 | two                          |     ----\     | 2 | two    |
     | 3 | This is a long chunk of text |     ----/     | 3 | This=> |
     | 4 | four                         |               | 4 | four   |
     |---+------------------------------|               |---+--------|
   #+end_example

   太长的域会被裁减并且以字符串'=>'结尾. 注意,此时完成的字符串还保留在缓冲区内,只不过被隐藏起来罢了. 要查看完整的文本,只需要把鼠标移到要查看的域上过一会儿,会有一个小提示窗口弹出来,里面有完整的内容. 要编辑这个域,使用命令C-c `(C-c 接着反引号). 该编辑命令会打开一个新窗口给你编辑,里面是完整的内容.输入C-c C-c完成编辑

   打开一个文件时,若文件中存在缩小的列的表格,此时列中的文本不会自动进行隐藏动作.这时候的表格看起来不太好看,需要重排. 设置选项'org-startup-align-all-tables'会使org在打开文件时自动重排其中的所有表格,当然这个动作也会降低org启动的速度. 你也可以在每个文件中设置这个属性,方法为:
   #+begin_src org
     ,#+STARTUP: align
     ,#+STARTUP: noalign
   #+end_src

   默认清空下富含数字的列是右对齐的,富含字符串的列是左对齐的,但你也可以自定义列的对齐方式,方法为在列中使用类似'<r>','c'[fn:27],或'<l>'这样的字符串来定义该列的对齐方式. 当然你也可以同时定义列对齐方式和列的宽度,例如'<r10>'.

   当导出文档时,只包含指定格式的字符串的行会自动移除不被导出.
** 对列进行分组            :Grouping to trigger vertical lines
   当Org导出表格时,默认是不导出表格中的竖线的,因为通常来说这不美观. 然而有时候竖线可用用来把表格划分为几个列的组(类似于水平分隔行把行划分为几个组别). 要定义列的组别,你可以使用一种特殊的行,在这一行里,第一个域只包含'/'. 接下来的域中可用包含'<'(表格这一列是一个组别的起始列),或者'>'(指示这一列是组别的结束列),或者'<>'('<'和'>'中间没有空格,这表示这一列自成一组). 组别之间的边界在导出时会用竖线标示出来.如下例子所示
   #+begin_src org
     ,| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
     ,|---+-----+-----+-----+---------+------------|
     ,| / |   < |     |   > |       < |          > |
     ,| 1 |   1 |   1 |   1 |       1 |          1 |
     ,| 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |
     ,| 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |
     ,|---+-----+-----+-----+---------+------------|
     ,#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))
   #+end_src
   
   你也可以只是在想要竖线的地方插入列组的起始符号即可.例如
   #+begin_src org
     ,|  N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
     ,|----+-----+-----+-----+---------+------------|
     ,| /  | <   |     |     | <       |            |
   #+end_src
** 名为Orgtbl的minor mode :使用minor-mode中的表格编辑器
   如果你喜欢Org表格编辑器的直观操作，你也可以在别的mode(例如text-mode或mail-mode)中使用它. 名为'Orgtbl-mode'的minor mode可以实现这一点. 你可以通过'M-x orgtbl-mode'来切换该模式. 如果你想在进入特定mode(例如Message mode)时自动进入该minor mode,使用如下的配置语句
   #+begin_src emacs-lisp
     (add-hook 'message-mode-hook 'turn-on-orgtbl)
   #+end_src

   此外,通过一些配置,还可以用Orgtbl-mode实现在任意标签内包含表格. 例如,它可以实现在构建LaTeX表格时兼顾LaTeX的易用和Orgtbl-mode的能力(包含了电子表格的能力). 详细请见[[#Tables and lists in arbitrary syntax][任意标签中的表格和列表]]
** 电子表格               :带有电子表格功能的表格编辑器
   表格编辑器使用Emacs的'calc'包来实现类似电子表格的功能. 它也可以根据Emacs Lisp表达式来根据其他域中的值计算得出当前域的值. 虽然功能上类似,但是严格来说,Org的实现方式与其他电子表格的实现方式是不一样的. 例如, Org能够理解column formula(列公式)的概念，列公式会自动应用到当前列的每一个非最开头的域中，而不用在每一个域中都复制一份公式(formula). Org还提供了一个formula调试器和一个formula编辑器, 该formula编辑器会高亮公式中所引用到的域,并且可以通过方向键来移动该引用.
*** 引用                  :如何引用其他域或区域
    要根据其他域的值来计算表格中的值,公式必须引用到其他域或区间. 域可用通过名称,通过绝对坐标和相对坐标用这三种方式来引用. 要确定某个域的坐标是什么,在这个域中按下'C-c ?'就会在echo区域显示出该域的坐标,也可以按下'C-c }'来切换显示坐标网格.

    * 域引用
      在公式中有两种方法来引用其他域中的值. 第一种类似于其他电子表格,你可以用一个字母/数字组合起来表示一个域的引用,例如'B3'的意思是第3行的第2个域. 然而,Org更推荐[fn:28]使用另一种更加通用的表示方法,这种表示方法看起来是这样的:
      #+begin_example
         @row$column      
      #+end_example

      列的可以用绝对坐标表示,类似于这样:$1,$2...$N.也可以用相对坐标表示(当前列为基准值)类似于这样:$+1,$-2,$<,$>.其中$<固定表示第一列,$>固定表示最后一列. 另外,你可以用$>>>表示从右往左数第3列

      行在计算坐标时,值计算数据行,而 *不算水平分隔行(hline)* .类似于列的表示方法,你可以使用绝对行数来表示,类似于@1,@2...@N,也可以用相对行数来表示,类似于@+3,@-1,@<和@>. 其中@<固定表示表格中的第一行,@>固定表示表格中的最后一行[fn:29].另外你也可用通过与hline的相对位置来引用行:@I引用第一个hline,@II引用第二个hline,一次类推. @-I引用的是当前行的上一个hline,@+I是当前行的下一个hline. 你也可以通过@III+2表示第3个hline的后2行

      $0和$0分别引用的是当前行和当前列,也就是要被计算的域的行和列. 另外,如果你忽略了引用的行或列部分,默认情况下使用当前域的行或列代替.

      Org中不带符号只含数字的引用是固定引用,也就是说如果你在两个不同的域中使用同一个引用表示法,引用的是同一个域. 而org中带符号和数字的引用是浮动引用,即相同的引用表示法可能引用的是不同的域,这取决于公式所在的那个域的位置.

      下面是一些例子:
      #+begin_example
              
        @2$3      2nd row, 3rd column (same as C2)
        $5        column 5 in the current row (same as E&)
        @2        current column, row 2
        @-1$-3    the field one row up, three columns to the left
        @-I$2     field just under hline above current row, column 2
        @>$5      field in the last row, in column 5
        
      #+end_example

    * 区间引用
      
      你可以引用一个矩形区间,方法是指明两个域引用,并用'..'连接起来. 如果这两个域都处于同一个行,可用只使用'$2..$7'这样来代替, 但若至少有一个域处于不同的行,那么你需要对至少第一个域使用完整的@row$column格式(即引用必须以@开头,以便能够正确第解释).例如
      #+begin_example
              
        $1..$3        first three fields in the current row
        $P..$Q        range, using column names (see under Advanced)
        $<<<..$>>     start in third column, continue to the one but last
        @2$1..@4$3    6 fields between these two fields (same as A2..C4)
        @-1$-2..@-1   3 numbers from the column to the left, 2 up to current row
        @I..II        between first and second hline, short for @I..@II
        
      #+end_example

      区间引用返回一个值的vector(向量),并传入Calc向量函数中执行. 区间中的空域正常来说都会被忽略掉,这样向量中就只包含了非空域(要切换这种行为,参见下面的'E' mode).如果区域中所有的域都为空域,那么就会返回'[ 0 ]'一次来避免公式中发生语法错误.

    * 公式中的域坐标

      若要在Calc公式使用当前域的行号和列号,可用用@#和$#来表示. 在传统的Lisp公式中等价于'org-table-current-dline'和'org-table-current-column'.例如:
      #+begin_example
              
        if(@# % 2, $#, string(""))   column number on odd lines only
        $3 = remote(FOO, @@#$2)      copy column 2 from table FOO into
                                     column 3 of the current table
        
      #+end_example

      对于第二个例子,FOO表格至少需要有与当前表格一样多的行. 注意:这对于大量的行操作来说是很不效率的[fn:30].

    * 命名引用
      '$name'会被被解释成列名，参数或者常量. 可以通过变量'org-table-formula-constants'来定义全局常量,或者通过类似下面一行的方法来为某个文件定义本地常量.
      #+begin_src org
        ,#+CONSTANTS: c=299792458. pi=3.14 eps=2.4e-6
      #+end_src
      
      另外,在表格公式中,也可以使用属性(参见章节[[#Properties and columns][属性与列]])来作为常量使用[fn:31]:你可以通过名为'$PROP_ Xyz'的常量来访问属性':Xyz:',Org会在表格所在大纲条目及其上级条目中搜索该属性. 如果你加载了'constants.el'这个包,那么Org也会使用这个包来匹配常量,这个包甚至包括自然常量(例如$h表示普朗克常量)和单位(例如$km表示千米). 列名和参数可以在一个特殊的表格行内指定,更具体描述以后再说,可以参见[[#Advanced features][高级特性]].现阶段所有的名字都必须以字母开头,以后可能可以以字母和数字开头.

    * 远程引用
      你也可以引用其他表格中的常量,域和区间, 这些表格可以在同一个文件也可以在不同文件中. 引用的方法为
      #+begin_src org
        ,        remote(NAME-OR-ID,REF)
      #+end_src
      这里NAME可以是当前文件中当前表格以前所定义的表格名字. 这里表格名字可以用'#+TBLANAME:表格名字'来定义. NAME的值也可以是某个大纲条目的ID(甚至可以是其他文件中的大纲条目),这时引用的就是该条目中的第一个表格. REF是一个绝对域或绝对区间的引用(具体方法如上面所示,例如@3$3或者$somename,这些绝对引用需要确保在被引用表格中都是可用的).

*** Calc的公式语法         :使用Calc计算
    一个公式可用是任何能够被Emacs的'calc'包所识别的代数表达式. *注意,在'Calc'中,'/'的操作符优先级要比'*'低,因此'a/b*c'会被解释为'a/(b*c)',这一点与标准不符*. 在calc-eval(参见GNUEmacs Calc　Manual中'Calling Calc from Your Lisp Programs'章节的)进行计算之前,变量替换会以之前所描述的方式发生. 公式之中的区域变量可用直接放入Calc的向量函数(例如'vmean'和'vsum')中作为参数使用.

    公式可用在分号之后附加上可选的选项模式字符串. 这种选项模式字符串由标志所组成,这些标志会在公式被执行时影响Calc和其他模式. 默认情况下,Org使用标准的Calc模式(精度为12位,角度单位为度,分数和symbolic模式为关闭状态). 然而,公式在显示时,会自动调整为(float 8)以便保持表格的紧凑. 可用通过变量'org-calc-default-modes'来配置这些默认设置
    #+begin_example
      p20           set the internal Calc calculation precision to 20 digits
      n3 s3 e2 f4   Normal, scientific, engineering, or fixed
                    format of the result of Calc passed back to Org.
                    Calc formatting is unlimited in precision as
                    long as the Calc calculation precision is greater.
      D R           angle modes: degrees, radians
      F S           fraction and symbolic modes
      N             interpret all fields as numbers, use 0 for non-numbers
      E             keep empty fields in ranges
      L             literal
    #+end_example
    除非你使用大整数或高精度计算式,并且需要显示浮点式数字,你可以提供一个printf格式说明字符串[fn:32]来对Calc计算并传回Org的结果进行重新格式化,而不是Calc自己作这种格式化. 下面是一些例子
    #+begin_example
      $1+$2                Sum of first and second field
      $1+$2;%.2f           Same, format result to two decimals
      exp($2)+exp($1)      Math functions can be used
      $0;%.1f              Reformat current cell to 1 decimal
      ($3-32)*5/9          Degrees F -> C conversion
      $c/$1/$cm            Hz -> cm conversion, using ‘constants.el’
      tan($1);Dp3s1        Compute in degrees, precision 3, display SCI 1
      sin($1);Dp3%.1e      Same, but use printf specifier for display
      vmean($2..$7)        Compute column range mean, using vector function
      vmean($2..$7);EN     Same, but treat empty fields as 0
      taylor($3,x=7,2)     Taylor series of $3, at x=7, second degree
      
    #+end_example

    Calc还包含了一个完整的逻辑操作集合. 例如
    #+begin_example    
      if($1<20,teen,string(""))            如果第一列(age列)比20小,则返回值"teen",否则返回空值
    #+end_example
    
    注意,在计算时长时,还可以使用两个特定的标志T和t,具体参见[[#Durations and time values][时长与时间]]
*** Emacs Lisp写成的公式   :使用Emacs Lisp来写公式
    你可以使用Emacs Lisp来写公式;这在当Calc提供的函数不足与实现我们期望的操纵字符串和控制结构的功能时非常有用. 如果一个公式是以单引号后跟一个开括号开头的,则该公式被认为是Lisp形式的. 该Lisp的运算结果应该是返回一个字符串或者是数字的. 就像使用'calc'公式一样,你可以在分号';'后面指定模式和printf格式. 使用Emacs Lisp形式,你需要关注域引用插入到form中的方式. 默认情况下,一个引用是将域中的值以字符串的形式(包括在双引号内)插入的. 如果开启了M模式,则所有的被引用元素都会被转化为数字(非数字域转化为0)并且在插入时作为Lisp数字型插入(不包含引号). 如果你提供了'L'标志,所有的域将会以字面上的方式(不包含引号)插入公式中. 也就是说,如果你想一个引用作为字符串来插入到Lisp形式的公式中,则使用双引号来包含引用表达式(例如"$3")即可. 区域在插入时会作为一系列以空格分隔的域,这样你就可以把它们潜入list或vector符号中. 下面是一些例子--注意我们在用Lisp计算时是如何使用'N'模式的
    #+begin_example
          
      Swap the first two characters of the content of column 1
        '(concat (substring $1 1 2) (substring $1 0 1) (substring $1 2))
      Add columns 1 and 2, equivalent to Calc's $1+$2
        '(+ $1 $2);N
      Compute the sum of columns 1-4, like Calc's vsum($1..$4)
        '(apply '+ '($1..$4));N
      
    #+end_example
*** 时长和时间的值          :如何计算工期和时间的值
    如果你希望计算的是时间的值,你需要在Calc公式或Elisp公式中使用T标志
    #+begin_src org
      ,  |  Task 1 |   Task 2 |    Total |
      ,  |---------+----------+----------|
      ,  |    2:12 |     1:47 | 03:59:00 |
      ,  | 3:02:20 | -2:07:00 |     0.92 |
      ,  #+TBLFM: @2$3=$1+$2;T::@3$3=$1+$2;t
      , 
      
    #+end_src
    输入的时长值必须是以[HH:MM[:SS]]的形式的,这里秒数是可选的. 当使用了T标志,计算出来的时长会以HH:MM:SS的形式来显示(参见上面例子的第一个公式). 当使用t标志时,计算出来的时长的显示方式是根据变量'org-table-duration-custom-format'的不同而不同的, 该变量默认单位为小时并且会以小数的形式来显示结果(参见上面的第二个公式).

    Org也支持副的时长,而且数字在作加减法时会被认为是秒数.
*** 域公式和区间公式        :给某个域或某个区间分配一个公式
    要给一个域分配公式,直接输入公式,并在前面加上':=',例如':vsum(@II..III)'. 当你在 *光标还在域中时* 按下<TAB>或<RET>或C-c C-c,公式就会被保持在该域中,并且会自动计算并把计算结果展示为域的值.

    公式是统一存储在一个特殊行中的,该行是以"#+TBLFM:"开头的,并且直接就在表格的下方紧靠表格. 如果你在第3行的第4个域中输入公式,那么该公式就会类似于'@3$4=$1+$2'这样. 当使用命令插入/删除/交换了行或者列时,公式中的绝对引用(但是不包括相对引用)也会跟着改变,以保证引用还是指向与修改前同一域. 要避免这种情况发生(特别是在公式中使用了区间引用,表格的边界引用(使用@<,@>,$<,$>)或hlines引用(使用@I符号)的情况下), 你需要使用一般的编辑命令来改变表格结构.当使用一般的编辑命令来修改表结构的情况下,域引用的这种自动适配功能当然是不会发生的--这样的话,你需要自己修正公式.

    除了直接在域中输入公式,你也可以使用下面这些命令
    * C-u C-c = (org-table-eval-formula) ::
         为当前域分配一个新的公式. 该命令提示你输入公式(默认值为从#+TBLFM:行中获得公式),然后应用该公式到当前域并保持起来.

         在公式的左侧也可以是特别的表达式,以这种方法可用为一系列不同的域分配公式. 并没有快捷方式来输入这种区间公式. 要增加这种区间公式,需要使用公式编辑器(参见[[#Editing and debugging formulas][编辑和调试公式]])或者直接编辑$+TBLFM:行

    * $N= (这里N表示第几列) ::  
	     列公式,对整个列生效. 这种公式如此常见以至于Org以一种特殊的方式来处理这些公式,参见[[#Column%20formulas][列公式]]

    * @N= (这里N表示第几行) :: 
	     行公式,对一行的所有域生效. @>=表示最后一行.

    * @1$2..@4$3= :: 
		    区间公式,对所指定的矩阵区间内的所有域有效. 这可以用来分配公式给行中的一些域(但不是所有的域)

    * $name= :: 
		命名域,具体参见[[Advanced features][高级特性]]
*** 列公式                 :对整个列都生效的公式
    #<<Column formulas>>
    当你分配一个列公式到一个列时(使用类似$3=这样的语法),该列的所有域都会使用同一个公式,然而也会有一些例外:(i) 如果表格包含了水平分隔行hlines,任何在第一个水平分隔行之前的行都被认为是表头信息,因此就不会被列公式所改变. (ii) 如果一个域已经定义了域公式或区间公式,那么它也被列公式排除在外(即域公式和列公式的优先级高于列公式). 上诉的两个条件使得列公式很容易使用.

    要分配一个列公式给某个列,直接输入公式到该列的任何一个域中,并在前面加一个-号,就像这样'=$1+$2'. 当你在光标还在域的情况下按下<TAB>或<RET>或C-c C-c, 输入的公式就会作为该列的列公式而存储起来,然后经过计算,把结果在当前域(而不是当前列)中展示出来. 如果列中的某个域只包含'=',那么该列中前一个存储起来的公式会被应用到该域中. 对于每个列来说,Org只会记住最近使用的那个公式. 在'#+TBLFM:'行,列公式看起来类似于'$4=$1+$2'这样. 列公式的左边不能是列的名字,它必须是数字形式的列引用或$>

    除了输入以=开头的公式到域中,你也可以使用下面的命令来创建列公式
    * C－c = (org-table-eval-formula) ::
         为该列应用一个新的列公式,然后使用该公式的计算结果显示在当前域中. 该命令会提示你输入列公式,默认值为#+TBLFM行的公式. 输入的列公式会应用到当前域中并存储起来. 如果加上一个数字前缀(例如C-5 C-c =),该命令会应用到当前列中连续N个域中.
*** 编辑和调试公式          :修正公式
    你可以在minibuffer或者直接在域中编辑一个个的公式. Org也可以准备一个包含表格中所有公式的特殊缓存区. 当对公式进行编辑时,Org在可能的情况下会转换引用为标准格式(类似于B3或者D&这样的引用). 如果你想只使用引用内部格式(类似于@3$2或者$4),请配置变量'org-table-use-standard-references'

    * C-c = 或者 C-u C-c = (org-table-eval-formula) ::
         在minibuffer中编辑当前列/域的公式. 参见[[#Column formulas][列公式]]和[[#Field and range formulas][域与区间公式]].
    * C-u C-u C-c = (org-table-eval-formula) :: 
	 为当前域重新设定一个公式(可以使域公式也可以是列公式),使用这个命令你可以直接在域中编辑公式. 与在minibuffer中编辑公式相比,这种方法的优势在于你可以使用命令C-c ?查询域的信息.
    * C-c ? (org-table-field-info) :: 
	 当在表格域中编辑公式时,高亮公式中鼠标所在位置的域引用所引用的域.
    * C-c } :: 
	       切换显示行列编号,using overlays(org-table-toggle-coordinate-overlays). 这些信息在每次表格重排之后都会自动更新;你也可以使用C-c C-c来强制更新信息.
    * C-c } :: 
	       切换开启或者关闭公式调试器(org-table-toggle-formula-debugger). 具体信息参见下面
    * C-c ' (org-table-edit-formulas) :: 
	 打开一个特殊的缓冲区(公式编辑器),可以在里面编辑当前表格所有的公式,在这个缓冲区中,每个公式都显示一行. 如果当前域包含包含有一个激活的公式,公式编辑器中的光标会标示出它来. 当光标在这个特殊的缓冲区中时,Org会自动高亮任何光标位置的域引用所引用的域. 你可以在这个特殊缓冲区中使用下面这些命令来编辑,删除和新增公式
      * C-c C-c 或 C-x C-s (org-table-fedit-finish) ::
	   退出公式编辑器,并且保持修改后的公式. 如果加了C-u前缀,那么会对整个表格应用新修改的公式(表格中所有的公式都会被重新计算一遍,然后显示出来)
      * C-c C-q (org-table-fedit-abort) :: 
	   退出公式编辑器,而不做任何修改
      * C-c C-r (org-table-fedit-toggle-ref-type) :: 
	   对表格编辑器中的所有引用切换显示格式,在标准格式(类似于B3)和内部格式(类似于@3$2)间切换
      * <TAB> (org-table-fedit-lisp-indent) :: 
	   美化并缩进当前光标所在的Lisp公式. 当光标所在行包含有Lisp公式时,使用Emacs Lisp的规则来格式化公式. Another <TAB> collapses the formula back again. 在open formula(开放式公式??)中,<TAB>跟在Emacs Lisp mode一样起着重新缩进的功能.
      * M-<TAB> (lisp-complete-symbol) :: 
	   补完Lisp符号,就跟在Emacs Lisp mode中一样
      * S-<up>/<down>/<left>/<right> :: 
	   切换光标所在的引用. 例如如果现在光标所在的引用是B3,你按下S-<right>之后,该引用变成了C3. 这对相对引用和hline引用也有效
      * M-S-<up> (org-table-fedit-line-up) 或 M-S-<down> (org-table-fedit-line-down) :: 
	   上下移动Org buufer中行公式的test line
      * M-<up> (org-table-fedit-scroll-down> 或 M-<down> (org-table-fedit-scroll-up) :: 
	   滚动表格所在的窗口
      * C-c } :: 
		 显示/关闭表格中各个域的坐标
    把一个域清空并不会删掉这个域的公式,因为公式实际上是保存在其他行(#_TBLFM行)-这样在下一次重新计算时,该域又会有新的值初出现. 要删掉一个域中的公式,你需要在编辑公式要求输入新公式时输入一个空回复,或者直接编辑#+TBLFM行

    你可以直接编辑'#+TBLFM'行,然后在该行运行C-c C-c来对改变后的公式进行重新计算.或者也可以在表格中执行普通的重计算命令.

    *调试公式*

    当公式的计算产生错误时,域中的内容变为字符串'#ERROR'. 如果你想知道在变量替换和计算时都发生了什么以便寻找bug,你可以在Tbl菜单上打开公式调试功能然后重新对改公式计算一次(在域中按下C-u C-u C-c = <RET>).随后就会显示详细信息出来.
*** 更新表格               :重新计算所有相关域
    表格一般来说不会自动进行重计算,而是需要通过命令来触发. 要想使表格半自动地进行重计算,请参见[[#Advanced features][高级特性]],

    要想对整个表格或者一整行进行重新计算,可用使用下面的命令:
    * C-c * (org-table-recalculate) ::
         重新计算当前行,计算的方法是首先从左到右对该行的每个域都计算一次列公式,然后再当前行的域公式和区间公式.
    * C-u C-c * 或C-u C-c C-c :: 
	 一行一行地重新计算整个表格. 任何在第一个hline之前的行都被认为是表头而排除在重计算操作之外
    * C-u C-u C-c * 或 C－u C-u C-c C-c (org-table-iterate) :: 
	 重复对表格进行重计算,直到没有变化可以继续产生. 如果有些域的计算结果依赖于其他域的值,而这些被依赖的域的值需要在指向了一系列的计算之后才能得到的时候,这时候这项功能就很有必要了.
    * M-x org-table-recalculate-buffer-tables :: 
	 重新计算当前缓冲区中的所有表格
    * M-x org-table-iterate-buffer-tables :: 
	 对当前缓冲区中的所有表格进行迭代计算,以便converge(汇聚??)表与表之间的依赖关系.
*** 高级特性               :域和列的名字,参数和自动重计算
    #<<Advanced features>>
    如果你想自动重计算域的值,或者你向为域和列分配名字[fn:33],你需要保留表格的第一列作存放特殊的标志字符.

    * C-# (org-table-rotate-recalc-marks) ::
         使第一列的标志字符在' ','#','*','!','$'这几个状态之间切换. 如果存在一个激活的块,则会改变该块中所有的标志.

    下面的例子是一个记录学生考试成绩的表格,里面用到了这些特性:
    #+begin_src org
      ,|---+---------+--------+--------+--------+-------+------|
      ,|   | Student | Prob 1 | Prob 2 | Prob 3 | Total | Note |
      ,|---+---------+--------+--------+--------+-------+------|
      ,| ! |         |     P1 |     P2 |     P3 |   Tot |      |
      ,| # | Maximum |     10 |     15 |     25 |    50 | 10.0 |
      ,| ^ |         |     m1 |     m2 |     m3 |    mt |      |
      ,|---+---------+--------+--------+--------+-------+------|
      ,| # | Peter   |     10 |      8 |     23 |    41 |  8.2 |
      ,| # | Sam     |      2 |      4 |      3 |     9 |  1.8 |
      ,|---+---------+--------+--------+--------+-------+------|
      ,|   | Average |        |        |        |  29.7 |      |
      ,| ^ |         |        |        |        |    at |      |
      ,| $ | max=50  |        |        |        |       |      |
      ,|---+---------+--------+--------+--------+-------+------|
      ,#+TBLFM: $6=vsum($P1..$P3)::$7=10*$Tot/$max;%.1f::$at=vmean(@-II..@-I);%.1f 
    #+end_src

    注意事项:请注意,对于这些特殊的表格来说,使用'C-u C-c *' 来重计算表格,只对标记了'#'或'*'的行,和那些分配了公式的域生效. 列公式对当第一个域为空的行无效.

    这些标志字符的意义如下所示:
    * '!' ::
         该行的域中的值为列的名称,因此你可以使用引用'$Tot'来代替'$6'
    * '^' :: 
	     这一行定义了上一行相应域的名称. 有着这种定义,任何表格中的公式可以使用'$m1'来引用值'10'. 而且如果你为这个命名了的域分配公式,该公式会被存储为'$name=...'的形式
    * '-' :: 
	     类似于'^',但是是为下一行的相应域定义名字的.
    * '$' :: 
	     这一行的域可以为公式定义参数. 举个例子,如果'$'行中的某个域包含了'max=50',则表格中的公式可以使用'$max'来引用50这个值. 参数就好像是常量一样,所不同的是它们(参数)能够根据每个表格来定义.
    * '#' :: 
	     当在行中按下了<TAB>或<RET>或S-,TAB>,所有该标示的行中的域会自动重新计算. 另外当使用全局重计算命令(C-u C-c * )时这些行也会进行重计算,而无标示的行则对该全局重计算命令无效.
    * '*' :: 
	     当使用全局重计算命令(C-u C-c * )时,该标志行也会进行重计算,但是该标志行并不会自动进行重计算. 当自动重计算功能会明显降低编辑效率时,该标志很有用.
    * '' :: 
	    无标志字符的行在使用C-u C-c * 进行重计算时并不会进行重计算. 只有标示了'#'或'*'的行才会重新计算.
    * '/' :: 
	     不导出带有该标志的行. 对那些包含了narrowing '<N>'标记(缩小的'<N>'标记)或列的分组标志很有用.

    最后,你可能会对使用梦幻般的'calc.el'包能实现那些功能很感兴趣, 下面是一个表格,它计算了the Taylor series of degree n at location x for a couple of functions. 
    #+begin_src org
      ,|---+-------------+---+-----+--------------------------------------|
      ,|   | Func        | n | x   | Result                               |
      ,|---+-------------+---+-----+--------------------------------------|
      ,| # | exp(x)      | 1 | x   | 1 + x                                |
      ,| # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |
      ,| # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |
      ,| # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |
      ,| # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |
      ,| * | tan(x)      | 3 | x   | 0.0175 x + 1.77e-6 x^3               |
      ,|---+-------------+---+-----+--------------------------------------|
      ,#+TBLFM: $5=taylor($2,$4,$3);n3
      
    #+end_src

** Org-Plot              :org表格绘图
   通过使用'Gnuplot'[[http://www.gnuplot.info]] 和'gnplot-mode'[[http://cars9.uchicago.edu/~ravel/software/gnuplot-mode.html]] ,Org-Plot可用根据表格中的数据生成2D和3D图表. 这里有一个例子: 首先确保你安装了Gnuplot和Gnuplot mode,然后对下面的表格调用'org-plot/gnuplot'
   #+begin_src org
     ,#+PLOT: title:"Citas" ind:1 deps:(3) type:2d with:histograms set:"yrange [0:]"
     ,| Sede      | Max cites | H-index |
     ,|-----------+-----------+---------|
     ,| Chile     |    257.72 |   21.39 |
     ,| Leeds     |    165.77 |   19.68 |
     ,| Sao Paolo |     71.00 |   11.50 |
     ,| Stockholm |    134.19 |   14.33 |
     ,| Morelia   |    257.56 |   17.67 |
   #+end_src

   注意,Org Plot会自动把表格的标题作为生成图表的标签. 通过表格前的#+PLOT:行,你还可以定义plot的标签,类型,内容和展示. 下面列出了完整的Org-plot选项. 更多的信息和例子请参见Org-plot教程[[http://orgmode.org/worg/org-tutorials/org-plot.html]]

   *Plot Options*
   * set ::
     当绘图时,用于设置任何的gnuplot选项
   * title :: 
	      指定plot的标题
   * ind :: 
	    指定表格的哪一列作为x轴
   * deps :: 
	     指定描绘哪些列,该设置的格式类似于Lisp中的list,由小括号括起来,内部用空格分隔,例如'dep:(3 4)'指定只描绘第3,4列(默认情况下,除了指明为ind的列,其他的列都会被描绘)
   * type :: 
	     指定plot是2d还是3d还是grid的
   * with :: 
	     对每一个要被绘制的列都插入一个指定的with选项(例如,lines,points,boxes,impulses,等等). 默认值为lines
   * file :: 
	     如果你想将描绘输出成一个文件,指定输出文件的路径
   * labels :: 
	       用一个列表指定各输出列的标签(默认情况下,如果列的标题村爱的话,使用列标题作为标签)
   * line :: 
	     在gnuplot脚本中插入指定的一整行(Specify an entire line to be inserted in the Gnuplot script. )
   * map :: 
	    当描绘类型为3d或grid时,该选项的值设为t则在描绘时描绘的是一个平面映射而不是3维图形(set this to t to graph a flat mapping rather than a 3d slope)
   * timefmt :: 
		指定Org-mode的时间戳格式,因为它们会被Gnuplot所解析,默认格式为'%Y-%m-%d-%H:%M:%S'
   * script :: 
	       如果你想实现完全的自定义,你可以指定一个脚本文件(把文件名放在双引号内)来实现描绘动作. 在正真描绘之前,这个特定脚本中的每个'$datafile'会被替换成生成的数据文件的实际路径. 注意:即使你设置了这个选项,你也可能仍然需要定义plot的type,因为这个选项会影响到生成的数据文件的内容.
* 超链接
  类似于HTML,Org提供了文件内部的链接,和文件外部的链接(可以链接到其他文件,Usenet文章,email等等)
** 链接的格式              :Org中的链接是什么格式的
   Org会识别类似URL的链接并且把它们作为可点击的链接. 然而,Org中链接的一般形式看起来像下面这样子
   #+begin_example
   [[链接地址][描述]]  或者 [[链接]]
   #+end_example

   一旦缓冲区中的链接被补完(所有的中括号都有了), Org会只显示链接中的'描述',而不是链接的完整形式. Link会以'org-link'定义的方式高亮,默认情况下是以下划线标示起来. 你可以直接编辑链接的显示部分(当有描述部分是为'描述'部分,否则为'链接'部分). 要编辑不可见的'链接'部分,把光标放在要编辑的链接上然后按下C-c C-l

   如果光标在链接的起始部分或就在链接中显示文本的后面,然后你按下<DEL>或<BACKSPACE>时,你删掉的是链接中不可见的中括号. 这样会使这个链接变得不完整,因此该链接的内部表现形式会以纯文本的方式展现出来. 再补完这个中括号又会使链接隐藏其内部结构. 要显示出所有链接的内部结构,使用菜单'org->hyperlinks->Literal links'
** 内部链接                :链接到同一文件的不同地方
** 外部链接                :类似与URL这样的链接,可以链接到全世界
** 链接处理                :创建,插入和进入链接
** 在Org外使用链接         :从我的C源码中链接过来的?
   不仅在Org模式中,在其他模式下你也可以插入和进入使用Org语法标示的链接. 要做到这一点,你可以就像下面所示创建两个全局命令(你可以选择自己喜欢的全局键)
   #+begin_src emacs-lisp
     (global-set-key "\C-c L" 'org-insert-link-global)
     (global-set-key "\C-c o" 'org-open-at-point-global)
   #+end_src
** 链接的缩写              :复杂链接的缩写形式
** 文件链接中的搜索选项     :链接到特殊的位置
** 客户化搜索              :当默认的搜索不够用的时候
* Footnotes

[fn:1] install-info的输出也是系统依赖的. 在特定的Debian及其衍生系统中使用两种不同版本的install-info程序.如果你看到
  #+BEGIN_EXAMPLE
    This is not dpkg install-info anymore, but GNU install-info
    See the man page for ginstall-info for command line arguments  
  #+END_EXAMPLE
  只管忽略它就好.

[fn:2] 如果你不想在全局范围使用font-lock,你可以用下面一句配置来只在Org-mode下打开font-lock选项
  #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook 'turn-on-font-lock) 
  #+END_SRC

[fn:3] 请考虑订阅邮件列表，以减少工作邮件列表版主的工作量。

[fn:4] 要配置C-a,C-e和标题环境中C-k的行为,参见参数'org-special-ctrl-a/e', 'org-special-ctrl-k和'org-ctrl-k-protect-subtree'

[fn:5] 参见org-cycle-emulate-tab选项

[fn:6] 参见org-cycle-global-at-bob选项

[fn:7] indirect buffer(关于indirect buffer的更多信息请查看Emacs手册)仅仅包含了原buffer中当前树的内容. 编辑这个indirect buffer也会修改原buffer,但是对原buffer的可见性不会有影响

[fn:8] 如果你不想一行内容被分割,你需要定制变量'org-M-RET-may-split-line'

[fn:9] 参见变量'org-show-hierarchy-above','org-show-following-heading','org-show-siblings'和'org-show-entry-below',这些参数详细定义了每次匹配多少内容

[fn:10] 这种行为依赖于'org-remove-highlights-with-change'选项

[fn:11] 这种方法在Xemacs中是行不通的,because XEmacs uses selective display for outlining, not text properties. 

[fn:12] 当使用*作为列表项的标志时,这一行必须是有缩进的,否则它们会被认为是顶层的标题. 同样的道理,如果你为了得到一个干净的大纲视图而隐藏了前面的星星,那么以*开头的列表项和真正的标题之间会很难区分. 总之,即使支持'*'作为列表项标志,但最好还是不要用它.

[fn:13] 你可以通过配置'org-plain-list-ordered-item-terminator'来过滤掉它们中的任何一个.

[fn:14] 通过配置'org-alphabetical-lists',你也可以用类似'a.','A.','a)','A)'作为列表项的标志. 为了最小化与普通文档的混淆,只准使用单个字符作为标志. 超过这个限制,列表项标志会自动变回数字.

[fn:15] 如果列表项中包含有复选框,那么这种标志必须放在复选框的前面. 如果你激活了字母列表,你也可以使用类似[@b]这样的形式.

[fn:16] 参见'org-empty-line-terminates-plain-lists'

[fn:17] Org只会改变Emacs的filling设置,对于XEmacs,你应该是i用Kyle E.Jones的'filladapt.el'.为了启用这个包,在'.emacs'中添加'(require 'filladapt)'

[fn:18] 如果你不想分割列表项,自定义变量'org-M-RET-may-split-line'

[fn:19] 如果你想用这种方式遍历列表项,你可能需要自定义'org-list-use-circular-motion'

[fn:20] 循环行为参见'org-liste-use-circular-motion'

[fn:21] 欲了解列表项标志的更多规则,参见'org-list-automatic-rules'

[fn:22] 你可以在每个文件中定义drawers,方法为添加一行类似'#DRAWERS: HIDDEN PROPERTIES STATE'这样的一行.

[fn:23] 相应的in-buffer设置为: '#+STARTUP: fninline'或者'#+STARTUP nofninline'

[fn:24] 相应的in-buffer设置为: 'fnadjust' 和 'nofnadjust'.

[fn:25] 要插入一个竖线到表格域中,使用\ vert(去掉空格)代替,若要插入竖线到单词中,则用\ vert{}(去掉空格)代替,例如abc\vert{}def.

[fn:26] 这个特征在XEmacs上无效

[fn:27] 诚然它在Emacs中是无效的,但是它在导出为HTML使却有效.

[fn:28] Org能够识别用户使用'B4'这种写法,但是当Org提供公式来编辑时,不会采用这种引用的表示法. 你可以使用变量'org-table-use-stand-references'来定制这种行为.

[fn:29] 为了向后兼容性,你可以使用特定的名称类似$LR5和$LR12,分别引用的是表格的倒数第5和倒数第12行. 然而,现在这种语法已经被弃用, 在新文档中不应该再使用这种语法了,现在使用@>$代替.

[fn:30] 这种操作所花时间的时间复杂度为O(N^2),因为表格FOO需要首先被解析一边这样每一行才能被拷贝过来.

[fn:31] 'constants.el'通过两种单位系统来提供常量值,分别是SI和cgs. 具体使用哪个单位系统取决于变量'constants-unit-system'的设置. 你也可以通过#+STARTUP选项中的constSI和constcgs来为某个文件设置该属性的值.

[fn:32] 使用printf进行重新格式化时,精度的指定是收到限制的.这是因为,传给printf的值会自动被转换为integer或double类型. integer型数字被限制为包括符号位一共32bit,超过就会被截断. 而double型被限制为精度为64位其中保留16位小数(leaves approximately 16 significant decimal digits)

[fn:33] 这里名字必须是以字母数字开头,并且只使用字母数字和下划线


