#+TITLE: vim
#+AUTHOR: DarkSun
#+EMAIL: lujun9972@gmail.com
#+OPTIONS: H3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 基本操作
** 编辑模式
   1) 操作命令+位移命令
   2) 操作命令+visual模式下选择的块
   3) 操作命令+文本对象
** 定位=移动+搜索
   1) */#     ：以光标所在位置的单词作为关键字向后/向前进行单词查找（类似于/\<xxxx\>)
   2) fx/Fx   ：在当前行范围内，往后/往前查找x字符
   3) e/ge    ：往后/往前移动到单词的最后一个字符的地方
   4) E/gE    ：往后/往前移动到以空格分隔的单词的最后一个字符的地方
   5) tx/Tx   ：在当前行内往后/往前查找x字符，光标停在字符的前一个字符上
   6) ;/,     ：重复/反向重复fx/Fx/tx/Tx的命令
   7) n%      ：移动到整篇文件的百分之n处
   8) n|      ：跳到第n列
   9) C-F/C-B ：向前/向后翻屏
   10) End/C-End/Home/C-Home ：转到行末，文件尾，行首，文件头
   11) zz/zt/zb：把当前行放在屏幕中间/首段/尾端
   12) :set ignorecase|noignorecase ：设置搜索时忽略/不忽略大小写
   13) /<UP>|<DOWN>：来复用之前的搜索字符串
   14) :set incsearch  ：开启增量搜索
   15) ··     ：在两个跳转点之间切换（处jk之外的，一个命令使得光标定位于其他行，都叫做一个跳转）
   16) ·x     ：跳转到名为x的标记，该标记用mx的方式标记
   17) 'x     ：跳转到名为x的标记的行首
   18) C-O/C-I：跳转到上一个/下一个跳转点（C-I和按下<TAB>一样）（可以在不同文件之间跳转!!）
   19) mx设置标记,`x跳回标记
   20) :marks 标记  ：现在标记所在位置
   21) 0-9作为标记，意思为上一次离开Vim时的地方。每次退出Vim都创建一个0标记，以前那个0标记变为1标记，以此类推
   22) )命令向前移动一个句子，(向后移动一个句子
   23) }命令向前移动一个段落，{向后移动一个段落
   24) 我们也可以指定查找结束后光标所处的位置.
       1. 对于向前查找的命令我们可以斜线后用数字来指明光标所处的位置,
	  如下面的命令: 
	  /set/2 
	  这个命令会在查找结束后将光标入在第一个set 字符串后第二行的开始处.在这个命令中这个数字可以是正数也可以是负数.
       2. .如果斜线后是 b 和数字的,那么在查找结束后,光标将会被置于第一个匹配字符串的开始处,然后向左或是右移动n个字符,这里的n即为数字所指定的数.
	   .将 b改为s 也是一样的效果. 与参数 b 或是 s 相类似是 e 参数,这个参数会使得光标放在第一个匹配字符串的结尾处.
	  NOTE:
	  不论是s、b、e，后面接的数字如果为正数则是向右移动,如果是负数,则是向左移动.
       3. 一些常用的偏移(Offset)定义: 
	  +[num]            光标置于第一个匹配字符下第num行的开始处. 
	  -[num]            光标置于第一个匹配字符上第num行的开始处. 
	  e          匹配字符串的结尾处. 
	  e[num]     光标置于第一个匹配字符串的结尾处,然后移动 num 个字符,如果为正,向右移,为负,向左移. 
	  b s         第一个匹配字符串的开始处. 
	  b[num] 
	  s[num]      光标置于第一个匹配字符串的开始处,然后移动 num 个字符,如果为正,向右移,为负,向左移.  
   25) 两个搜索式样中的分号（;）告诉编辑器先用一般的方式找到第一个搜索式样的位置，然后从那个位置开始搜索第二个式样
** 编辑
   1. X       ：删除左边的字符=dh
   2. D       ：删除到行尾的内容=d$
   3. C       ：修改到行尾的内容=c$
   4. S       ：修改一整行=cc
   5. .       ：重复前一个编辑命令，除了u撤销命令、C-R重做命令和:开头的ex命令
   6. C-N     ：自动补全功能
   7. v/V/C-V ：进入visual模式，并按字、行、矩阵块的方式选择要操作的块。在visual模式下按o命令可以在设置块头和设置块尾之间却换。当进行矩阵文本块内容的选择时，有4个角可以改变。o只会带你到对角的位置，O可以让你在一行的左右角之间切换
   8. ~       ：切换大小写
   9. 命令记录与回放步骤：
      1) 使用q{register}命令开始，后续的动作将被记录进名为{register}的寄存器中，名字为a-z
      2) 执行你要执行的操作
      3) 按下q以结束对命令的记录（注意仅仅是q一个字符，不要键入多余的字符）
      4) 通过@{register}命令来执行宏
      5) 通过@@可以重复执行上一次执行过的宏
   10. 宏命令起始就是存储在寄存器中的一系列字符，可以通过"np将寄存器n中的内容倒出来进行编辑，然后通过"nyy将修改后的宏命令存回到寄存器n中，就能用@n命令执行新的宏命令了
   11. 当寄存器为大写字母的时候，表示内容添加在寄存器之后，而不是覆盖
   12. :[范围]s/xxx/yyy/[g/p/c]  :在范围内替换xxx为yyy,后面g，p，c的意义为
      1) g 表示改变一行中所有符合的目标字符串
      2) p 表示显示出所有被改变的行
      3) c 对每个改变进行确认操作
      4) e 告诉:s命令，就算没有找到一个匹配的目标，也不要报错
   13. 全局命令:global(简写为:g)命令
      1) :g命令是vim最强大的功能之一，它允许你找到符合某个匹配模式的行，然后将命令作用其上。
      2) :g命令的形式为:[范围]g/正则表达式/命令 。这里的命令指的是:开始的命令行命令，而不是normal模式下的命令
      3) 例如：g/^#/s/foobar/barfoo/g 。对以#开头的行进行替换操作，将foobar替换为barfoo
   14. 按C-V可以进入Visual block模式，在此模式下可以选择一个矩形的文本块。vim提供了一些特别的命令操纵这个文本块
      1) 在Visual block模式下"$"命令会让每一行的被选择区域扩展到该行的末尾, 不管这些行的长短是否参差不齐. 这种选择状态持续到你发出下一个改变水平选择域的命令. 所以使用命令"j"会保持这种状态,而"h"命令则会停止它.
      2) 命令"Istring<Esc>"会在每行中插入相同的文本, 插入位置在被选择块的左边.如果你插入的过程中进行了换行, 那么"I"命令将会象Normal模式下一样, 只影响文本块的第一行.
      3) "A"命令类似于"I", 只不过它是在文本块的最右边追加文本.
      4) >,<可以移动矩阵块
   15. read命令可以接受一个行范围，被读入的文件被放在这个范围的最后一行上。如果要把文件放到第一行，使用特殊行号0
   16. 在normal模式下使用gq{范围}，来格式化范围内的文字，这里可以用hjklGgg之类的光标移动命令表示范围
   17. 类似gq，可以用gU/gu/g~{范围}来最大化/最小化/大小写切换范围内的文字
   18. 在normal模式下，!{motion}{外部程序}，将motion代表的文本送到外部程序作为输入，用其输出代替motion指定的文本块.!!命令过滤当前行的内容。{motion}指通过移动命令指定的文本块
   19. :m/:move 行号  将当前行放到指定行号之后，若要放到第一行，则用行号为0
   20. gC-g               ：显示从开头到当前位置的行数及字符数，若是在visual模式下，则显示选择的区域内有多少行，及字数
   21. :history           ：列出所有:命令的历史记录
   22. 在normal模式下运行q:可以打开命令窗口，可以浏览整个历史记录
   23. 自动补全：在insert模式下
    1) C-P/C-p ：vim会搜索以之前输入过的，以光标前开头的所有word，然后补全这个变量名的剩余部分
    2) C-N/C-n ：vim搜索以之后输入国的，以光标前开头的所有word，然后补全这个变量名的剩余部分
    3) 因为查找达到文件头尾时会绕过去循环进行，所有C-n和C-p会找到相同的word来补全，只不过查找的顺序相反。
    4) 查找时会隐含地使用ignorecase选项，忽略大小写的不同
   24. UNIX环境下的特殊命令
    1. 重复录入：如果按下C-a，编辑器会插入你上一次在insert模式下录入的内容
    2. 从其他行赋值：按下C-y，编辑器会插入你上一行中相同位置的字符。
    3. 插入寄存器内容：按下C-r 寄存器名称，编辑器从寄存器中复制文本
    4. 
   25. :ab 缩写 扩咱  ：定义缩写，用unab 缩写名来删除缩写，:abclear 清除所有的缩写定义
   26. 你也可以使用CTRL-V {digits}来插入一个由{digits}指定其ASCII码的字符.
   27. 在insert模式下执行一句normal的命令，可以用C-o 命令来执行
   28. 格式化文本的命令
    1) 重新排列文本：gq操作符，可以用三种方法来制定它的作用对象，visual模式，使用移动光标的命令和文本对象。一般与移动命令}作用，表示移动到这一段的末尾。或ap文本对象连用
    2) 对齐文本：:{range}center|right|left [width].width在center和right中的作用表示行的长度，而在left中表示左边留白的宽度
    3) 增加缩进：在normal模型下的>>命令或ex命令:>都会增加本行的缩进，每次缩进的字符宽度为set shiftwidth选项指定的量 
   29. 对多个文件同时进行编辑
    1) 同时修改所有待编辑的文件：使用:argdo ex命令.可以对所有打开的待编辑文件执行ex命令
    2) windo命令对所有窗口执行同样的操作
    3) bufdo对所有缓冲区执行同样的操作
   30. gu、gU、g~是改变大小写的操作符，他们可以用于动作命令、文本对象和可视模式
   31. 要让一个操作符作用于当前行，可以执行这个操作符两次，gugu,gUgU,g~g~可以缩写成guu,gUU,g~~
   32. 在替换式样中使用的字元
       &             在替换式样中，“&”表示替换命令中的被替换部分的文本
       ~             “~”用来表示在上一个替换命令中的替换式样
       \U            “\U”字元使其后一直到替换式样结束的所有字母转成大写，除非中间遇到了可将大写功能关闭的其他字元。
       \E             “\E”字元用来限制“\U”或“\L”的作用范围
       \u             这个字元将紧随其后的那一个字母转为大写形式
       \l             与“\u”一样，不同之处在于“\l”将紧随其后的那个字母变为小写
** 表示范围
   1. . 表示当前行
   2. 表示范围时,%=1,$
   3. 可以用搜索命令/和?来表示范围，例如:?^Chapter?,/^Chapter/s=grey=gray=g，这里用了两个搜索模式. 第一个"?^Chapter?" 向后查找,"/^Chapter/"向前. 为了避免眼花liao乱的斜杠/, ":s"命令使用"="字符作为分隔符.
   4. 可以对范围通过+-指定一个位移作为微调
  1) -n表示上调n行
  2) +n表示下调n行
  5. 可以使用标记来限定范围，如通过ma，mb设定了两个标记，则:'a,'b表示两个标记间的范围
  6. '<和'>实际上也是标记，分别表示visual选择区域的开始和结束，退出visual模式后，标记仍然保持
  7. 可以直接指定行数，如果你知道修改多少行，你可以在普通模式下先输入行数再输入冒号，例如输入5:会得到:.,.+4,表示修改当前行到下面4行一共5行
  8. 
** 文本对象
   1) aw=a word
   2) is=inner sentence，不包括句子后面的空格
   3) as=a sentence，包括了句子后面的空格
   4) ap=a paragraph
** 定制
   1) 键映射
      1. 可以在不同的模式下定义不同德键映射
	 :map Normal, Visual and Operator-pending
	 :vmap Visual
	 :nmap Normal
	 :omap Operator-pending
	 :map! Insert and Command-line
	 :imap Insert
	 :cmap Command-line
      2. map 映射键序列1 被映射键序列2：映射一个键序列2为键序列1，当键序列1为多个键时，需要快速输入键序列，才能使vim把他们看成是一个整体
      3. 可以用<xxx>的方式来代替特殊键，如<ESC> <CR>等
      4. 若要取消迭代映射，则用noremap 映射键序列1 被映射键序列2命令：
	 :noremap Normal, Visual and Operator-pending
	 :vnoremap Visual
	 :nnoremap Normal
	 :onoremap Operator-pending
	 :noremap! Insert and Command-line
	 :inoremap Insert
	 :cnoremap Command-line
      5. 使用unmap系列命令取消映射：
	 :unmap Normal, Visual and Operator-pending
	 :vunmap Visual
	 :nunmap Normal
	 :ounmap Operator-pending
	 :unmap! Insert and Command-line
	 :iunmap Insert
	 :cunmap Command-line
      6. 特殊字符替代
	 "|"用于命令之间分隔，所以键序列中不能出现 |,否则vim会以为命令已经结束，可以用<Bar>代替
	 空格可以用<Space>代替
	 <Nop>表示什么也不做
   2) 自定义冒号命令：
      1. :command 自定义冒号命令 实际要执行的命令
      2. 用户自定义冒号命令可以跟一系列的参数，参数个数用 :command -nargs={xxx} 自定义冒号命令 实际执行的命令 来指定
	 -nargs=0 没有参数
	 -nargs=1 1个参数
	 -nargs=* 任意个数的参数
	 -nargs=? 0个或1个参数
	 -nargs=+ 1个或多个参数
      3. 在实际执行的命令中，用关键字<args>来代表用户可能输入的参数
      4. 如果用户输入的参数可能包括特殊字符，可以用<q-args>来代表用户输入的参数
      5. <f-args>关键字包含的内容与<args>一样，不过它适用于把这些参数传递给一个函数调用
      6. 一些命令以一个指定的范围使用它的参数. 要在Vim中定义这样的冒号命令, 需要在定义时使用-range选项. 该选项的可能取值如下:
	 -range 允许使用行号范围, 默认是当前行
	 -range=% 允许使用行号范围, 默认是所有行
	 -range={count} 允许使用行号范围,行号范围中的最后一行作为最后生效的单个数字,默认值是{count}
      7. 自定义命令时还有其它可用的选项和关键字, 列表如下:
	 -count=fnumberg 使命令可以接受一个命令计数作为参数, 默认值是fnumberg.在定义时可用<count>关键字来引用该数字
	 -bang 允许在定义的命令体中使用<bang>关键字来代替!
	 -register 允许把一个寄存器作为参数传递给该命令, 命令体中对该寄存器的引用使用关键字<reg>或<register>
	 -complete=ftypeg 定义该命令使用命令补齐的方式, 请参考j:command-completionj了解该选项的可能取值
	 -bar 使该命令可以与其它命令共存于同一个命令行上, 以j分隔, 并且可以以一个"号进行注释
	 -buffer 使命令只对当前缓冲区生效.
      8. 要重新定义一个命令只需要在:command后面加一个!即:command!
      9. 要删除命令可以用:delcommand或者用:comclear清除所有的用户定义命令
   3) 自动命令(触发器)的格式为:autocmd [group] {events} {file_pattern} [nested] {command}
      1. {file pattern}是一个通常带有通配符的文件名.
      2. [group]名字是可选的. 它只是为了方便调用和管理这些命令
      3. [nested]这个可选的标志允许对自动命令的递归触发.
      4. {command}中的部分是实际上要执行的命令体
	 可以用execute 表达式 来重新构建一个命令并执行它
	 被自动执行的命令都是冒号命令，如果想执行一个normal模式下的命令，可以用:normal命令，如:autocmd BufReadPost *.log normal G
      6. {events}参数是可以触发该命令的事件列表(每个事件以逗号分隔)
	 最常用的事件是BufReadPost. 它在每次Vim将要编辑一个文件时被触发
	 如果Vim能正常检测到文件的类型的话, 它会设置°filetype°选项.这又会触发FileType 事件.
	 可以通过:set eventignore来设置vim可以忽略的事件列表
      7. 要删除一个自动命令，只要定义一个空的命令体就行了，同时在autocmd后面加上一个!字符
   4) :set nowrap        ：设置是否自动换行
   5) :set list          ：让稳重制表符成为可见的
   6) :set iskeyword     ：定义一个word可以包含哪些字符
   7) :set errorformat 可以用来控制 Vim 如何来组织错误文件
      %f    文件名 
      %l    行号 
      %c    列号 
      %t    错误类型(单一字符) 
      %n    错误行号 
      %m     错误信息 
      %r    匹配一行中的剩余 
      %*{char}匹配并跳过由{char}所指定的scanf转换 
      %%     字符% 
*** .vimrc设置
    1) filetype plugin indent on：开启自动识别文件类型、使用文件类型plugin脚本、使用缩进定义文件
    2) autocmd 属性 值 命令：设置一个触发器，当属性=值时，执行命令
    3) 文件类型plugin的文件名一般为ftplugin/<filetype>.vim或ftplugin/<filetype>_<name>.vim或ftplugin/<filetype>/<name>.vim
    4) :options ：该命令打开一个新窗口，该窗口的最开头的注释下面是一个选项列表，每行一个，对每个选项有一个对应的简短说明
    5) :syntax on ：打开语法标亮功能
*** 设置语法高亮
    1) :syntax on ：打开语法标亮功能
    2) 使用:colorscheme 颜色方案名称来指定vim使用的颜色方案。颜色方案文件设置如下：
       term 黑白终端的显示属性
       cterm 彩色终端的显示属性
       ctermfg 彩色终端的前景色
       ctermbg 彩色终端的背景色
       gui GUI的显示属性
       guifg GUI的前景色
       guibg GUI的背景色

** 帮助
   1. :help '选项'  :查看set的选项帮助，记得选项要用单引号括起来。
   2. K、\K         :用man查看光标所在的关键字，K在本窗口中显示man信息，\K在新窗口中显示man信息
   3. 
** 文件操作
   1. :hide edit 文件名 ：可以在不关闭现文件的情况下编辑其他文件，现编辑的文件隐藏起来了
   2. :args   ：显示现在编辑文件的列表
   3. :next/:previous/:last/:first ：在多个编辑文件中切换
   4. :args 文件列表 ：重新定义一个文件列表，可以使用通配符
   5. :preserve     ：这个命令是将我们所做工作存入交换文件,而原始的保持不变
   6. :set backupext=备份文件后缀  ：设置备份文件后缀
   7. :set backup   ：开启备份模式
   8. :saveas 文件名 ：另存为，之后用w命令默认保存的文件名就变成了指定的文件名
   9. gf或C-W f      ：在normal模式下，按gf会进入光标所在关键字所指代的文件，文件搜索路径为当前目录和path所指代目录，其中gf在当前窗口打开文件，C-W f在新窗口打开文件
   10. :find 文件名或:sfind 文件名 ：根据path定义的路径，打开指定文件，其中:find在当前窗口打开文件，:sfind在新窗口打开文件
   11. 加密文件：vim -x 文件名，就可以设置密码，下次vim打开时会提示输入密码
   12. 更改密码或取消加密  ：可以通过:set key=密码或:X交互修改密码，密码为空，则表示不加密
   13. 编辑二进制文本的操作
     1) vim -b 文件名  ：以二进制方式打开文件
     2) :set display=uhex    ：设置以十六进制显示文本内容
     3) 用ga命令可以查看当前光标下字符的本来面目
     4) 字节数go   :移动到指定字节位置去
** 窗口操作
   1. :[number]split [文件名]   ：上下分割一个窗口,若指定了number则新窗口为numbe行
   2. :[number]vsplit [文件名]  ：左右分隔一个窗口
   3. :close|:q|ZZ     ：关闭窗口，但是用:close不会关闭最后一个窗口，防止vim退出
   4. :only            ：只显示当前窗口
   5. :new             ：上下打开新窗口并编辑空缓存区
   6. :vnew            ：左右打开新窗口并编辑空缓存区
   7. :命令后加all      ：表示对所有窗口进行同一个操作
   8. C-Z或者:suspend命令可以暂时挂起vim，回到shell中
   9. 在任何打开窗口的 Ex 命令前面，你都可以放上 ":tab"。这个窗口在新标签页中打开。
   10. 很多编辑另一个文件的命令都有一个使用分割窗口的变体。
    1) 对于命令行命令，这通过前置一个 "s" 实现。例如 ":tag" 用来跳到一个标记，"stag" 就会分割出一个新窗口并跳到那个标记。
    2) 对于普通模式，前置一个 CTRL-W 可以完成这个功能。例如，CTRL-^ 跳到轮换文件，而 CTRL-W CTRL-^ 打开一个新窗口并编辑轮换文件。
*** C-w 为前缀的命令表示对窗口进行操作的命令
    1. C-w w            ：在窗口之间切换
    2. C-w +            ：增加窗口的高度
    3. C-w -            ：减少窗口的高度
    4. nC-w _           ：设定窗口高度为n
    5. C-w h|j|k|l|t|b  ：光标移动到左边，下面，上面，右边，顶部，底部的窗口去（类似文本移动）
    6. C-w H|J|K|L|T|B  ：窗口移动到左边，下面，上面，右边，顶部，底部的位置
    7. :[vertical ]all  ：为指定的所有命令各开一个窗口，加了vertical 则让打开的窗口都是垂直分隔
** 启动参数
   1) 用vim -R|-M 文件名  ：以只读的方式打开文件，-R是软现在 -M是硬限制
   2) vim -r             ：以修复模式启动vim
   3) 用vim -o|-O选项可以让vim为每一个文件打开一个窗口，-o水平排列，-O则为垂直排列
   4) 用vim -g  ：用gui模式运行vim
   5) 用vim -r 文件名 ：恢复文件
   6) 如果你在编辑一个没有指定文件名的缓冲区时死机了, 可以通过一个空字符串作为要恢复的"文件名"
   7) 如果用vim -r的话，会列出所有找到的交换文件。
   8) vim -S vim脚本文件     ：启动vim时执行某个脚本，若脚本文件为会话文件则可以用来恢复某个会话
   9) vim -s normal模式命令文本 待编辑文件 ：执行normal模式命令来编辑文件名，就好像你手工键入的一样              ：
   10) vim -e -s 文件名 <ex脚本文件：这里-e表示vim以ex模式，根据ex脚本文件的内容对文件进行修改，-s参数告诉vim安静地运行
   11) vim -                ：-表示vim从标准输入读取要编辑的内容
   12) vim -w 记录normal模型命令的文件 待编辑文件 ：将编辑文件的所有操作记录下来，添加在normal模型命令的文件后面
   13) vim -W 记录normal模型命令的文件 待编辑文件 ：将编辑文件的所有操作记录下来，覆盖normal模型命令的文件
   14) vim -u file           ：使用file为初始化文件，而不使用.vimrc
   15) vim -U file           ：使用file而不使用.gvimrc作为初始化文件
   16) vim -i file           ：使用file而不使用.viminfo作为初始化文件
   17) vim -Z                ：受限模式.这个命令参数可阻止我们使用:shell 命令或是其他的一些命令来使用外部的Shell.但是这个选项并不会阻止我们使用:vi 命令来编辑文件.
   18) -b          二进制模式.设置了noexpandtab,textwidth=0,nomodeline,binary 
   19) vim +{行数}            ：光标直接跳到指定行号 
** 缓冲区操作
   1. :buffers或:ls      ：列出缓冲区列表
   2. :buffer|sbuffer 缓冲区编号|文件名或部分文件名   ：编辑指定缓冲区，其中buffer表示在本窗口编辑，是buff而表示在新窗口编辑
   3. :bnext|bprevious|bfirst|blast      ：在各个缓冲区之间进行跳转
   4. bdelete 缓冲区编号     ：把一个缓冲区从列表中去除
   5. 
* 技巧
** 移动
   1. `]      
     
      返回最后编辑的位置

   2. ;

	  重复查找上次f命令所查找的字符
** 编辑
   1. xp可以用来交换两个字符的位置
   2. 当光标位于一个单词的中间，而需要删除这个单词时，可以用daw，这里aw是表示一个文本对象=a word的缩写
   3. 在R命令进入replace模式后，按退格键，会发现原来的字符又回来了，等价于一个撤消操作
   4. set autowrite|noautowrite  ：设置是否自动存盘
   5. Ctrl-^  ：可以快速地在两个文件间切换
   6. ·"      ：带你到上次你离开该文件时光标所在的位置
   7. `.      ：回到你最后一次对文件做出修改的地方
   8. 删除内容时，也可以指定一个寄存器名，这种方法可以用来移动多处的文本。
   9. 可以用:write >>文件名的方式来追加文件内容
   10. 命令记录与回放步骤：
   1) 使用q{register}命令开始，后续的动作将被记录进名为{register}的寄存器中，名字为a-z
   2) 执行你要执行的操作
   3) 按下q以结束对命令的记录（注意仅仅是q一个字符，不要键入多余的字符）
   4) 通过@{register}命令来执行宏
   5) 通过@@可以重复执行上一次执行过的宏
   11. 宏命令起始就是存储在寄存器中的一系列字符，可以通过"np将寄存器n中的内容倒出来进行编辑，然后通过"nyy将修改后的宏命令存回到寄存器n中，就能用@n命令执行新的宏命令了 
   12. 可以用其他符号代替s///的斜杠，如s+xxx+yyy+g
   13. 在normal模式下，!{motion}{外部程序}，将motion代表的文本送到外部程序作为输入，用其输出代替motion指定的文本块
   14. 使用[位置]read !{外部程序} 可以将外部程序的输出写到指定位置
   15. :write !{外部程序}  ：将要写的文本传入外部程序作为输入
   16. :g/^/m 0           ：将各行顺序反转
   17. 进入vim后，输入'0就会回到上次退出的位置
   18. viminfo文件保存vim实例中的交换信息，可以用:wviminfo和rviminfo实现多个不同vim间分享viminfo文件
   19. vim休眠：会话文件包含你编辑活动的所有信息，可以用:mksession 会话文件名的方式创建一个会话文件，用:source 会话文件名载入会话信息还原
   20. 视图文件可以保存某个窗口的属性，可以用mkview 文件名|数字编码和loadview 文件名|数字编码来保存和恢复视图
   21. 模式行：模式行加入到某个文件的前5行或后5行中，为该文件指定特殊的选项设置，语法为:任何文本 vim:set语法...: 任何文本。这里任何文本的意思是你可以在对vim有用的文本之前或之后放入任何东西，vim之前必须要有一个空格
   22. 远程URL指定的文件，使用normal模式下的gf命令，vim也会自动下载该文件然后再编辑它
   23. gzip插件可以使得vim像处理其他文件一样编辑压缩文件，vim自动处理解压缩问题
   24. 自动补全：在insert模式下
    1) C-P/C-p ：vim会搜索以之前输入过的，以光标前开头的所有word，然后补全这个变量名的剩余部分
    2) C-N/C-n ：vim搜索以之后输入国的，以光标前开头的所有word，然后补全这个变量名的剩余部分
    3) 因为查找达到文件头尾时会绕过去循环进行，所有C-n和C-p会找到相同的word来补全，只不过查找的顺序相反。
    4) 查找时会隐含地使用ignorecase选项，忽略大小写的不同
    5) 对于自动补全有一个选项十分有用, 它就是°infercase°. 它使搜索
    6) 匹配的word时忽略剩余部分的大小写(当然还得°ignorecase°被设置了才行), 但继续保留已键入的部分的大小写. 这样对于键入了"For"时Vim会查找到"fortunately"这样的匹配, 但最终的结果是"Fortunately".
    7) 如果你自己清楚要找的东西, 你可以用以下命令来补全这样一些特殊的文档元素:再用C-n，C-p切换
       CTRL-X CTRL-F 当前目录中的文件名
       CTRL-X CTRL-L 整行内容
       CTRL-X CTRL-D 宏定义(也包括那些在include文件里定义的宏)
       CTRL-X CTRL-I 当前文件和被当前文件include的文件
       CTRL-X CTRL-K 来自一个字典文件的word
       CTRL-X CTRL-T 来自一个thesaurus的word
       CTRL-X CTRL-] tags
       CTRL-X CTRL-V Vim的命令行
    25. 左右对齐文本：vim没有一个内置的命令来使文本左右对齐，但是可以使用fmt外部程序实现:%!fmt
    26. 当一行多于一个屏幕长度时，用j/k命令可能会移动多于一个屏幕行的位置。要精确地移动一个屏幕行，可以用gj/gk命令来代替
    27. 要方便地编辑表格时，可以:set virtualedit=all,就可以把光标任意移动到空无一物的虚位置上去了。
    28. 增加数字序号：将光标移动到要修改的数字序号上，在normal环境下按C-A，就对序号+1，可以在前面接数字；按C-X做减法，可以在前面接数字
    29. 在命令行上键入文本跟插入模式下键入文本有所不同。许多修改文本的命令都不能用。在普通模式下键入q:，会打开cmdline，可以用普通编辑命令来编辑复杂的ex命令
** 窗口操作
   1. :[number]split [文件名]   ：上下分割一个窗口,若指定了number则新窗口为numbe行
   2. :[number]vsplit [文件名]  ：左右分隔一个窗口
   3. :close|:q|ZZ     ：关闭窗口，但是用:close不会关闭最后一个窗口，防止vim退出
   4. :only            ：只显示当前窗口
   5. :new             ：上下打开新窗口并编辑空缓存区
   6. :vnew            ：左右打开新窗口并编辑空缓存区
   7. :命令后加all      ：表示对所有窗口进行同一个操作
   8. C-Z或者:suspend命令可以暂时挂起vim，回到shell中
   9. 在任何打开窗口的 Ex 命令前面，你都可以放上 ":tab"。这个窗口在新标签页中打开。
   10. 很多编辑另一个文件的命令都有一个使用分割窗口的变体。
    1) 对于命令行命令，这通过前置一个 "s" 实现。例如 ":tag" 用来跳到一个标记，"stag" 就会分割出一个新窗口并跳到那个标记。
    2) 对于普通模式，前置一个 CTRL-W 可以完成这个功能。例如，CTRL-^ 跳到轮换文件，而 CTRL-W CTRL-^ 打开一个新窗口并编辑轮换文件。
*** C-w 为前缀的命令表示对窗口进行操作的命令
    1. C-w w            ：在窗口之间切换
    2. C-w +            ：增加窗口的高度
    3. C-w -            ：减少窗口的高度
    4. nC-w _           ：设定窗口高度为n
    5. C-w h|j|k|l|t|b  ：光标移动到左边，下面，上面，右边，顶部，底部的窗口去（类似文本移动）
    6. C-w H|J|K|L|T|B  ：窗口移动到左边，下面，上面，右边，顶部，底部的位置
    7. :[vertical ]all  ：为指定的所有命令各开一个窗口，加了vertical 则让打开的窗口都是垂直分隔
** 启动参数
   1) 用vim -R|-M 文件名  ：以只读的方式打开文件，-R是软现在 -M是硬限制
   2) 用vim -o|-O选项可以让vim为每一个文件打开一个窗口，-o水平排列，-O则为垂直排列
   3) 用vim -g  ：用gui模式运行vim
   4) 用vim -r 文件名 ：恢复文件
   5) 如果你在编辑一个没有指定文件名的缓冲区时死机了, 可以通过一个空字符串作为要恢复的"文件名"
   6) 如果用vim -r的话，会列出所有找到的交换文件。
   7) vim -S vim脚本文件     ：启动vim时执行某个脚本，若脚本文件为会话文件则可以用来恢复某个会话
   8) 
** 设置
   1. 在set 选项&可以使得选项变为默认值，记得&号是紧靠选项后面的。
* 注意
** 移动
** 编辑
   1. yw复制的内容包括word之后的空白文字，而ye不包括后面的空白文字
   2. 在R命令进入replace模式后，按退格键，会发现原来的字符又回来了，等价于一个撤消操作
   3. :lcd与:cd的区别，:cd改变整个vim的工作目录而:lcd改变的只是该窗口的工作目录
   4. 不保存源文件打开第二个文件：假设你现在在编辑one.txt,希望在不保存one.txt的情况下打开two.txt,则可以用:hide edit two.txt的方法，缓冲区one.txt会从屏幕消失，vim会保持one.txt的状态
   5. 即使是用":bdelete"命令删除了一个缓冲区Vim还是 会 记 住 它. 实 际 上 它 被 打 入"unlisted"列 表 中,不 再 显 示 在":buffers"命 令 显 示 的 缓 冲 区 列 表 中.但":buffers!"还是会让它再度现身(是的, Vim可以完成Misson Impossible). 要彻底清除一个缓冲区, 要使用":bwipe". 同时请参考°buflisted°选项.
   6. 即使加密了，但是vim不会对交换文件加密，为了保密，一个方法是不用交换文件，如vim -x -n file.txt或者在编辑状态:setlocal noswapfile
   7. 在unix环境中，如果按下C-a，编辑器会插入你上一次在insert模式下录入的内容。而在windows环境C-a代表全选编辑区文本 
   8. 要输入特殊字符，在unix环境下按C-v 特殊字符，在windows环境下按C-q 特殊字符
   9. 如果你想让缩进量是4的倍数, 只需要把°shiftwidth°设为4即可. 但是键入制表符还是会插入一个8字符宽度的缩进. 这可以通过°softtabstop°选项得以改观:
   10. 

* 专题应用
** C编程
*** 在程序中移动
    1. %可以在#ifdef....#else...#endif间跳动
    2. 在#ifdef ...#else...#endif 中可以用[#或]#跳到上一个或下一个#结构的开始元素中
    3. [和]移动方法
   1. 用[[或][可以移动到一个代码块的开头或末尾，这两个命令都假设{}字符位于第一列
   2. [{或]}命令跳转到当前代码块的开头或结尾，它会跳过与它平级的代码块
   3. [m可以找到前一个函数的开始，]m到下一个函数的结尾
   4. []向前查找一个函数的结尾，]]查找一个函数的开始
   5. [(和])命令类似于[{和]}, 只不过它工作于()的内部而不是{}.
   6. [/和 ]/在/*...*/注释内移动 
   4. 查找全局标识符：
      1. [i或[I会列出当期光标之前的第一个([i)或所有的([I)包含光标所在标识的行，包括include的文件及include中include的文件，以此类推
      2. ]i或]I会列出当期光标之后的第一个(]i)或所有的(]I)包含光标所在标识的行，包括include的文件及include中include的文件，以此类推
      3. [+CTRL+i 跳转到[i所标识的函数定义处 
      4. [I命令查找任何的标识符，要只查找以#define定义的宏，使用[D
      5. [I命令会搜索include文件，要使搜索限制在当前文件里并执行同样的功能，以命令gD(goto Definition)
      6. 要是搜索限制在当前函数中，使用gd命令
   5. 跳转到匹配的全局标识符处 ：[<TAB> 会跳转到用[i查出的匹配目标处，可以在前面加数字
   6. vim会根据选项path指定的路径里查找include文件。使用:checkpath会列出所哟能找到和不能找到的include文件
   7. c\c++ 下常用的: 
      ]] 在  C 的  {} 形成的段落中移动 (在第一列  { 之间跳动,一次一个函数，一个结构或类的定义) 
      [# 和  ]# 在  #if #else #endif 的上下位置间移动 
      [{       ]} 
      [(       ]) 
      [/        ]/ 在注释  /* */ 间移动 
      [( 返回到未闭合的  '(' 处。  
      )) 前进到未闭合的  ']' 处。  
      [{ 跳转到最近对应的  '{' 处。 
      }} 跳转到最近对应的  ']' 处。 
      这样在这些块的中间位置, 就能迅速到块头和块尾 如果已经在这些行上, 如果不是到对应点, 会到上一级范围, 如  { 上按  [{ 到上一级 ]}  则到对应点 
      NOTE:
      (vim 里常用  [  表示 "向上", ] 表示 "向下", 
      比如上面的例子, 以及  [i ]i, diff 时候的  [c ]c 等) 
      %  在  ()     {}   []   #ifdef #endif    /* */之间跳转 
      可以  :so    $VIMRUNTIME/macros/matchit.vim 
      这样可以在  if endif <tr> <\tr> 之间使用 
      NOTE:
      对  1 个块的操作, 具体  :h v_a 
      里面的  iX aX 什么的都很好用  
**** 跳转到函数
     1. :[数字]tag|stag|ptag 函数名称    ：跳转到函数定义出，stag会分隔一个窗口来显示,ptag会打开一个预览窗口来显示光标依然在原窗口中，其中函数名可以是/关键字 会找到包含关键字的函数，/关键字表示查找关键字的位置
     2. :tags                           ：会列出现在你已经到过哪些tag
     3. C-T                             ：跳到你前一次tag处
     4. :set tags=../,.../...           ：可以通过tags选项的设置来引用更多的tags
     5. :tfirst|:tnext|:tprevious|:tlast：跳转到下个同名函数
     6. :tselect 函数名                  ：弹出个列表，可以在列表中选择
     7. 预览窗口操作
        1) :ptag 函数名称                 ：打开预览窗口，显示函数定义
        2) C-w }                         ：打开预览窗口，显示光标所在的函数名称的定义
        3) :pclose                       ：关闭预览窗口
        4) :pedit 文件名                  ：在预览窗口编辑文件
        5) :psearch 关键字                ：搜索当前文件和include的文件，并显示匹配行
    8. g<鼠标左键点击>                    ：跳转到鼠标点击处关键字的tag处
    9. C-]                              ：跳转到光标所在关键字的tag处
*** 编辑程序
    1. 开启cindent选项可以让vim自动对C进行缩进
    2. 要格式化代码可以使用=操作符命令，与其他操作符一样，它有三种命令形式
       1. == ：为最简单的应用，为当前行进行适当的缩进
       2. visual模式下=命令为被选择的行设定缩进
       3. 可应用于文件对象，如=a{ 对当前的{}程序块进行重新缩进
       4. = 定位操作 ：如=G，对到文件尾进行缩进
       5. 使用外部程序格式化代码：set equalprg=外部程序
	  如：针对不同文件后缀使用不同的程序格式化程序：
	  autocmd Filetype 文件后缀 :set equalprg=外部格式化程序
   1. 也可以卡开smartindent选项来为未知格式的文件进行自动缩进
   2. 要快速向右或向左缩进，可以用>或<操作符。使用方法类似=操作符
      1. <<或>> :为最简单的应用，为当前行快速减少或增加缩进
      2. visual模式下
      3. 应用于文件对象
      4. 接定位操作符
   3. 对注释的格式化：gq 操作符，如
      1. visual模式下
      2. 应用于文件对象
      3. 可以把光标放在注释的开头，按下gq]/  ：gq是格式化注释命令的操作符，]/是移动到注释命令的结尾
   4. 自定义注释格式：
      1. 行注释：通过:set comments=:注释关键字 可以设置注释的格式,其中:为分隔符
      2. 段注释：set comments=s:注释开始关键字[,m{option}],e:注释结束关键字.这里s代表start，m代表middle为注释内容，e代表end
   5. 补全：C-x C-XXX
      1. 万能补全
	 启动万能补全：C-x C-o
	 取消万能补全："CTRL-E"停止补全并回到原来录入的文字。用"CTRL-Y"可以停止补全，并接受当前所选的项目
      2. 整行补全                        CTRL-X CTRL-L
      3. 根据当前文件里关键字补全        CTRL-X CTRL-N
      4. 根据字典补全                    CTRL-X CTRL-K
      5. 根据同义词字典补全              CTRL-X CTRL-T
      6. 根据头文件内关键字补全          CTRL-X CTRL-I
      7. 根据标签补全                    CTRL-X CTRL-]
      8. 补全文件名                      CTRL-X CTRL-F
      9. 补全宏定义                      CTRL-X CTRL-D
      10. 补全VIM命令                     CTRL-X CTRL-V
      11. 用户自定义补全方式              CTRL-X CTRL-U
      12. 拼写建议                        CTRL-X CTRL-S
   6. ga 显示光标处字符的ascii,hex,oct,

*** comments选项来定义哪些文本时注释
    1. 可使用的标记如下
       b     后面必须跟上空格.这就是说如果一个字符后面跟上空格或是其他的空白符,那 么这个字符开始了一个注释. 
       f     只有第一行有注释字符串.在下一行不要重复这个字符串,但是要保持缩进格式 
       l     当使用在三段注释的情况下,必须保证中间一行要与注释的开始和结束相对应. 而且必须使用s或是e标记. 
       n    指明了嵌套注释 
       r    与l 相类似,所不同的只是右对齐 
       x    告诉 Vim 在三段注释的情况下我们可以在下面的三种情况下仅输入最后一个字符就可以结束注注释: 
         1) 我们已经在注释的开头输入了. 
         2) 注释有中间部分. 
         3) 结束字符串的第一个字符是这一行的第一个字符. 
    2. 对于三段注释的情况,下面的一些标记适用: 
       s    开始三段注释 
       m      三段注释的中间部分 e    三段注释的结尾 
       number    在三段注释的中间部分的缩进中添加指定的空格 
*** 编译程序
    1. :make 参数        ：编译程序，如果有错误发生，vim会自动将光标定位于第一个错误的事发地点
    2. :cnext|cprevious|cfirst|clast  ：cnext命令会带你到下一个错误的事发地点,其他的类推
    3. :cc [数字]        ：跳转到第N个错误，并显示完整的错误信息描述
    4. :clist或:clist!   ：clist会列出一个所有简要错误信息的列表,:clist!会列出一个所有完整信息的列表
    5. :set makeprg      ：设置:make命令被执行时实际调用的为外部程序，VC用户可以设置为nmake
    6. :colder|:newer    ：vim内部维护了一个错误列表，每次:make都会生成一个新的错误列表，可以用:colder来返回上一个错误列表,用:newer返回下一个错误列表
    7. :cfile 错误信息文件 ：若你有一个包含错误信息的文件，可以用:cfile 文件名的方式读取错误信息，就可以像:make命令一下让你跳转到出错地点去了。
       1. 
** fileExplorer
   1. 打开fileExplorer：
      :explore
      #+BEGIN_SRC vimrc
      """"""""""""""""""""""""""""""
      " netrw setting
      """"""""""""""""""""""""""""""
      let g:netrw_winsize = 30
      nmap <silent> <leader>fe :Sexplore!<cr>
      "这样，在我输入“,fe”时，就会打开一个垂直分隔的窗口浏览当前文件所在的目录，窗口的宽度为30。
      #+END_SRC
   2. fileExplorer下的的常用键
      ----	--------			
      映射	简要解释				
      ----	--------			
      <F1>	netrw 给出帮助
      <cr>	netrw 进入目录或者打开文件                        
      <del>	netrw 试图删除文件/目录                          
      -	netrw 往上一层目录                              
      a	切换普通显示方式、                              
      隐藏方式 (不显示匹配 g:netrw_list_hide 的文件) 和显示方式 (只显示匹配 g:netrw_list_hide 的文件)
      c	使浏览中的目录成为当前目录                       
      C	设置编辑窗口                                   
      d	建立新目录       
      D	试图删除文件/目录                             
      gb	切换到收入书签的目录                          
      gh	快速隐藏/显示点文件                          
      <c-h>	编辑文件隐藏列表                            
      i	在瘦、长、宽和树状列表方式循环                
      <c-l>	使 netrw 刷新目录列表                 
      mb	把当前目录加入书签                            
      mc	把带标记文件复制到标记目标目录中               
      md	对带标记文件进行比较 (不超过 3 个)            
      me	把带标记文件放到参数列表中并编辑之            
      mf	标记文件                                  
      mh	切换带标记文件的后缀在隐藏列表中的存在与否    
      mm	把带标记文件移动到标记目标目录中            
      mp	打印带标记文件                           
      mr	标记满足 shell 风格的 |regexp| 的文件    
      mt	使当前浏览目录成为标记文件的目标目录       
      mT	对带标记文件应用 ctags                  
      mu	撤销所有带标记文件的标记                 
      mx	对带标记文件应用任意外壳命令             
      mz	对带标记文件压缩/解压缩                 
      o	用水平分割在新浏览窗口中进入光标所在的文件
      O	获取光标指定的文件                                
      p	预览文件                                        
      P	在前次使用的窗口中浏览                           
      qb	列出书签内的目录和历史                           
      qf	显示文件信息                                   
      r	反转排序顺序                                   
      R	给指定的文件或目录换名                          
      s	选择排序风格: 按名字、时间或文件大小             
      S	指定按名排序时的后缀优先级                      
      t	在新标签页里进入光标所在的文件/目录             
      u	切换到较早访问的目录                            
      U	切换到较迟访问的目录                            
      v	用垂直分割在新浏览窗口中进入光标所在的文件/目录    
      x	用指定程序阅读文件                             

      %	在 netrw 当前目录打开新文件                    
      
** Vim脚本
*** 变量
    1. 变量作用域声明：变量有不同的命名空间，根据附加的前缀决定:
       s:name                脚本文件内部变量
       b:name                局部于一个缓冲区的变量
       w:name                局部于一个窗口的变量
       g:name                全局变量
       l:name                只在函数内部使用的变量
       a:name                变数变量
       v:name                Vim的预先定义变量，预定义变量时只读的

       $NAMW                 环境变量名
       &name                 VIM中的选项目
       @r                    VIM中的寄存器
*** 操作符
    1. .操作符
       用来连接字符串
    2. =~与！~
       正则匹配运算符
       在字符运算符后加上#表示区分大小写，而?表示不区分大小写
       ==?       大小写不敏感的相等
       =~#       大小写敏感的正则匹配
       没有#或?时则，根据ignorecase设置项决定是否区分大小写
    3. Vim不支持浮点运算，小数点将会省略
       9/4.4=(9/4).4=2.4=24   "注意这里的点位连接运算符，两个数字自动类型转换为字符串
    4. []操作符
       Vim允许通过[]析取字串中的某个字母
       :echo "abc"[0]             "结果为a
    5. | 操作符
       连接多条命令这样就可以在同一行中执行多条命令.
    6. 
*** 函数
    1. 函数的命名规则与变量名一样，但是只有大写字母开头的函数名可以从脚本外部访问
    2. 如果没有return函数的返回值总为0.没有return语句的函数一般不在表达式中使用，要调用这些函数的可以使用:call 命令
    3. 
*** 运行及录制脚本
    1. 在vi中用source命令运行
    2. 在命令行中运行vim的脚本
       参数     作用             示例 
       -s      读入一般模式脚本    vim -s 脚本文件名 文件 
       -e -s   使用vim的ex命令     vim -e -s <脚本文件名 文件 
       -E -s                     vim -es <脚本文件名 文件  
    3. vim提供两个命令行参数来录制命令
       参数   作用                                    示例 
       -w   将操作录制起来，如果脚本文件已存在则覆盖       vim -w script.vim 文件 
       -W   同上但是如果脚本文件已存在则添加到末尾         vim -W script.vim 文件 
*** 例子
    1. 个创建导航窗口的脚本
       #+BEGIN_SRC vim
       " 用来更新目标窗口内容及更新目标文件名的函数。 
       " 当双击或者输入CTRL-]时调用这个函数。 
       function! SToc(tag) 
       " 高亮标题 
       exe 'match Todo /\%' . line(".") . 'l/' 
       " 获取目标窗口当前的编号 
       let nr=bufwinnr(bufname(g:xbn)) 
       " 跳到目标窗口 
       exe nr."wincmd w" 
       " 在目标窗口中打开tag 
       silent! exe "tag " . a:tag 
       " 更新目标窗口中的文件名（全局变量） 
       let g:xbn=bufname('%') 
       endfunction 
       
       " 负责初始化的函数 
       function! IToc() 
       " 如果当前编辑区无文件，则打开一个临时窗口 
       if bufname('%')=="" | view _blah_  | endif 
       " 初始化全局变量，这个变量用来跟踪当前编辑区的文件名 
       let g:xbn=bufname('%') 
       " 打开一个窗口并做导航 
       vsp __目录__ 
       " 不需要实体文件 
       setlocal buftype=nofile 
       " 简单的语法高亮 
       syn match Comment "[^-]" 
       " 从tags读取信息并转换成“用户友好”的格式显示 
       call append(line('$'), 
       \map(taglist("^"), 
       \'substitute(printf("%-30s%s",v:val["name"],' . 
       \'(has_key(v:val,"author")?v:val["author"]:""))," 
       ","-","g")' 
       \)) 
       " 定义导航键 
       map <2-LeftMouse> :call 
       SToc('/'.expand("<cword>"))<CR>zt 
       nmap <C-]> <2-LeftMouse> 
       endfunction 
       
       " 定义打开导航窗口的命令 
       command! -nargs=0 Toc call IToc() 
       #+END_SRC
** 可视模式
   1. v 按字符选择
   2. V 按行选择
   3. C-V 列块选择
** 正则表达式
*** 特殊位置符号
    1. 单词界限  \<,\>
*** 常用的通用表达式如下:(认为magic选项打开) 
**** 简单的元素: 
     x    字符x     ^    一行的开始处 
     $    一行的结尾处. 
     .     单一的字符 
     \<    查找字符串的开始标记 
     \>    查找字符串的结束标记. 
**** 范围运算符: 
     [abc]          匹配a,b 或是c 
     [^abc]          匹配除abc以处的字符 
     [a-z]           匹配从a到z的所有小写字符 
     [a-zA-Z]      匹配所有字符,包括大小写. 
**** 字符类: 
     [:alnum:]     匹配所有的字符和数字 
     [:alpha:]     匹配所有的字符 
     [:ascii:]     匹配所有的ASCII字符 
     [:backspace:]    匹配退格符<BS> 
     [:blank:]    匹配空格和Tab 
     [:cntrl:]     匹配所有的控制字符 
     [:digit:]    匹配所有的数字 
     [:escape:]    匹配Esc 
     [:graph:]     匹配所打印的字符,不包括空格 
     [:lower:]     匹配所有的小写字符 
     [:print:]    匹配所有的要打印字符,包括空格 [:return:]    匹配所有的行末符号(包括<Enter>,<CR>,<NL>). 
     [:punct:]    匹配所有的功能符号 
     [:space:]    匹配所有的空白符 
     [:tab:]           匹配Tab 
     [:upper:]     匹配所有的大写字符 
     [:xdigit:]    匹配十六进制数字. 
**** 类型: 
     \(pattern\)    标记一个类型以后使用 
     \1        与第一个在\(\)中的子表达式匹配的字符串匹配相同的字符串 
     例如表达式\([a-z]\)\1 可以匹配aa,bb 或是类似的. 
     \2        与\1 相类似,但是是使用第二个子表达式 
     \9        与\1 相类似,但是是使用第九个子表达式 
**** 特殊字符: 
     \a    大小写字母字符 
     \A    除了a-zA-Z以外的字母字符 
     \b     <BS> 
     \d    数字字符 
     \D    非数字字符 
     \e     <ESC> 
     \f    由isfname选项定义的文件名字符 
     \F    文件名字符,但是不包含数字 
     \h    单词的头字符(A-Za-z) \H    不是单词的头字符(A-Za-z) 
     \i    由isdent 选项定义的字符 
     \I    定义的字符,但是不包括数字 
     \k    由iskeyword选项定义的关键字字符 
     \K    关键字字符,但是不包括数字 
     \l    小字字符(a-z) 
     \L    非小写字符(除了a-z以外的字符) 
     \o    八进制数字 
     \O    非八进制数字 
     \p    由isprint 选项定义的可打印字符 
     \P    可打印字符,但是不包括数字 
     \r     <CR> 
     \s    空白符<Space>和<Tab> 
     \S    非空白符 
     \t     <Tab> 
     \u    大写字母字符(A-Z) 
     \U    非大写字母字符 
     \w    单词字符(0-9A-Za-z) 
     \W     非单词字符 
     \x    十六进制数字 
     \X    非十六进制数字 
     \~    匹配最后指定的字符串 修饰符: 
      *    匹配0 次或是多次,尽可能多的匹配 
     \+    匹配1 次或是多次,尽可能多的匹配 
     \=    匹配0 次或是1 次 
     \{}    匹配0 次或是多次 
     \{n} 
     \{-n}    匹配n 次 
     \{n,m}      匹配n 次到 m次 
     \{n,}    匹配n 次到多次 
     \{,m}     匹配0 次到 m次 
     \{-n,m}      匹配n 次到m次,尽可能少的进行匹配 
     \{-n,}    至少匹配n 次,尽可能少的进行匹配 
     \{-,m}     匹配到m次,尽可能少的进行匹配 
     \{-}    匹配0 次到多次,尽可能少的进行匹配 
     str1\|str2    匹配str1 或是str2
*** 例子
    1. 查找后面不是跟回车的回车
       \n\n\@!是查找后面不跟回车的回车
** 寄存器
*** 数字寄存器0-9
    1. 寄存器0存着上一次复制操作所复制的文本
      2. 1-9分别保存着你最近删除的文本
*** 字母寄存器a-z，A-Z
    1. 使用大写的寄存器进行复制或删除文本时，寄存器原来的内容会被保存，内容附加在原来的内容后面
*** 其他寄存器
    1. ""
       无名寄存器。保存最近一次复制或删除的文本
    2. "_
       短删除寄存器，若删除的文本不足一行（不包含换行符），则放入其中
    3. ":  ".  "%  "#
       只读寄存器，它们分别用来保存最近一次在命令行窗口使用的而命令，最近一次插入的文本，当前编辑的文件名，当前的替代文件名
    4. "=
       表达式寄存器：它的主要作用是实时计算表达式的值
       在编辑 
       输入时、在命令窗口输入时、在搜索时。使用的方式是按Ctrl-R再按等号（<C-R>=），接着输入表达式，原来输入的位置就会插入表达式的值。例如 
       :/<Ctrl-R>=@a*4<Enter>/<Enter> 。
       如果在输入=号后直接按回车没有输入表达式的话默认使用上一次使用的表达式。
    5. "* "+ "~  
       选择与拖放的寄存器。在 Windows 中这几个寄存器就是剪贴板。在 Linux 中它们也是剪贴板——但这几个寄存器是有所区别的。  
    6. "_  
       黑洞寄存器删除操作会影响现有数字寄存器的内容。前一个数字寄存器的值传给后一个数字寄存器，"9的内容被丢弃，新删除的文本则放入"1。这至少有两个直接的影响，一是"9的内容被丢弃；二是寄存器中文本的位置都发生了变化。而复制操作会改变"0 的值。如果你不希望删除或复制的操作影响数字寄存器的话就使用这个寄存器。使用这个寄存器进行删除或复制的内容都会被丢弃——这还可以提高一点速度节省一点空间。
    7. "/
       搜索式样寄存器。保存上一次搜索所使用的式样。注意这也包括了 s 命令中所使用的搜索式样。  
*** 寄存器命令
    1. 命令行中复制、删除和粘贴分别是`:y‘、`:d‘、`:pu‘。寄存器的使用方式是直接在上述命令后面加上寄存器的名称——不需要在寄存器前加入"号。如： 
       :2,4y a  
       将第2 至4行的文本复制到寄存器a中。 
       :'<,'>d A  
       将选中的行删除并将其内容附加到寄存器 a中。 
       :pu! a  
       将寄存器a的内容粘贴到当前行之前。 
    2. 使用<C-R>的方式可适用于各种输入的环境中：
       在插入模式输入时、在命令窗口输入时、在搜索时。在插入模式时要输入寄存器内容并不需要退回到一般模式再使用p指令，可以直接按`<Ctrl-R>e‘当然e可以改成相应的寄存器名。
    3. q寄存器
       q命令可以记录击键操作放入寄存器变量中
    4. redir @寄存器
       重定向命令中，所有的echo都被写入了寄存器中，如
       :redir @a 
       :echo "目录：" 
       :g/^第.\{1,3}章 /echo getline(".") . "\t\t\t" . 
       line(".") 
       :redir END 
    5. 
       
** 高亮
*** 环境配色
    1. 颜色设置
       " guifg表示图型介面（gui）下的前景色（ForeGround）  guibg表示图型介面（gui）下的背景色（BackGround）
       " 这里的值可以是名称也可以是数值，不仅可以使颜色，也可以是字体
       :hi {组} guifg={值} guibg={值}
       
       " 这条命令使{组1}使用与{组2}一样的颜色设置(或字体设置) 
       :hi link {组1} {组2} 
       注：
       1) “:hi link {组} NONE”是:hi link的一种用法，用来清除组的颜色关联
       2) hi不仅可以设置颜色，也可以设置字体，如：:hi ErrorMsg term=bold,reverse cterm=bold,reverse gui=reverse
       3) 因为Normal组是做为Vim的基准设定，所以对Normal进行的字体样式设定将被忽略
       4) 如果在关联之前{组1}组已经定义过了了，则要使用加!号的形式:hi! link否则提示错误。  ·
       5) 当{组1}关联到{组2}后， {组1}组使用与{组 2}一样的颜色设置。 如果此时再用:hi对{组1}定义颜色，则关联被取消。{组1}回复到设置关联前的颜色设置（如果有的话） ，再应用新定义的颜色。
       6) default开关项。由于Vim有多个配置文件，又有语法文件定义颜色。所以一组颜色可能被多次定义，为了让某一组颜色只在未定义时关联到其他组。可以使用开关项 default： 
	  ·       :hi default link {组1} {组2} 
    2. 可以设置的组
       Cursor  光标 
       ErrorMsg  命令行中的错误提示 
       Folded 折叠行 
       LineNr  行号 
       NonText  非文本区（控制字符和一些特殊字符和编辑器空白区等） 
       Normal  编辑区一般文本的前景和背景色 
       Search  搜索 
       StatusLine  状态行 
       Visual  圈选区
    3. 
*** 语法高亮
    1. 步骤
       先用:hi命令定义组及其使用的颜色。
       再用:match告诉Vim编辑区文本中哪些部分是属于自定义组的。
       最后，Vim会根据:match设置的规则将当前编辑区文本分为许多不同的组（如果有定义多个组的话），并对不同的组应用:hi为其分配的颜色 
    2. match
       :match {组} /匹配样式/
       告诉vim，凡匹配样式的字符串，应用指定{组}的颜色
       NOTE:
       由于使用match命令时前一个match定义的组的颜色会丢失。用match命令你没办法同时显示多种颜色。因此一般在match命令前加上syn[tax]，就可以显示所有自定义的颜色
    3. 其实:syntax match的语法与match的语法是不同的。
       
** g{x}操作
   1. gq
      重排文档
   2. gU、gu、g~
      改变大小写
   3. ga
      显示光标当前字符的十六进制
   4. g?
      用Rot13来加密选择的文本
   5. g^
      将光标移动到当前屏幕的第一个非空字符处。
   6. g0
      将光标移动到当前png木的第一个字符处
   7. g$
      向右移动当前屏幕的结尾处
   8. gm
      移动到屏幕的中间
   9. gj、gk
      移动光标到屏幕显示的上一行或下一行，而不管实际上他们是不是一行
   10. gv
       重复上一次可视化模式时选中的文本，重复gv就可以在当前选中与上一次选中的文本之间切换
   11. gh、gH、gC-H
       进入字符选择模式、行选择模式、块选择模式
** TAGS
*** TAGS文件格式
    共有三栏（一般也都是三栏），栏与栏之间用一个制表符（Tab）分隔。
    最前面一栏是标签，后面是具体的位置信息——为表示方便我们估且称之为锚点。
    第二栏用于定位到特定文件，
    第三栏将位置具体到特定的行。
    NOTE:
    第三栏可以用用Ex命令表示。所以遇到"norm 30G4|"Vim会将光标定位到第 30 行的第4 列
    第三栏后面有“尾巴”。Vi或其他编辑器中“;"”后的内容被视为注释。但 Vim可以读取这部分的内容，所以我们可以通常这一部分为 tags添加额外的信息(键值对)。
    要记住，每一项之间要用制表符分开（包括;"与第一项之间），键与值之间用冒号（:）分隔。
    Vim支持中文键值但不支持中文键名
    ：tags文件的编码(encoding)要与Vim的默认编码一致，不然可能会出现中文文字工作不正常的情况
*** 制作Vim文档的步骤： 
    1.  写作并在适当的地方加入锚点和标签。写Vim 文档的惟一要求就是对标签和锚点应用特定的样式：  
	o  锚点样式：在关键字两边加上“*”号和空格表示一个锚点；另外，关键字不能包含空格；如：  *vim:*  。  
	o  标签样式：在关键字两边加上“|”。如：|vim:|。  
    2.  在文档的最后插入modeline。这是可选步骤。  
    3.  在文档中使用了上面的规则后，用:helptags .生成 tags 文件。  
    4.  使用:tag等命令访问文档 
*** 扩展ctags的语言支持
    1. 些定义新的语言需要用到的“选项”： 
       `–langdef=<lang>‘  
       告诉ctags，你要定义一种新的语言。如: –langdef=texinfo 
       `–langmap=<lang>:<ext1>[<ext2><…>][,<lang2>:<ext…>]‘  
       将该语言与特定的扩展名关联起来。如：–langmap=texinfo:.texi.texinfo 将扩展名“.texi”与“.texinfo”都关联到新定义的语言“texinfo” 
       `–regex-<lang>=/regexp/replacement/[kind-spec/][flags]‘ 
       <lang>部分放上新定义的语言的名称。“regexp”是用来抓锚点的正则表达式，
       “replacement”部分定义了与锚点对应的标签。这一部分的语法与 Vim 的:s 命令一样，只是正则语法上有些区别。 比如，用这个正则  /class\W(foobar)/\1/ 抓锚点“class  foobar” 后，可用标签 foobar 引用该锚点。
       “kind-spec”可以设定该 tag 的“kind”项，Taglist插件用kind项的值对tag进行分类。
       “flags”指定所使用的正则版本及是否区分大小 写。默认使用扩展的正则表达式（Extended Regular Expression）即 egrep所使用的正 则语法。加上 b 可使用基本的正则语法——grep 的默认的正则语法。加上 i，则不区分大小写。如：–regex-texinfo=/^@chapter\W+(.+)$/\1/c/
*** 增加taglist支持
    1. 

** 万能补全
   1. 自定义补全函数的基本框架
      func! Mycomp(start,base) 
      if a:start 
      " 返回欲匹配字的起始位置。对于英文就是往前找到第一个非字母字符的位置。 
      else 
      " 返回匹配列表。 
      endif 
      endfunc 
   2. 补全函数说明:
      1. 之所以有这种奇怪的结构是因为这个函数实际要干两件事，就是上面注释中写的那两件事。这个程序会被调两次。
	 a:start可以认为是一个flag，第一次调用时这个值为1第二次调用时值为0。
	 base表示的是要进行补全的内容。前面我们说了omnifunc被调用了两次第一次返回的值，Vim会将之视为欲匹配字的起始位置，这个位置到光标所在栏之间的字串就是base。
	 如果第一次调用时未返回值则base为整行。返回负数base为空。 
	 第二次所返回的将是匹配列表。空列表（list）或负值视为无匹配。
      2. 自动补全返回的是列表，但列表项可以使用字典的形式。如： 
	 return [{"word":"abc","kind":"v","info":"变量"}, 
	 {"word":"eee","info":"也是变量"}] 
	 其中word就是补全的值，而info是一些附加信息将会在preview窗口中显示。
	 其他可以在返回列表项中使用的键（key）可以见*complete-items* 
   3. 一个补全函数的例子
      func! Mycomp(st,base) 
      if a:st 
      return 2 
      else 
      echo "base=" . a:base 
      return ["XXX","YYY"] 
      endif 
      endfunc 

      se omnifunc=Mycomp 
      abcd<C-X><C-o>
      补全的结果为
      abXXXX
** 编码
   1. 使用指定编码方式打开文件
      :se enc=utf8 | e ++enc={encode} yourfile
      或
      :se enc=utf8 fencs={encode}| e yourfile 
      与上面的命令的不同之处在于，这条命令只有在文件的内容符合korea(euc-kr/cp949)的编码规则时才将fenc设为korea。而上一条命令则是无条件的将编码设置为korea。
   2. 
** 模拟Notepad
   如果我们设置了insertmode选项,那么Vim默认的便为插入模式.我们可以通过命令CTRL-O暂时切换到正常模式.相关的命令如下: 
   :set im 
   :set insertmode :set noim 
   :set noinsertmode
   CTRL-L    类似正常情况下的ESC，返回普通模式
   NOTE：
   这个时候ESC键失去原有的责任
 
** 保存编辑中的信息
*** mksession与source
    1. set sessionoptions=
       buffers            保存所有的缓冲区.包括在屏幕上显示的以及隐藏的和卸载的缓冲区. 
       globals         保存全局变量.这些全局变量是由大写和至少一个小写字母组成的. 
       help         帮助窗口 
       blank          屏幕上的空窗口 
       options        所有的选项和键盘映射 
       winpos           GUI窗口的位置 
       resize         屏幕的尺寸 
       winsize          窗口的尺寸 
       slash          在文件名中用斜线来代替空格. 
       unix          用UNIX的行结尾格式来保存程序信息文件. 
*** wviminfo与rviminfo
    1. 
** Set 选项设置  
   set all 列出所有选项设置情况。  
   set term 设置终端类型。  
   set ignorecase 在搜索中忽略大小写。  
   set list 显示制表位(^I)和行尾标志($)。  
   set number 显示行号。  
   set showmode 示用户处在什么模式下  
   set report 显示由面向行的命令修改国的行数目。  
   set terse 显示简短的警告信息。  
   set warn 在转到别的文件时，若没有保存当前文件则显示  No write 信息。  
   set autowrite 在&ldquo;:n&rdquo;和&ldquo;:!&rdquo;命令之前都自动保存文件  
   set nomagic 允许在搜索模式中，使用前面不带\的特殊字符。  
   set nowrapscan 禁止  vi 在搜索到达文件两端时,又从另一端开始。  
   set mesg 允许  vi 显示其他用户用  write 写到自己终端上的信息。  
   autoindent (ai) noai 使新行自动缩进,和上(下)行的位置对齐  
   autoprint (ap) ap 每条命令之后都显示出修改之处  
   autowrite (aw) noaw 在:n,:!命令之前都自动保存文件  
   beautify  (bf)  nobf  在输入的时候忽略所有的控制字符(除了制表键(tab),换行(newline),进纸(formfeed))  
   directory= (dir=) /tmp 存放缓冲区的目录名  
   edcompatible noedcompatible 在替换的时候使用类ed 的用法  
   errorbells (eb) errorbells 出错的时候响铃  
   exrc (ex) noexrc 允许在主目录(home)外面之外放.exrc文件  
   hardtabs= (ht=) 8 设置硬制表的边界  
   ignore case (ic) noic 正规式里忽略大小写  
   lisp nolisp 打开lisp模式  
   list nolist 显示所有的制表键和行的结尾  
   magic agic 可以使用更多的正规表达式  
   mesg mesg 允许向终端发送消息  
   number (nu) nonumber 显示行号  
   open open 允许开放和可视化  
   optimize (opt) optimize 优化吞吐量,打印时不发回车  
   paragraphs= (para=) IPLPPPQPPLIbp 设置{ & }的分界符  
   prompt prompt 命令模式下的输入给出:的提示符  
   readonly (ro) noro 除非用!号否则不准保存文件  
   redraw noredraw 当编辑的时候重绘屏幕  
   remap remap 允许宏指向其他的宏  
   report= 5 如果影响的行数>这个数的话就报告  
   scroll 1/2 window 下卷屏幕时滚动屏幕的数目, 同样这也是z命令输出的行数(z输出2 倍滚屏的大小)  sections= SHNHH HU 定义节的末尾(当使用命令[[ 和  ]]  时)  
   shell= (sh=) /bin/sh 缺省的SHELL,如果设置了环境变量SHELL的话,就使用变量  
   shiftwidth= (sw=) 8 当使用移动(shift)命令时移动的字符数  
   showmatch (sm) nosm 显示{, }, (, ), [,  或者  ] 的匹配情况  
   showmode noshowmode 显示你处在什么模式下面  
   slowopen (slow) 插入之后不要立刻更新显示  
   tabstop= (ts=) 8 设置制表停止位(tabstop)的长度  
   taglength= (tl=) 0 重要标记的字符个数(0 表示所有的字符)  
   tags= tag, /usr/lib/tags 定义包含标记的文件路径  
   term= 设置终端类型  
   terse noterse 显示简短的错误信息  
   timeout (to) timeout 一秒钟后键盘映射超时  
   ttytype= 设置终端类型  
   warn warn 显示"No write since last change"信息  
   window= (w=) 可视模式下窗口的行数  
   wrapmargin=  (wm=)  0 右边距,大于0 的话最右边的单词将折行,留出n个空白位置  
   wrapscan (ws) ws 查找到文件尾后再重头开始  
   writeany (wa) nowa 可以保存到任意一个文件去 
