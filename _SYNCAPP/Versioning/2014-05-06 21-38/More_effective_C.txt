                           More_effective_C
                           ================

Author: lujun9972 <lujun9972@X41>
Date: 2013-03-26 07:08:15 CST


Table of Contents
=================
1 基础 
    1.1 指针和引用区别 
    1.2 尽量使用C++风格的类型转换 
    1.3 不要对对象数组使用多态,但可以对指向对象的指针数组使用多态 
    1.4 避免误用的缺省函数 
2 运算符 
    2.1 谨慎定义类型转换函数 
    2.2 区别自增和自减operator的前置和后置形式 
    2.3 千万不要重载&&，||和,操作符（因为你永远无法模拟它们） 
    2.4 了解不同意义的new和delete 
3 异常 
    3.1 防止构造函数在存在异常时发生资源泄露 
    3.2 理解"往catch语句传参数"与"往函数传递参数"的差别 
    3.3 使用引用异常 
4 技巧 
    4.1 如何将构造函数和非成员函数虚拟化 
    4.2 如何限制某个类能产生的对象数量 
    4.3 如何要求/禁止在堆中产生对象 
        4.3.1 要求在堆中建立对象 
        4.3.2 判断对象是否在堆中. 
        4.3.3 禁止堆对象 
    4.4 智能指针 
        4.4.1 智能指针和基础类到基类的类型转换 
        4.4.2 智能指针和const 
    4.5 引用计数 
    4.6 代理类 
    4.7 让函数根据一个以上的对象来决定怎么虚拟 
5 其他杂项 
    5.1 在未来时态下开发程序 
    5.2 将非尾端类设计为抽象类 
    5.3 如何在同一程序中混合使用C++和C 
        5.3.1 名变换 
        5.3.2 静态初始化 
        5.3.3 动态内存分配 
        5.3.4 数据结构的兼容性 


1 基础 
~~~~~~~

1.1 指针和引用区别 
===================
   1. 指针可以指向空值,引用不能指向空值
   2. 指针定义时可以不初始化,引用定义时必须初始化
   3. 指针可以被重新赋值指向另一个对象,而引用在初始化时被指定的对象,以后不能改变,但它和本体的值会因赋值而改变
   4. 如果你需要重载一个操作符时,应该使用引用

1.2 尽量使用C++风格的类型转换 
==============================
   1. const_cast不仅仅能转换掉const属性,还能转换掉volatileness属性
   2. reinterpret_cast最普遍的用途就是函数指针之间转换,但是该转换不一定可行

1.3 不要对对象数组使用多态,但可以对指向对象的指针数组使用多态 
==============================================================
   1. 通过一个基类指针来删除一个含有派生类对象的数组,结果将是不确定的.

1.4 避免误用的缺省函数 
=======================
   1. 没有缺省构造函数的类使用起来会有所限制
      * 无法建立数组(因为一般来说无法在建立对象数组时给构造函数传递参数),除非类中定义placement new方法,在自定义的new中调用构造函数
      * 无法在许多基于模板的容器类里使用(因为模板内部的实现往往是通过数组实现的)
   2. 提供无意义的缺省构造函数也会影响类的工作效率，因为需要是不是得测试对象是否正确地初始化。因此如果缺省构造函数无意义的话，尽量避免使用它们。

2 运算符 
~~~~~~~~~

2.1 谨慎定义类型转换函数 
=========================
   1. 有两种函数允许编译器进行隐式类型转换:
      * 单参数构造函数(包括除了第一个参数,所有参数都有缺省值得情况)
      * 隐式类型转换运算符
        隐式类型转换运算符只是一个样子奇怪的成员函数：operator 关键字，其后跟一个类型符号。你不用定义函数的返回类型，因为返回类型就是这个函数的名字。
   2. explicit关键字，只会拒绝隐式类型转换而调用构造函数。显式类型转换依然合法。
   3. 隐式类型转换只会转换一次，即不会A转成B再转成C
  struct B
  {
      B(int){};
  };
  struct D2
  {
      D2(B ){};
  };
  void test(D2)
  {
      cout<<"D2 created"<<endl;
  }
  int main()
  {
      test(1);  //编译出错，不能int->B->D2
  }

2.2 区别自增和自减operator的前置和后置形式 
===========================================
   1. 前置operator不带参数，而后置operator带一个int参数，在调用时，编译器自动赋值为0
   2. 前置返回一个reference，而后置返回一个const对象（主要是为了防止i++++能够编译通过，而且i只增加一次，不合逻辑）
   3. 后置式operator的实现应该以前置式operator为基础。

2.3 千万不要重载&&，||和,操作符（因为你永远无法模拟它们） 
==========================================================
   1. C++对&&和||采取“骤死式”的评估方式。
      然而当重定义这些运算符时，“函数调用语义”会取代“骤死式语义”。
      “函数调用语义”意味着：所有参数都必须评估完成，各参数评估的次序未知
   2. C++对,的评估方式为：逗号左边会先评估，然后逗号的右边再被评估，最后整个逗号表达式的结果以逗号右边的值为代表。

2.4 了解不同意义的new和delete 
==============================
   1. new operator(也叫new表达式)和operator new是不同的
      A* a = new A(),这里的new是new operator,它是C++内置的，你不能改变它的意义（无法重载），它总是先分配足够内存然后调用构造函数初始化内存中的对象。
      new operator调用operator new来完成第一部分内存的分配步骤，operator new能够被重载
   2. 当调用new operator来分配数组时，就不是调用operator new来分配内存，而是调用operator new[]来分配内存
   3. operator new通常声明为void* operator new(size_t size);这里返回类型为void*因为函数返回的是一个未初始化内存的指针。
      你能够增加额外的参数重载函数operator new，但是第一个参数类型必须是size_t
   4. delete operator和operator delete也是类似的不同。

3 异常 
~~~~~~~

3.1 防止构造函数在存在异常时发生资源泄露 
=========================================
   1. 如果你用对应的auto_ptr对象替代指针成员变量，就可以防止构造函数在存在异常时发生资源泄漏，你也不用手工在析构函数中释放资源，并且你还能象以前使用非const指针一样使用const指针，给其赋值。 

3.2 理解"往catch语句传参数"与"往函数传递参数"的差别 
====================================================
   1. 在函数中声明函数与在catch子句中声明参数几乎没什么差别,但
      无论通过传值捕获异常还是通过引用捕获异常,都将对传入catch的参数进行拷贝动作.
      当异常对象被拷贝时,拷贝操作是由对象的拷贝构造函数完成的.该拷贝构造函数是对象的 *静态类型* 所对应的拷贝构造函数,而不是对象的动态类型对应的拷贝构造函数.
  struct B
  {
      virtual void say(){cout<<"this is "<<typeid(*this).name()<<endl;}
  };
  struct D:public B
  {
  };
  
  int main()
  {
      try{
          D d;
          B& rb = d;
          rb.say();      //this is D1
          throw rb;      //这里抛出的是rb的拷贝,类型位B
      }catch(B& b) 
      {
          b.say();       //this is B1
      }
  }

      在函数调用中不存在传递一个临时对象到一个非const引用类型的参数里,但是在异常中却被允许.
      函数的实参在传递给形参时会发生隐式类型转换,但catch子句在匹配异常类型时不会进行这样的转换.
   2. 异常是其它对象的拷贝，这个事实影响到你如何在catch块中再抛出一个异常。比如
  catch (Widget& w)                 // 捕获Widget异常 
  { 
  ...                             // 处理异常 
  throw;                          // 重新抛出异常，让它 
  }                                 // 继续传递 
  catch (Widget& w)                 // 捕获Widget异常 
  { 
  ...                             // 处理异常 
  throw w;                        // 传递被捕获异常的 
  }                                 // 拷贝

       这两个catch块的差别在于第一个catch块中重新抛出的是当前捕获的异常，而第二个catch块中重新抛出的是当前捕获异常的一个新的拷贝。
   3. 不过在catch子句中进行异常匹配时可以进行两种类型转换。
      * 继承类与基类间的转换。
      * 允许从一个类型化指针（typed pointer）转变成无类型指针(所以带有const void* 指针的catch子句能捕获任何类型的指针类型异常)

3.3 使用引用异常 
=================
   1. bad_alloc,bad_cast,bad_typeid,bad_exception都不是指向对象的指针,必须通过值或引用来捕获它们.
   2. 通过值捕获,它们抛出时系统将对异常对象拷贝两次,而且它会产生切片问题

4 技巧 
~~~~~~~

4.1 如何将构造函数和非成员函数虚拟化 
=====================================
   1. 虚拟构造函数是指能够根据输入给它的数据的不同而建立不同类型的对象的成员函数(不是构造函数!!).
   2. 虚拟拷贝构造函数返回一个指针,指向调用该函数的对象的新拷贝.因此其名字通常为clone()
   3. 被派生类重定义的虚拟函数不用必须与基类的虚拟函数具有一样的返回类型:
      如果函数的返回类型是一个指向基类的指针(或一个引用),那么派生类的函数可以返回一个指向基类的派生类的指针(或引用)
   4. 根据参数的不同动态类型而行为特征也不同的非成员函数叫做虚拟化的非成员函数
   5. 虚拟化的非成员函数实际上也是通过参数中的成员函数来实现的.

4.2 如何限制某个类能产生的对象数量 
===================================
   1. 在类中的静态对象总是被构造和释放的,及时不使用该对象.
      函数中的静态对象只有在第一次执行函数时才会建立对象.
   2. 我们能够准确地知道函数的静态成员在第一次执行定义静态成员的函数时初始化.
      而无法定义一个类的静态成员被初始化的时间.
   3. 带有内部链接的函数可能在程序内被复制,这种复制也包含函数内的静态对象.
      因此如果建立一个包含局部静态对象的非成员内联函数,你可能使程序的静态对象的拷贝超过一个.
      所以,不要建立包含局部静态对象的非成员函数的内联函数.
   4. 可以在public:中使用using语句using private函数,这样可以把private函数恢复public访问权限.

4.3 如何要求/禁止在堆中产生对象 
================================

4.3.1 要求在堆中建立对象 
-------------------------
    1. 非堆函数在定义它的地方被自动构造,在生存时间结束时自动释放,所以要禁止使用隐式的构造函数和析构函数就可以实现这种只能通过new手段建立对象的限制了.
       最好让析构函数成为private(结果是该类不能被继承)或protected(该类可以被继承),让构造函数成为public.
       你可以引进一个专用的伪析构函数,用来访问真正的析构函数.客户端调用伪析构函数释放他们建立的对象.(注意,异常处理体系要求所有在栈中的对象的析构函数必须申明为公有!)
  class A
  {
  public:
      void destory()const {delete this;}  //伪析构函数
  private:
      ~A(){}
  };
  int main()
  {
      //A a;             //编译出错 error: 'A::~A()' is private
      A* a = new A();    //能编译通过
      //delete a           //错误,~A() is private
      a->destory;          //正确,通过调用伪析构函数,访问真正的析构函数.
  }

4.3.2 判断对象是否在堆中. 
--------------------------
    1. 在new一个数组时,只会调用一个operator new[],执行多次构造函数.因此不能通过在operator new和operator new[]中设置成员变量的方式来判断对象是否在堆中.
    2. 静态对象可能分配在堆中也可能分配在栈中,它们的位置依据系统而定.
    3. 我们可以通过抽象混合(mixin)基类给派生类提供判断指针指向的内存是否由operator new分配的能力.

4.3.3 禁止堆对象 
-----------------
    1. 禁止对象在堆中直接实例化
       由于new操作符总是调用operator new函数,因此可以自己声明operator new函数,并把它作为private权限.
    2. 禁止对象作为派生类的基类在堆中实例化
       如果operator new和operator delete没有在派生类中进行声明,它们就会继承基类中的版本,因此,基类中声明了private的operator new和operator delete,也能阻碍类作为一个位于堆中的派生类对象的基类被初始化.
       如果派生类声明它自己的operator new,当在堆中分配派生对象时,就会调用自己的operator new函数.这就得另找一个不同的方法来防止基类的分配问题.
    3. 对象被嵌入到其他对象内,在堆中实例化
       类的operator new是private这一点,不会对包含该类对象的对象分配产生任何影响.

4.4 智能指针 
=============
   1. 因为当调用auto_ptr的拷贝构造函数时,对象的所有权被传递出去,所以通过传值方式传递auto_ptr对象是一个很糟糕的方法.
   2. T& operator*()的返回值需要设置为reference
   3. 一个智能指针如果提供了默认转换为原始指针,则可能出现delete smart_ptr<T>的写法,这样会导致一个对象指针被delete两次.
      因此除非有必要,否则尽量不要提供转换到原始指针的隐式类型转换符.

4.4.1 智能指针和基础类到基类的类型转换 
---------------------------------------
    1. smart_ptr<Base>和smart_ptr<Sub>之间并无任何关系,不能认为这两个智能指针之间存在继承关系.
       1) 但是可以通过在smart_ptr<Sub>中定义隐式类型转换符operator smart_ptr<Base>的方式,模拟子类与基类指针之间的转换.
          这个方法有两个缺点:一,你必须认为特化smart_ptr<Sub>,这就破坏了模板的通用性.二,你可能必须添加许多类型转换符,因为你的对象可能位于继承层次中很深得位置.
       2) 声明(非虚)成员函数模板(成员模板),使用它来生成灵巧指针类型转换函数.它的原理与第一种方法一样的
  template<class newType>
  operator Smart_ptr<newType>()
  {
      return Smart_ptr<newType>(m_pointee);
  }

          这种方法也有个缺点,如果定义了函数Func(Smart_Ptr<Base>)和Func(Smart_Ptr<Sub>),那么对于Sub的子类SubSub,调用Func(Smart_Ptr<SubSub>)具有二义性,不知道把它转换为Smart_Ptr<Base>还是Smart_Ptr<Sub>
       3) 综上所述,无法让智能指针的行为与原始指针一样.最好的方法是使用成员模板生成类型转换函数,在会产生二义性结果的地方使用casts

4.4.2 智能指针和const 
----------------------
    1. 由于智能指针实质上只是一个类,所以const smart_ptr<C>表示智能指针中的pointee是不能变的.
       要表示智能指针指向一个const对象,需要定义为smart_ptr<const C>.
    2. 由于smart_ptr<C>和smart_ptr<const C>是两个完全不同的类型,因此不能用smart_ptr<C>初始化smart_ptr<const C>
    3. 由于const和non-const指针有类似于父类与子类的关系,因此可以考虑通过继承的方式实现smart_ptr和const_smart_ptr
  const_smart_ptr<T>
  {
       const T* cpt;
  }
  smart_ptr<T>::public const_smart_ptr<T>
  {
      T* pt
  }

4.5 引用计数 
=============

4.6 代理类 
===========
   1. const函数的调用与否,与其返回值是作为左值还是右值无关,而仅仅与调用成员函数的对象的const属性有关.
   2. operator[]无法判断其返回值会被用于左值还是右值,这是可以实现一个代理类,在该代理类中包含原类的一个引用,当对代理类写时就可以对原对象做个拷贝.

4.7 让函数根据一个以上的对象来决定怎么虚拟 
===========================================
   1. 无名命名空间的东西是当前编译单元(其实就是当前文件)私有,这很像文件范围内的static函数一样,有了命名空间之后,文件范围的static已经不赞成使用了.
   2. 

5 其他杂项 
~~~~~~~~~~~

5.1 在未来时态下开发程序 
=========================
   1. 用C++语言自己来表达设计上的约束条件,而不是用注释或文档
   2. 未来时态的考虑不是问一个类现在正被怎么使用,而是问这个类是被设计为怎么去使用的.
   3. 未来时态的考虑只是简单地增加了一些额外约束： 
      * 提供完备的类，即使某些部分现在还没有被使用。如果有了新的需求，你不用回过头去改它们。 
      * 将你的接口设计得便于常见操作并防止常见错误。使得类容易正确使用而不易用错。
        例如，阻止拷贝构造和赋值操作，如果它们对这个类没有意义的话。防止部分赋值。 
      * 如果没有限制你不能通用化你的代码，那么通用化它。
        例如，如果在写树的遍历算法，考虑将它通用得可以处理任何有向不循环图。 

5.2 将非尾端类设计为抽象类 
===========================
   1. 绝大部分纯虚函数都没有实现,但纯析构函数是个特例.它们必须被实现,因为它们在派生类析构函数被调用时也将被调用.
   2. 如果有两个实体类C1和C2,并且C2公有继承C1,那么你应该将两个类的继承层次改为三个类的继承层次,通过创造一个新的抽象类A,并将C1和C2都从它继承.
      这种修改的重要价值是强迫你确定抽象类.
      其目的是,确认有用的抽象,并强迫它们放入抽象类这样的实体.
      注意,只有在设计出得类能被将来的类从它继承而不需要它做任何修改时,你才能从抽象类中获得好处.

5.3 如何在同一程序中混合使用C++和C 
===================================
   1. 确保C++编译器和C编译器兼容

5.3.1 名变换 
-------------
    1. 名变换，就是C++编译器给程序的每个函数换一个独一无二的名字。在C中，这个过程是不需要的，因为没有函数重载，但几乎所有C++程序都有函数重名.因此C++编译器通常会对函数进行名变换.这需要一个办法来告诉C++编译器不要在这个函数上进行名变换.
    2. 要禁止名变换,需要使用C++的extern "C"指示符.
       不要将extern 'C'看作是申明这个函数是用C语言写的，应该看作是申明在个函数应该被当作好象C写的一样而进行调用。
  extern "C" void simulate(int iterations);
  extern "C"{
      void drawLine(int x1, int y1, int x2, int y2); 
      void twiddleBits(unsigned char bits); 
      void simulate(int iterations)
  }

5.3.2 静态初始化 
-----------------
    1. 在C++的main执行前和执行后都有大量代码被执行。
       静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的构造函数通常在main被执行前就被调用。
       通过静态初始化产生的对象也要在静态析构过程中调用其析构函数；这个过程通常发生在main结束运行之后。
    2. 如果main()不是用C++写的,那么前后的代码可能就不会被执行,从而C++库中的静态对象可能没有被初始化和析构.
       最好的办法是将C的main()改名,然后在C++的main()中调用C的main()函数

5.3.3 动态内存分配 
-------------------
    1. 将C++的new和delete与malloc和free进行严格的分离

5.3.4 数据结构的兼容性 
-----------------------
    1. 两种语言间的函数可以安全地交换指向对象的指针和指向非成员的函数或静态成员函数的指针
    2. C++中非虚函数的的struct或class的对象兼容了它们在C中的孪生版本(其定义只是去掉了这些成员函数的声明)
       在C++的struct中增加虚函数,会使得对象使用一个不同的内存结构,这就跟C不兼容了.
       从其它结构（或类）进行继承的结构，通常也改变其内存结构，所以有基类的结构也不能与C函数交互。
