* 若interactive的参数以*开头，则意义是，如果当前buffer是只读的，则不执行该函数
* 变量本地化
  * 普通变量通过make-localvariable或make-variable-buffer-local变为buffer－local的
	* make-variable-buffer-local使指定的变量在每个buffer中都是独立的
	* make-local-variable使变量在当前buffer是独立的，而其他buffer依然共享全局变量
  * hook变量智能通过make-local-hook变为buffer-local的
* 有三种方式可以加载文件：
  * load
  * autoload
  * require
* 使用eval-after-load可以推迟一段代码的执行
  (eval-after-load "触发条件的文件" 待执行的代码)
  这里，第一个参数的值必须跟上面三种方式加载文件时的值一模一样
* 可以直接使用(a . b)产生一个cons，注意a . b之间的空格
* MAX值
  * most-positive-fixnum和most-negative-fixnum定义了整数的范围
  * 
* 和C语言类似，如果参数都是整数，做除法时要记4(/ 5 6)是会等于0的，这跟common lisp不同
* elisp中，字符的读入语法为?字符，而common lisp中是#\字符.
  字符前也可以加上\来转义,如?\a表示控制字符
  另外,\M-代表Meta建,\C-代表control建
* 没有charp,因为字符就是整数,但是有char-or-string-p函数
* 使用char-equal比较字符时,需要注意case-fold-search变量的值,t表示忽略大小写
* 只有string=,string<函数,没有string>函数
* 转换函数
  * char-to-string / string-to-char
  * number-to-string / string-to-number
  * concat可以将序列转换成字符串
	#+BEGIN_SRC elisp
      (concat '(?a ?b ?c ?d ?e)) ; => "abcde"
      (concat [?a ?b ?c ?d ?e]) ; => "abcde"
	#+END_SRC
  * vconcat可以把字符串转换成向量
	#+BEGIN_SRC elisp
    (vconcat "abdef") ; => [97 98 100 101 102]
	#+END_SRC
  * append可以把字符串转换成一个列表
	#+BEGIN_SRC elisp
    (append "abcdef" nil) ; => (97 98 99 100 101 102)
	#+END_SRC
  * downcase / upcase
* length不能对点列表和环形列表求长度,但是可以用safe-length代替
* copy-sequence不能用于点列表和环形列表,可以用copy-tree函数拷贝点列表,但无法复制环形列表
* vector的读入语法为:
  [val1 val2 val3]
* 使用elt取序列中第n个元素,nth取列表中第n个元素,aref取数组的第n个元素
* 使用aref和aset访问或修改数组元素时,下标超出数组长度的话,会产生错误,所以要先确定数组的长度
* elisp中,使用一个名为obarray的向量来存放符号,lisp每读入一个符号都会intern到obarray中,如果想避免,可以在符号名前加上#::
  #+BEGIN_SRC elisp
    (intern-soft "abc") ; => nil
    'abc ; => abc
    (intern-soft "abc") ; => abc
    (intern-soft "abcd") ; => nil
    '#:abcd ; => abcd
    (intern-soft "abcd") ; => nil
  #+END_SRC
  obarray也是一种类型名称
* obarray类似common lisp中的package,我们也可以使用其他向量代替obarray,相关函数有
  * intern
  * intern-soft
  * unintern
  * mapatoms
* 符号的组成
  * 符号名称:symbol-name
  * 符号值:  symbol-value
	* 使用boundp测试符号是否有值
  * 函数:    symobl-function
	* 使用fboundp测试符号是否设置了函数
  * 属性列表:symbol-plist
	* 使用get/put来访问/修改某个属性值
	* 使用plist-get/plist-put来访问/设置属性列表中的属性
	* 属性列表是一个形如(prop1 value1 prop2 value2)的关联列表,但无法删除一个属性
* 列表的第一个表达式如果是一个符号,解释器会查找这个表达式的函数值.如果函数值是另一个符号,则会继续查找这个符号的函数值
* buffer-local变量
** 声明buffer-local变量
   * make-variable-buffer-local
	 各个缓冲区都有各自的buffer-local变量
   * make-local-variable
	 当前缓冲区产生一个局部变量,其他缓冲区仍然使用全局变量(推荐使用)
** buffer相关函数
*** with-current-buffer
   	#+BEGIN_SRC elisp
      ;使其中的body表达式在指定的缓冲区里执行(使用指定buffer的配置信息执行body表达式)
      (with-current-buffer buffer
      body)
   	#+END_SRC
*** get-buffer
	#+BEGIN_SRC elisp
      ;得到缓冲区名字的对应缓冲区对象,如果没有这个名字的缓冲区,返回nil
      (get-buffer buffer-name)
	#+END_SRC
*** default-value
	#+begin_src elisp
      ;访问符号的全局变量的值
      (default-value symbol)
	#+end_src
*** setq-default
	#+begin_src elisp
      ;修改符号作为全局变量的值
      (setq-default symbol-name)
	#+end_src
*** local-variable-p
	#+begin_src elisp
      ;测试变量是不是buffer-local的
      (local-variable-p symbol [buffer对象])
	#+end_src
*** buffer-local-value
	#+begin_src elisp
      ;得到其他缓冲区内的buffer-local变量值
      (buffer-local-value 符号 buffer对象)    
	#+end_src
*** default-boundp
	#+begin_src elisp
      ;判断符号是否有全局值
      (default-boundp 符号)    
	#+end_src
*** makunbound
	#+begin_src elisp
      ;使一个变量的值重新为空
      (makunbound 符号)
	#+end_src
*** kill-local-variable
	#+begin_src elisp
      ;清除一个buffer-local变量
      (kill-local-variable 符号)    
	#+end_src
*** kill-all-local-variables
	#+begin_src elisp
      ;清除所有的buffer-local变量,但是带有属性permanent-local的不会清除,带有这些标记的变量一般都是和缓冲区模式无关的
      (kill-all-local-variables)    
	#+end_src
* 变量名命名习惯
  * -hook 一个在特定情况下调用的函数列表，比如关闭缓冲«时，进入某个模式时。
  * -function值为一个函数
  * -functions 值为一个函数列表
  * -flag 值为nil或non-nil
  * -predicate 值是一个作判断的函数，返回nil或non-nil
  * -program 或-command 一个程序或shell名令名
  * -form 一个表达式
  * -forms 一个表达式列表。
  * -map 一个按键映射（keymap）
* docstring
  * 字符串的第一行最好独立的,因为apropos命令只显示第一行的文档
  * docstring以*开头的defvar变量被认为是用户选项（user option）
	* 用户选项可以通过命令set-variable交互设置
	* 可以使用edit-options命令编辑*scratch*
  * '符号名'生成一个链接
  * \\{major-mode-map}可以显示扩展成镇魂歌模式按键的说明
  * docstring最后那个的\[ command ]会被command的绑定键所代替
  * 如果不想要这种代替，需要用\=转义，当然，在Emacs的docstring中，真正的写法应该是
    #+begin_src elisp
      "\\=\\{major-mode-map}"
      "\\=\\[command]"
    #+end_src
* interactive
  * interactive可以后接字符串,表示获得参数的方式
  * interactive可以后接一个form,form的求值结果应该是一个list,这个list的值作为参数的实参
* 
