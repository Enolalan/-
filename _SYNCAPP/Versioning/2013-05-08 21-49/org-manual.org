* 总介
** 摘要            : org大概能够做什么的摘要
   Org是一种通过纯文本方式来快速而有效地记录笔记,处理待办列表,做项目计划的mode.
   
   Org通过一些NOTE文件来组织任务,这些NOTE文件用纯文本的方式包含了一些列的项目信息. Org是建立在Outline mode的基础之上的,Outline mode能够很好地组织大型文件的内容. 你可以使用可视的循环和结构编辑功能来帮助你编辑大纲树结构. 通过使用内置的表格编辑器,你也可以很容易地创建出一个表格. Org可以管理代办列表,设置最后期限,加时间戳,制定规划. 它动态的把这些东西显示在一个agenda中,在这个agenda中很好地集成了Emacs calendar和diary功能. 你可以用纯文本的方式记录各种类URL的连接,这些连接可以链接到网站,email,Usenet消息,BBDB(The insidious Big Brother Database)条目,和任何与项目有关的文件. 如果你想打印和分享这些记录,你可以把org导出为结构化的ASCII文件,比如HTML,或者iCalendar文件(仅限于TODO和日程条目). 它也可以作为发布工具,为一堆的相互链接的网页提供发布服务.

   作为一个项目计划的环境,Org通过为大纲节点增加元数据的方式工作. 正是基于这些元数据,我们可以通过查询抽取特定的记录并且动态地创建agenda视图.

   Org模式中也可以包含其他非org环境,这些环境运行你编辑文件中的内嵌源代码,更便利地执行代码,记录文档,进行文学化编程.

   通过激活Orgtbl mode,任何major mode都能拥有Org的表格编辑功能,这些表格编辑功能不仅自动化,上下文敏感,而且具有电子表格(spreadsheet)的运算能力. 通过一个转换步骤,就可以用它来包含一个表格到任意文件类型中(比如LaTeX). 通过minor Orgstruct mode,可以在非Org mode中使用Org的结构编辑和列表创建功能.

   Org保持简单的事情简单化. 当第一次使用它时,感觉它就是个简单易用的大纲编辑器. 它不强加给你复杂性,但是当你需要的时候,却会发现有大量的功能可以使用. Org就是一个工具盒,你可以为了不同的目的,通过的不同的途径来使用它,例如你可以把它看成是:
   #+BEGIN_EXAMPLE     
     • 一个具有可见性的转换和结构编辑能力的outline mode扩展
     • 一个记录结构化记录的ASCII系统和表格编辑器
     • 一个TODO列表的编辑器
     • 一个完整的日程表和计划规划工具,你可以设定工作的最后截止日期和规划执行日期.
     • 一个GTD系统
     • 一个简单的超文本系统,可以导出HTML和LaTeX格式的文件
     • 一个发布工具,可以用来创建一套相互链接的网页
     • 一个进行文学化编程的环境
   #+END_EXAMPLE

   有一个网站提供了最新版本的Org连接,还有附加信息,FAQ,和入门指导.这个网页就是http://orgmode.org
** 安装            : 下载org后,如何安装
   *注意*:如果你使用的是Emacs或者XEmacs中自带的Org版本,请跳过这一步直接前往[[Activition][激活]]. 如果需要查看你Emacs中自带的Org是什么版本的,按下 /M-x load-library RET org/ 然后再 /M-x org-version/.

   如果你从网站上下载了Org,不管它是zip还是tar格式的分发包,也不管它是不是Git存档,你必须遵照下面的步骤来安装它:
   解压Org分发包并进入解压的目录中,然后编辑顶层目录中的'Makefile'文件. 你必须设置Emacs的二进制执行文件的名字(一般是'emacs'或者'xemacs'),设置Lisp和Info文件存放的路径. 如果你没有权限访问全系统的目录,你只需要简单地把'lisp'子目录加入Emacs的load-path中,然后就可以运行org mode了.如果你用这种方法,需要把下面这一行加入'.emacs'文件中
   #+BEGIN_SRC emacs-lisp    
     (setq load-path (cons "~/path/to/orgdir/lisp" load-path))          
   #+END_SRC
   如果你想使用'contrib'子目录中的代码,你只需要加这么一句
   #+BEGIN_SRC emacs-lisp
        (setq load-path (cons "~/path/to/orgdir/contrib/lisp" load-path))
   #+END_SRC
   现在用下面的shell命令来把lisp文件编译为字节格式
   #+BEGIN_SRC sh
     make
   #+END_SRC
   如果你只是从发布目录运行Org,这就是所有的步骤了. 如果你想要安装Org到系统目录中,指向下面命令(需要系统管理员权限)
   #+BEGIN_SRC sh
     make install
   #+END_SRC
   安装Info文件是系统依赖的,不同的系统使用的是不同的'install-info'程序. 下面的命令理论上应该可以正确的安装Info文件到大多数系统中,但如果没有正确的安装的话,欢迎发送BUG报告给我们[fn:1]
   #+BEGIN_SRC sh
     make install-info
   #+END_SRC
   然后把下面一行添加到'.eamcs'文件中. 这使得Emacs可以在需要的时候自动加载文件中的函数,而不用在Org mode已启动的时候就加载
   #+BEGIN_SRC emacs-lisp
     (require 'org-install)
   #+END_SRC
   不要忘了激活Org,具体操作见下一节.
** 激活            : 如何为指定的buffer激活org模式 #<<Activition>>
   为了保证后缀为'.org'的文件会使用Org mode,在'.emacs'文件中增加下面一行
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
   #+END_SRC
   Org-mode缓冲区需要打开font-lock选项,默认情况下Emacs已经打开次选项[fn:2]. 有4个Org命令应该定义全局的快捷键(也就是说作用于在Emacs的任何地方,而不仅仅是Org缓存区),这四个org命令为'org-store-link','org-capture','org-agenda'和'org-iswitchb'. 下面是建议的绑定键设置,你可以按照自己喜欢的来修改键配置
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-cl" 'org-store-link)
     (global-set-key "\C-cc" 'org-capture)
     (global-set-key "\C-ca" 'org-agenda)
     (global-set-key "\C-cb" 'org-iswitchb)
   #+END_SRC
   
   经过上面这些配置,所有后缀为'.org'的文件在打开时会直接进入Org-mode. 如果你想不这么配置,作为替代,把下面这句放到文件的一行也可以.
   #+BEGIN_EXAMPLE
     MY PROJECTS    -*- mode: org; -*-
   #+END_EXAMPLE
   这样,不管文件名是什么,在打开时都会进去Org-mode. 参见变量'org-insert-mode-line-in-empty-file'.

   很多Org命令在选定文本块时会对文本块进行操作. 为了保证该特性被启用,你需要开启'transient-mark-mode'(在XEmacs总是'zmacs_regions'). 在Emacs23中默认是打开的,但是在Emacs22中,你需要自己打开,自己打开的命令为
   #+BEGIN_SRC emacs-lisp
     (transient-mark-mode 1)
   #+END_SRC
   
   如果你不想使用transient-mark-mode,你可以通过鼠标选择一个区域,以这种方式来建立一个选定的文本块,或者在一定光标之前安两下'C-<SPC>'
** 反馈            : BUG报告,好的想法,补丁等等
   如果你发现了Org有问题,或者你有疑问,建议和好的想法,请发邮件到Org的mailing list [[emacs-orgmode@gnu.org]]. 如果你还不是这个mailing list的会员, 那么在版主批准之后,你的mail会被加入到mailing list中[fn:3]. 

   如果你想报告BUG,请首先在最新版本的Org上复现这个BUG--如果你允许一个老旧版本的Org,很可能这个Bug已经被修复了. 如果依旧有问题,请写好报告并提供尽可能多的信息,包括Emacs的版本信息(用M-x emacs-version <RET>)和Org的版本信息(用M-x org-version <RET>),以及'.emacs'中Org的相关配置. 最简单的提交报告的方法就是执行命令'M-x org-submit-bug-report'. 这个命令会收集所有必要的信息并放到一个Emacs的mail缓存区中,这样你只需要添加你自己的描述就可以了. 如果你不会在Emacs中发送email,请拷贝这些内容并粘贴到自己常用的Email程序中.

   有时候你面对的错误可能是由于Emacs或Org-mode配置错了. 在报告BUG之前,最后以最小客户化的形式启动Emacs然后复现这个BUG. 这样做常常能够帮助你确定这个问题是因为配置的关系还是Org-mode本身有问题. 你可以用下面这个命令来开启一个最低客户化的session
   #+BEGIN_SRC sh
     emacs -Q -l /path/to/minimal-org.el
   #+END_SRC
   
   如果你使用的是Emacs中自带的Org mode,那么上面哪个最小客户化的配置就没有必要了. 你可以直接用'emacs -Q'来打开Emacs. 一个典型的'minimal-org.el'配置文件可能包含如下内容
   #+BEGIN_SRC emacs-lisp
     ;;; Minimal setup to load latest `org-mode'
     
     ;; activate debugging
     (setq debug-on-error t
           debug-on-signal nil
           debug-on-quit nil)
     
     ;; add latest org-mode to load path
     (add-to-list 'load-path (expand-file-name "/path/to/org-mode/lisp"))
     (add-to-list 'load-path (expand-file-name "/path/to/org-mode/contrib/lisp"))
     
     ;; activate org
     (require 'org-install)
   #+END_SRC
   如果有错误发生,一个错误的跟踪栈对查找问题很有帮助(下面说明了如何创建一个跟踪栈). 通常提供一个简单的造成错误的简单例子会很有帮助, 再加上以下这些信息:
   #+BEGIN_EXAMPLE
     1. 你做了什么
     2. 你希望的结果是什么
     3. 实际上的结果是什么
   #+END_EXAMPLE
   
   感谢您帮助我们改进这个程序.
*** 如何创建一个有用的跟踪栈
    如果Org报出了一个i额你不明白的出错信息,你可能发现了BUG. 报告这个BUG的最好方法是提供一个跟踪栈(backtrace). 跟踪栈使用内置的调试信息来收集一些信息,这些信息包括错误发生的地点和方式. 下面是提供一个有用跟踪栈的步骤
    1. 重新加载未编译的所有Org mode的Lisp源文件. 如果错误是在未编译的脚本中产生时,跟踪栈能够提供多得多的信息. 要做到这一步,执行
       #+BEGIN_EXAMPLE
         C-u M-x org-reload RET
       #+END_EXAMPLE
       或者在Emacs菜单上选择'Org -> Refresh/Reload -> Reload Org uncompiled'
    2. 在'Options'菜单中选择'Enter Debugger On error'(如果是使用XEmacs,需要在'Troubleshooting'子菜单中选择此项).
    3. 复现错误,别忘了记录操作的每个步骤
    4. 当错误产生了,一个名为*Backtrace*的缓存区会显示出来,保存这个缓存区到文件中(一般是用C-x C-w命令)然后附加在你的错误报告中.
** 手册中的排版约定  : 手册中的排版约定
   Org使用三种类型的关键字:TODO关键字,标签和属性名称. 在该手册中我们使用如下约定:
   #+BEGIN_EXAMPLE
   TODO
   WAITING
   #+END_EXAMPLE
   TODO关键字全部大些,即使它们可以用户随意定义的.
   
   #+BEGIN_EXAMPLE
   boss
   ARCHIVE
   #+END_EXAMPLE
   
   用户自定义的标签使用全小些;内置的标签具有特定的意义,使用全大些形式
   #+BEGIN_EXAMPLE
   Release
   PRIORITY
   #+END_EXAMPLE
   用户自定义的属性使用首字母大些;内置属性有特定意义的,使用全大些形式.
   
   该手册列出特定功能的键序列和相应的命令. Org mode经常使用相同的键序列来在不同的上下文中触发不同的功能. 绑定到这些键序列的命令都有一个通用的名称,比如'org-metaright'. 在该手册中,我们会尽可能的给出通用命令内部调用的函数名称. 例如,在文件结构的章节上按下'M-<right>'会被指明调用的是'org-do-demote'程序,而在表标题上按下相同的键序列时,我们会指明调用的是'org-table-move-column-right'.

   如果你愿意,你可以编译这份手册使之不带有命令名称,方法是在'org.texi'中取出'cmdnames'标志.
* 文档结构
  Org是基于Outline-mode的,它提供了大量的命令来编辑文档的结构.
** 大纲                  :Org是基于Outline-mode的
   Org的实现是基于Outline-mode的.Outline运行文档按照分级结构的方式来组织,这种方式(至少对于我来说)是用来展示记录和想法的最佳方式.通过折叠(隐藏)绝大部分的文档内容而只显示文档的大致结构和正在编辑的这一部分内容,一个文档结构的总览被完美地展示出来. Org极大地简化了对大纲的操作,它把整个显示/隐藏功能都通过一个命令来完成:'org-cycle',这个命令被绑定到了<TAB>键上.
** 标题                  :如何排版Org的树状标题
   标题定义了大纲树的结构. Org的标题以一个或多个星号开头,向左对齐[fn:4]. 例如:
   #+BEGIN_SRC org
     ,* Top level headline
     ,** Second level
     ,*** 3rd level
     ,    some text
     ,*** 3rd level
     ,    more text
     
     ,* Another top level headline
   #+END_SRC

   有些人觉得太多的星号眼花缭乱,它们可能更喜欢Outline-mode使用空格加星号的格式作为标题的开始标识.[[A cleaner outline view][一个更简洁的大纲显示]]中描述了如何配置.

   在子树的末尾的空行,被认为是子树的一部分,它会随着子树的折叠而被隐藏. 然而,如果你放了两个空行,那么在折叠这个子树的时候,还会有一个空行是可见的,这样做的目的常常是为了构造分割的视图. 要改变这种行为,需要配置变量'org-cycle-separator-lines'
** 可见性的转换           :显示和隐藏,很简单
   Outline使得隐藏缓存区中的一部分文本成为可能. Org仅仅使用两个命令来切换缓存区的可见性,这两个命令被绑定到了'<TAB>'和'S-<TAB>'上.
   * <TAB> (org-cycle) :: 子树循环:以下面的循环状态来切换当前子树的状态
	#+BEGIN_EXAMPLE
	,-> FOLDED -> CHILDREN -> SUBTREE --.
	'-----------------------------------'
	#+END_EXAMPLE
	为了执行子树的切换,光标位置必须在子树的标题上[fn:5]. 若光标在缓存区的最前端,而这第一行又不是标题,那么<TAB>实际上执行的是'全局循环'(具体情况见下文)[fn:6]. 同样的,如果使用的是带前缀参数的<TAB>(C-u <TAB>),调用的也是'全局循环'
   * S-<TAB> / C-u <TAB> (org-global-cycle) :: 全局循环:使整个缓存区在在不同状态间切换
	#+BEGIN_EXAMPLE
	 ,-> OVERVIEW -> CONTENTS -> SHOW ALL --.
	'--------------------------------------'
	#+END_EXAMPLE
	若再S-<TAB>前加了一个数字前缀N,那么CPMTEMTS一直到第N个层次的内容都会显示出来. 需要注意的是,若是在编辑表格中,S-<TAB>的作用是跳到上一个域.
   * C-u C-u <TAB> (show-all) :: 
	显示所有信息,包括'抽屉'内的信息
   * C-c C-r (org-reveal) :: 
	显示光标周围的上下文,也就是显示当前条目,以及所有上层标题. Useful for working near a location that has been exposed by a sparse tree command (see section Sparse trees) or an agenda command (see section Commands in the agenda buffer). With a prefix argument show, on each level, all sibling headings. With a double prefix argument, also show the entire subtree of the parent. (TODO 真没看懂什么意思,在实验C-c C-r的时候我的Org居然没反应...)
   * C-c C-k (show-branches) :: 
	展开所有子树的标题,如果只有一个子树,那么内容也显示出来.
   * C-c C-x b (org-tree-to-indirect-buffer) :: 
	把当前子树显示在indirect buffer中[fn:7]. 如果加了一个前缀参数N,它会向下进入地N层子树并在indirect buffer中显示该子树. 如果N是负数,那么就是向上进入N层的父节点. 如果命令执行前加了C-u前缀,则打开新的indirect buffer,而不会关闭之前打开的indirect buffer.
   * C-c C-x v (org-copy-visible) :: 
	拷贝文本块中的可见文本到kill ring中
	
   当Emacs第一次打开一个Org文件时,全局状态为OVERVIEW,也就是说,只有顶层的标题是可见的. 这个行为可以通过配置'org-startup-folded'变量来改变.或者可以在文件的任何地方添加下面所列出的任何一句,Emacs就会根据这句配置信息自动设置初始的状态.
   #+BEGIN_SRC org
     ,#+STARTUP: overview
     ,#+STARTUP: content
     ,#+STARTUP: showall
     ,#+STARTUP: showeverything
   #+END_SRC

   此外,任何带有'VISIBILITY'属性名的条目(参考[[#Properities and columns][属性与列]])会相应地按照该属性值来设置可见性. 该属性的有效值可以使'folded','children','cotent'和'all'
   * C-u C-u <TAB> (org-set-startup-visiblity) ::
     重置该buffer的可见性为该buffer在启动时的可见性,也就是说根据buffer的'startup'选项和各个单独条目的'VISIBILITY'属性来重新设置整个buffer的可见性.
** 移动                  :跳转到其他标题
   下面的命令跳转到buffer中的其他标题
   * C-c C-n (outline-next-visible-heading) ::
     下一个标题
   * C-c C-p (outline-previous-visible-heading) :: 
	上一个标题
   * C-c C-f (org-forward-same-level) :: 
	同一级的下一个标题
   * C-c C-b (org-backward-same-level) :: 
	同一级的上一个标题
   * C-c C-u (outline-up-heading) :: 
	回到上一级标题
   * C-c C-j (org-goto) :: 
	跳转到其他位置的同时不改变当前大纲的可见性. 在一个临时buffer中显示文档的结构,在这个临时buffer中你可以使用下面的快捷键来定位:
	#+BEGIN_EXAMPLE
	<TAB>           切换可见性
	<down> / <up>   下一个/上一个可见的标题
	<RET>           选定当前位置
	/               在树中作一个匹配查询
	如果你关掉了org-goto-auto-isearch选项,下面这些快捷键才可用
	n / p           下一个/上一个可见的标题
	f / b           同级别的上一个/下一个标题
	u               回到上一级标题
	0-9             数字参数
	q               退出这个临时buffer
	#+END_EXAMPLE
	参见变量'org-goto-interface'
** 结构编辑               :改变标题的次序和层次
   * M-<RET> (org-insert-heading) ::
     插入一个与当前位置同级别的新标题. 如果光标位于一个普通的列表项,新的列表项被创建(参见[[#Plain list][普通列表]]). 要强制创建新标题,则需要使用前缀参数. 如果在一行的中间执行这个命令,那么这一行会被分割成两行,光标到行尾的内容会成为新的标题[fn:8]. 如果实在一个标题的开头执行这个命令,那么新标题会天骄到当前行的前面. 如果是在所有行的前面执行这个命令,那么就创建了一个新的文件头. 如果是在折叠起来的子树末尾使用这个命令(也就是说,是在标题末尾的省略号之后),那么与当前标题类似的标题会被插入到这个子树的末尾.
   * C-<RET> (org-insert-heading-respect-content) :: 
	类似与M-<RET>,不同之处在于,当在当前标题后增加一个新标题时,M-<RET>会在当前标题的内容前增加一个新标题(内容成为这个新标题的内容),而C-<ERT>则在内容后增加一个新标题(内容还是原标题的内容). 这个命令在条目的任何地方都是一样的行为.
   * M-S-<RET> (org-insert-todo-heading) :: 
	插入一个与当前标题同级别的TODO事项. 参见变量'org-treat-insert-todo-heading-as-state-change'
   * C-S-<RET> (org-insert-todo-heading-respect-content) :: 
	插入一个与当前标题同级别的TODO事项, 与C-<RET>类似,新的标题会插在当前子树的后面.
   * <TAB> (org-cycle) :: 
	在一个未输入内容的标题上,第一次按<TAB>,这个标题成为了上一个标题的子标题,再按一下<TAB>,这个标题的级别变成了上一个标题的父标题,然后每按一次<TAB>级别就上升一级,一直到最高级.到了最高级再按一次<TAB>,又会回到初始的级别.
   * M-<left> (org-do-promote) :: 
	提升当前标题一级
   * M-<right> (org-do-demote) :: 
	降低当前标题一级
   * M-S-<left> (org-promote-subtree) :: 
	提升当前子树一级
   * M-S-<right> (org-demote-subtree) :: 
	降低当前子树一级
   * M-S-<down> (org-move-subtree-up) ::
        上移当前子树(与同级别的上一个子树交换位置)
   * M-S-<down> (org-move-subtree-down) ::
        下移当前子树(与同级别的下一个子树交换位置)
   * C-c C-x C-w (org-cut-subtree) :: 
	剪切当前子树,也就是说把当前子树从buffer移到kill ring中. 加一个前缀参数N,会剪切N个连续的子树.
   * C-c C-x M-w (org-copy-subtree) :: 
	把当前子树拷贝入kill ring中, 加上一个前缀参数N,会拷贝N个连续子树
   * C-c C-x C-y (org-paste-subtree) :: 
	从kill ring中粘贴子树. 该操作会自动更改被粘贴子树的级别以便它能够使用粘贴的位置. 你也可用在粘贴时就指定好级别,方法有两个,一个是在粘贴命令前加一个数字前置参数,第二种方法是在已经标示好的标题(比如'****')后粘贴子树.
   * C-y (org-yank) :: 
	根据变量'org-yank-adjusted-subtrees'和'org-yank-folded-subtrees'的值,org-yank可用很智能地用与命令C-c C-x C-y一样的方式来粘贴折叠起来的子树. 在缺省的配置中,org-yank不会调整级别,并且除非会把原先可见的文本折叠起来,否则被粘贴的子树会子的那个被折叠起来. 任何前缀参数会让这个命令强制执行一个带着前缀参数的普通的yank操作. 要强制执行普通yank的一个好方法是按下C-u C-y. 如果在yank之后,你紧接着执行yank-pop命令,就会yank当前kill-ring前一个的内容,而且不会作调整和折叠动作.
   * C-c C-x c (org-clone-subtree-with-time-shift) :: 
	拷贝一堆的同级副本. 你可以一次性拷贝多个同级副本,并且你若拷贝的条目中含有时间戳信息的化,你还可以定义时间戳信息如何变化. 这项功能十分有用,例如,当你要分配任务来准备一系列的课程时. 更多细节参见命令'org-clone-subtree-with-time-shift'的文档字符串.
   * C-c C-w (org-refile) :: 
	转存指定条目或文本块到另一个地方.参见章节[[#Refiling note][转存记录]].
   * C-c ^ (org-sort-entries-or-items) :: 
	对同级条目进行排序. 如果选择了一块文本块,所有文本块中的条目都会被排序. 否则当前标题下的子节点进行排序. 该命令会提示你选择排序的方法,可选择的方法有按字母顺序排序,按数字顺序排序,按时间排序(创建时间,规划时间,最后期限),按优先级排序,按TODO的关键字排序(需预先在配置中定义好关键字的排序顺序),按属性值排序. 你也可以采取逆排序的方式排序. 你甚至可以提供自己的函数来对其他的关键字进行排序. 如果加了C-u前缀,排序是大小写敏感的.
   * C-x n s (org-narrow-to-subtree) :: 
	缩减buffer只显示当前的子树的内容
   * C-x n s (org-narrow-to-block) ::
        缩减buffer只显示当前块的内容
   * C-x n w (widen) :: 
	回复被缩减的buffer
   * C-c * (org-toggle-heading) :: 
	该命令把正文转变为一个标题(正文在它的位置成为上一个标题的一个子标题). 也会把一个标题转变为正文. 如果选择了一个文本块,那么文本块中的所有行都变成标题. 如果该文本块中第一行是一个item(什么意思??),那么只把这个item转换为标题. 最后,如果文本块中第一行是一个i额标题,那么该文本块中所有的标题都变成正文.

   当对一个选定的文本块(Transient Mark mode)作升级/降级操作时,会影响到文本块中所有的标题.  要选择一个包含很多标题的文本块,最好是把point和mark都放在行首,mark放在第一个标题的行首,point放在要改变的最后哪个标题的下一行的行首. 需要注意的是,如果光标在表格内部(参见[[#tables][表格]]). Meta-光标键的操作有不同的作用.
        
** Sparse树              :与情景有关的匹配
   Org-mode的一个很重要的功能是它可以根据一系列的条件,将一棵大纲树中所匹配出来的一部分形成一棵sparse树,也就是说,整个文档都会尽可能的折叠起来,唯独所匹配的信息和上级标题是可见的[fn:9]. 你只要尝试以下,就立刻能够明白它是怎么工作的. 

   Org-mode有很多命令可以创建Sparse树,所有这些命令都可以通过dispatcher来触发.

   * C-c / (org-sparse-tree) ::
        它会提示你输入一个额外的快捷键来选择特定的sparse树的创建命令
   * C-r / r (org-occur) :: 
	提示输入一个正则表达式,然后显示所有匹配的sparse树. 如果有标题匹配,那么只有这个标题可见. 如果是正文匹配,那么标题和正文同时可见. 为了提供最低限度的上下文信息,所有上层标题和紧跟者匹配部分的标题都会被显示. 每个匹配的部分都被高亮; 若这是你对文档进行编辑动作,则高亮会消失[fn:10]. 同样你也可以通过C-c C-c来取消高亮. 如果执行C-u C-c / r则以前匹配的高亮会被高持,这样多次调用这个命令的结果就被保存了下来.
   * M-g n 或者 M-g M-n (next-error) :: 
	跳到当前buffer中匹配的下一个sparse树
   * M-g p 或者 M-g M-p (previous-error) :: 
	跳到当前buffer中匹配的上一个sparse树

   对于那些常用的sparse树查询,你可以在变量'org-agenda-custom-commands'中定义快捷键,直接执行这些sparse树查询. 然后就可以在agenda dispatcher中使用这些快捷键来快速查询了.例如
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-custom-commands
           '(("f" occur-tree "FIXME")))
   #+END_SRC
   会定义一个键序列为'C-c a f'的快捷方式,这个快捷方式会通过匹配字符串'FIXME'来创建sparse树.

   其他的sparse树命令(例如通过TODO关键字,标签或者属性来查找)会在手册后一点的位置提到.

   要打印出sparse树,你可以使用emacs命令'ps-print-buffer-with-faces',这个命令不会把不可见部分给打印出来[fn:11]. 或者你可以用命令'C-c C-e v'把可视化的部分导出到文档中,然后打印导出文档.
** 纯文本列表             :条目中的附加结构
   在大纲树的正文内容中,手工排列好的列表被认为是带有一定结构的. Org提供了一种方式来创建带复选框的列表(参见[[#Checkboxes][复选框]]),它提供工具来编辑这种列表,并且在导出时(参见章节[[Exporting][导出]])能够解析并且格式化这些列表.

   Org支持有序列表,无序列表和描述列表
   * 无序列表,以'-','+'或者'*'[fn:12]开头
   * 有序列表以数字开头,后接句号或者右括[fn:13](像这样'1.','1)')[fn:14]. 如果你想让列表以其他值作为初始值开始计数,需要以类似[@20]这样的文本开头[fn:15]. 这样的用法可以用在列表的任何一项上(而不需要仅仅是第一项),以强制从指定数字顺序开始.
   * 描述列表是一种无序列表,它包含'::'作为分隔符来分割术语和描述.
     
   同一个列表中的列表项必须有相同的缩进. 尤其当一个有序列表的计数达到了'10'的时候,那么这两位的计数必须与列表中的其他计数左对齐. (一个列表项可以是多行的.)当一个列表项的下一行的缩进与该列表项本身的缩进相等甚至跟少时,才表示该列表项结束了.

   当所有的列表项结束时,一个列表才被认为是结束了的,这意味在有一行的缩进等于或者小于列表第一项的缩进前,该列表都没有结束. 当然,你也可以用两个空白行[fn:16]来强制结束列表. 这种情况下,所有的列表项都被关闭了.下面是一个例子.
   #+BEGIN_SRC emacs-lisp
     ,** Lord of the Rings
        My favorite scenes are (in this order)
        1. The attack of the Rohirrim
        2. Eowyn's fight with the witch king
           + this was already my favorite scene in the book
           + I really like Miranda Otto.
        3. Peter Jackson being shot by Legolas
           - on DVD only
           He makes a really funny face when it happens.
        But in the end, no individual scenes matter but the film as a whole.
        Important actors in this film are:
        - Elijah Wood :: He plays Frodo
        - Sean Austin :: He plays Sam, Frodo's friend.  I still remember
          him very well from his role as Mikey Walsh in The Goonies.   
   #+END_SRC

   Org能正确地对这些列表进行filling和warpping调整[fn:17], 而且能够以一种恰当的方式导出这些列表(参见[[#Exporting][导出]]). 由于缩进决定了这些列表的结构,许多像#+BEGIN_...这样的block可以通过缩进来表明它们是属于哪一个列表项的一部分的.

   如果你觉得为子列表使用不同的标示(而不使用当前列表项的标示)可以增加可读性,你可以自定义变量'org-list-demote-modify-bullet'. 如果你想改变缩进程度,自定义变量'org-list-indent-offset'

   当光标处于某列表项的第一行(即带有列表项标示的那一行),可以用下面这些命令来对列表项进行操作. 其中有些命令暗含某些规则来保证列表结构是正确的. 如果你想让这些命令妨碍了你,可以通过配置'org-list-automatic-rule'来禁用其中的某些命令.
   * <TAB> (org-cycle) ::
        列表项可以像标题一样具有折叠的功能. 正常情况下,只有当光标处在plain list item上时才能进行这种折叠操作. 欲了解更多的细节,请看变量'org-cycle-include-plain-lists'. 如果该变量的值为'integrate'. plain list items会被当成是低层次的标题看待. 而*号和数字缩进层次则决定了把它当成几级标题来看待. 列表项的等级总是要低于真正的标题, 然而列表的等级制度与标题的等级制度是完全分开的. 在一个新的还未写内容的列表项上,第一次按<TAB>会把它变成上一个列表项的子项.再按一次<TAB>会上升一个层级,并且下去直到最顶列表项的层级,再按一次则返回最原始的层级位置.
   * M-<RET> (org-insert-heading) :: 
	插入新列表项到当前层级. 若在前面加了前缀参数,则强制插入的是标题(参见[[#Structure editiong][结构编辑]]). 如果在一个列表项的中间位置执行这条命令,这个列表项会被分为2部分,而第二部分则变成了一个新的列表项[fn:18]. 如果在列表项的内容前执行这个命令,则新列表项插入在当前列表项前.
   * M-S-RET :: 
	插入带复选框的列表项(见[[#Checkboxes][复选框]])
   * S-up 和 S-down :: 
	跳转到当前列表的上一个/下一个列表项上去[fn:19],不过该命令只有在'org-support-shift-select'被关闭的情况下才能用. 如果不是的话,你可以使用段落跳转命令代替,快捷键为C-<up>和C-<down>
   * M-up 或 M-down :: 
	向上或者向下移动列表项及其子项[fn:20](与上一个/下一个同缩进的列表项交换). 如果列表是有序列表,会自动重新计算序号.
   * M-S-left 和 M-S-right ::
        减少/增加列表项(联通其子项)的缩进. 在第一次开始改变缩进时Org就会记住缩进的范围,并且在以后的多次缩进中都以次范围为准进行缩进,即使在缩进过程中可能会形成新的继承体系也不管. 如果你想在新的继承体系上进行缩进,那么你可以移动以下光标或者其他方法来先中端命令链,重新开始新的缩进过程.

        作为一种特殊的情况,在列表的第一个列表项上用这个命令会移动整个列表. 你可以通过配置'org-list-automatic-rules'来禁止这种行为. 一个列表的总体缩进对列表后面的文本并无影响力(什么意思??)
   * C-c C-c :: 
	如果所在的列表项是带复选框的(参见[[#Checkboxes][复选框]]),那么就会转换复选框的状态. 在任何情况下,该命令都会校验整个列表序号和缩进的一致性.
   * C-c - :: 
        循环更改整个列表的列表项标志(对于无需列表:'-','+','*';对于有序列表:'1.','1)'),更改的具体方式依据'org-plain-list-ordered-item-terminator',列表的类型和列表项的位置来决定的[fn:21]. 如果加了一个数字前缀N,就会选择'+,*,1.,1),-'中第N个标识作为列表项的标识. 如果在调用该命令时选择了一个文本块,那么整个文本块会转换成一个列表项. 如果加了前缀参数,那么文本块中所有的行各自转换成为列表项. 如果第一行依据是一个列表项,那么文本块中所有的列表项标识都被删除. 最后,即使没有选择文本块,一个普通的文本行也会转换成列表项.
   * C-c * :: 
	把一个普通列表转换为标题(这样它就原地转换为了一个子标题). 更详细的扩展参见[[#Structure editing][结构编辑]].

   * C-c C-c * :: 
	把整个列表转换成当前标题下的子树. 带复选框的列表项(参见[[#Checkboxes][复选框]])会转换成TODO(复选框没被选上)或者DONE(复选框被选上)关键字.
   * S-left 或 S-right :: 
	当光标处于列表项的任意位置上时,这个命令也会起到循环转换列表项标志的作用. 具体怎么转换依赖于'org-support-shift-select'
   * C-c ^ :: 
	对列表进行排序. 你会被提示输入排序方法,有按数字排序,按字符排序,按时间排序或自定义方法排序.
** 抽屉                  :收缩起所有的资料
   有时候你想记录下一项事务的某些信息,但是这些信息在一般情况下是没必要显示出来的. 为了实现这个目的,Org mode提供了drawers功能. drawers需要在变量'org-drawers'[fn:22]中进行配置. Drawers看起来就像这样:
   #+BEGIN_SRC org
     ,** This is a headline
     ,   Still outside the drawer
     ,   :DRAWERNAME:
     ,   This is inside the drawer.
     ,   :END:
     ,   After the drawer.
   #+END_SRC

   无论如何在标题上切换可见性(参见[[#Visibility cycling][切换可见性]]),drawer都是收缩为一行显示的. 要看drawer内的信息,你需要移动鼠标到drawer这一行,然后按<TAB>键. Org-mode使用名为'PROPERTIES'的drawer来存放属性(参见[[#Properties and columns][属性与列]]), 你也可以把状态改变记录(参见[[Tracking TODO state changes][跟踪TODO状态变化]])和计时时间(参见[[#Clocking work time][记录工作时间]])存放在名为'LOGBOOK'的drawer中. 如果你想像状态变化信息一样把自己的一段记录也存放到名为'LOGBOOK'的这个drawer中,使用
   * C-c C-z ::
        添加一个带有时间戳信息的记录到名为'LOGBOOK'的drawer中
** 区块                  :折叠的区块
   Org-mode使用begin...end块来实现很多功能,比如引入源代码(参见[[#Literal examples][文学化例子]]),记录计时信息(参见[[#Clocking work time][记录工作时间]]). 在这些区块的第一行上按TAB键可以折叠/扩展该区块. 你也可以在设置在启动时自动折叠所有的块,方法是配置变量'org-hide-block-startup'或者在每个文件加上
   #+BEGIN_SRC org
     ,#+STARTUP: hideblocks
     ,#+STARTUP: nohideblocks
   #+END_SRC
** 注脚                  :如何用Org标签定义注脚
   Org-mode支持创建注脚. 与'footnote.el'包相反,Org-mode中的注脚功能是专门设计在大型文档来使用的,而不仅仅是用在类型email这样的一次性文件上的. org-mode中注脚的基本语法类似于'footnote.el'中的语法,即,要在段落中定义一个注脚,它需要顶格(不能有缩进)以方括号作为注脚的标记. 如果你需要在注脚内分段,使用LaTeX语法'\par'. 要定义注脚引用,只需要简单的在文本中用方括号做一个标记. 例如
   #+BEGIN_SRC org
     ,The Org homepage[fn:1] now looks a lot better than it used to.
     ,...
     ,[fn:1] The link is: http://orgmode.org
   #+END_SRC
   
   Org-mode会把'footnote.el'中基于数字的语法扩展为可以为注脚命名并且可以选择给注脚提供内部定义. 使用纯数字作为注脚标注(footnote.el就是这样作的)是为了提供向后兼容性,但是这种方式不鼓励使用,因为这种方式可能会与LaTeX snippets(参见[[#Embedded LaTeX][内嵌LaTeX]])冲突. 下面列举几种有效的注脚引用:
   * [ 1 ] ::
        一个纯数字的注脚标记. 与'footnote.el'兼容,但是不推荐使用,因为像'[ 1 ]'这样的东西,很可能是code snippet的一部分.
   * [ fn:name ] :: 
	一个带有名字的注脚引用,这里name是一个唯一的标签.如果是自动创建的注脚引用的化,则会是一个数字.
   * [ fn:: This is the inline definitiion of this footnote ] :: 
	这是一个类似LaTeX的匿名注脚,其中注脚的定义直接放在引用的位置.
   * [ fn:name:a definition ] ::
        这是一个带有名字的自定义的注脚. 由于Org-mode允许从多处引用到同一个说明,你可以使用[ fn:name ]来创建更多的引用.

   注脚标记可以被自动创建,你也可以自定义标记自动创建时的名字. 这是由变量'org-footnote-auto-label'变量和变量相应的'#+STARTUP'关键字来决定的. 欲了解详情请查看该变量的文档字符串.

   下面这些都是操作注脚的命令
   * C-c C-x f ::
     注脚行为命令

     当光标位于注脚引用处,该命令会跳转到注脚定义处. 若光标处于注脚定义处,跳转到(第一个)引用处.

     否则,创建一个新的注脚. 根据变量'org-footnote-define-inline[fn:23]'的不同,该注脚的定义可能是作为引用的一部分,会放在文本中, 也可能放在另外的其他位置,这个位置由变量'org-footnote-section'决定.

     当使用带前置参数的方式调用该命令, 会显示出一个附加选项菜单供你选择:
     #+BEGIN_EXAMPLE
       s   以引用顺序为依据对注脚的定义进行排序. 在编辑过程中,Org不会对注脚的定义进行排序操作. 如果你向对这些注脚的定义进行排序,使用这个命令,在对注脚定义进行排序的同时,也会根据'org-footnote-section'来移动整个条目. 用户可以通过配置变量'org-footnote-auto-adjust'来实现在每次插入/删除一个注脚后自动对注脚定义进行重新排序.
       r   对类型fn:N这样的以简单数字命名的注脚进行重新编号. 可以通过配置变量'org-footnote-auto-adjust'来实现每次插入/删除一个标注就自动对标注进行重新编号.
       S   先执行r操作,然后执行s操作
       n   标准化所有的标准,方法为先收集所有的标注定义(包括自定义的标注定义)并移动到一个特定的区域中,然后按顺序对这些定义进行编号. 那些标注引用随后也会转换为相应的数字. 这常常是在完成一篇文档前的最后一个步骤(例如,要发送email时). 在导出文档时,exporter会自动作这一步.或者当触发类似message-send-hook时,类似的动作也会自动触发.
       d   删除当前位置的标注,连同所有的标注定义和标注引用
     #+END_EXAMPLE

     根据变量'org-footnote-auto-adjust[fn:24]'的值,可以设定每插入或删除一个注脚后,自动重编码和排序文档中的所有注脚.

   * C-c C-c :: 
	当光标位于注脚引用处时,跳转到注脚定义处. 若光标处于注脚定义处,则跳转回注脚引用处. 若在标注位置上用带前置参数的方式调用该命令,则弹出一个与C-c C-x f一样的菜单.

   * C-c C-o 或 鼠标左键 或鼠标右键 :: 
	注脚标签也是注脚定义与注脚引用相互之间的一种链接,你可以使用跳转链接的一般命令来在注脚定义/引用间相互跳转.
** Orgstruct的minior模式 :在Org之外进行结构编辑
   如果你喜欢Org-mode编辑结构和格式化列表时的这种直接了当的感受,你可能希望在其他mode下(比如Text-mode或者mail-mode)也能使用这些命令. 这时你可以使用名为'orgstruct-mode'的minor mode. 使用'M-x orgstruct-mode'来切换mode. 如果你想在默认情况下启用'orgstruct-mode',例如设置在Message-mode下默认启用该mode,可以在配置文件中添加下面中的任一句
   #+BEGIN_SRC emacs-lisp
     (add-hook 'message-mode-hook 'turn-on-orgstruct)
     (add-hook 'message-mode-hook 'turn-on-orgstruct++)
   #+END_SRC

   'orgstruct-mode'被激活后,当光标在一行(对org来说)看起来像是标题或列表项的第一行的文本行上时,大多数的结构编辑命令都可以被使用,即使在major mode原本定义的功能键跟'orgstruct-mode'提供的功能键有冲突时,也一样. 如果光标所在行看起来不是那种特殊的行,Orgstruct mode不会有任何作用,就跟没有开启Orgstruct mode一样. 若你使用的是'orgstruct++-mode',Org也会在major mode中引入缩进和填充设置,并且会探测列表项第一行后面的列表项内容.
* 表格
  Org自带一个快速而且直观的表格编辑器. 借助Emacs的'calc'包(参见<Gnu Emacs calculator manual>中的'Top'部分)甚至可以具备类似电子表格的计算能力.
** 内置的表格编辑器        :编辑简单的表格
   Org可以很容易的使用纯文本来格式化表格. 任何以'|'为非空白字符开头的行都被认为是表格的一部分. '|'也是列的分隔符[fn:25].一个表格看起来类似于这样:
   #+BEGIN_SRC org
     ,| Name  | Phone | Age |
     ,|-------+-------+-----|
     ,| Peter |  1234 |  17 |
     ,| Anna  |  4321 |  25 |     
   #+END_SRC
   
   每次在表格内按<TAB>,<RET>或'C-c C-c'都会自动对表格进行重排. <TAB>也使光标移动到下一个域(<RET>使光标移动到下一行)并且会在表格的最后一行或者在水平线之前的位置上添加一行新行.表格的缩进是由第一行来决定的. 任何以'|-'开头的行都被认为是水平分割行,并且在下一次表格重排时会扩展到整个表格的长度. 所有要创建上面的表格,你只需要键入
   #+BEGIN_SRC org
     ,|Name|Phone|Age|
     ,|-    
   #+END_SRC
   然后按下<TAB>来对齐表格并且开始在表格域内进行填充操作. 更快的操作是输入"|Name|Phone|Age"然后紧接着输入'C-c <RET>'.

   当在表格域内输入文本时,Org以一种特殊的方法来处理<DEL>,<Backspace>,和所有的字符键,这种方法保证了插入和删除操作可以避免对其他域产生影响. 另外,如果是在光标通过<TAB>,S-<TAB>或<RET>的方式移动到新表格域后立即输入,那么新表格域中的文本会被自动清空. 如果这种行为对你产生了困扰,可以配置变量'org-enable-table-editor'和'org-table-auto-blank-field'来取消这种行为.

   * 创建和转换命令
     * C-c | (org-table-create-or-convert-from-region) ::
          转换选定域为表格. 如果每个行都包含了至少一个TAB键,那么该函数假设选定域的值是以tab键作为分隔符的. 如果每一行都包含了一个逗号,那么选中域被假设为是CSV文件内容. 如果即没有TAB,也没有逗号,那么就认为选中域是以空格为分隔符的. 你可以使用前置参数来告诉函数使用哪种分隔符:C-u使用CSV格式,C-u C-u使用TAB为分隔符,前置参数N标示至少N个连续的空格或TAB键作为分隔符.

          如果没有选定域,这个命令会创建一个空的Org表格. 至少它比输入"|Name|Phone|Age<REt>|-<TAB>"这样来的简单.
   * 重对齐和表格域之间的移动
     * C-c C-c (org-table-align) ::
          对表格进行重对齐操作但不移动光标的位置
     * <TAB> (org-table-next-field) :: 
	  重对齐操作,光标移动到下一个域中. 如果需要的话创建一个新行.
     * S-<TAB> (org-table-previous-field) :: 
	  重对齐操作,光标移动到上一个域中.
     * <ERT> (org-table-next-row) :: 
	  重对齐表格,并且光标移到下一行. 如果需要的话会新键一行. 若光标在一行的开头或末尾,<ERT>也会新建一行,因此该功能可以用来分割表格.
     * M-a (org-table-beginning-of-field) :: 
	  移动到光标当前域的开头位置,或者(若已经在当前域的开头位置)上一个域的开头位置
     * M-e (org-table-end-of-field) :: 
	  移动到光标当前域的结尾位置,或者(若已经在当前域的结尾位置)下一个域的结尾位置
   * 列和行的编辑
     * M-<left> (org-table-move-column-left) ::
          移动当前列到左方(与左列交换位置)
     * M-<right> (org-table-move-column-right) ::
          移动当前列到右方(与右列交换位置)
     * M-<up> (org-table-move-row-up) :: 
	  移动当前行到上方(与上行交换位置)
     * M-<down> (org-table-move-row-down) :: 
	  移动当前行到下方(与下行交换位置)
     * M-S-<up> (org-table-kill-row) :: 
	  删除当前行或水平分隔行
     * M-S-<down> (org-table-insert-row) :: 
	  在当前行上面插入一新行. 如果加上前置参数,就在当前行下方插入新行.
     * C-c - (org-table-insert-hline) :: 
	  在当前行下面插入一新水平分隔行. 如果加上前置参数,就在当前行上方插入新水平分隔行.
     * C-c <RET> (org-table-hline-and-move) :: 
	  在当前行下方插入一水平分隔行,并且移动光标到该分隔行的下一行
     * C-c ^ (org-table-sort-lines) :: 
	  对当前块的表格行进行重新排序. 光标的位置指明根据哪一列来排序, 排序的范围就是上下两个最近的水平分隔行之间所包含的行,或者是整个表格. 如果光标处于第一列的前面,你会被提示需要输入按照哪一列来进行排序. 如果存在一个被选定的块,那么文本块的标记位置就指定了要排序的起始行,并且根据标记所在的列来进行排序,而光标所在的列(包括该列)为要排序的结束行. 该命令会提示您输入排序的类型(按字母排序,按数字排序或这按时间排序). 当该命令带有前置参数的时候,按字母排序是大小写敏感的.
   * 区域
     * C-c C-x M-w (org-table-copy-region) ::
          从表格中拷贝一个矩形区域到粘贴板. 光标所在的位置和标记的位置决定了矩阵的边界. 如果没有选定的区域,就把整个当前域拷贝到粘贴板中. 该操作会忽略水平分隔行.

     * C-c C-x C-w (org-table-cut-region) :: 
	  拷贝表格中的矩形区域的内容到剪贴板,并且对该矩形其余进行填空操作.因此这其实是个剪切操作

     * C-c C-x C-y (org-table-paste-rectangle) :: 
	  粘贴矩形区域内容到表格中. 该区域的左上角放置在当前域. 所有涉及到的域都会被覆盖掉. 如果矩阵不能合适地放到当前表格中,那么当前表会根据需要扩大. 该操作会忽略水平分隔行的存在.

     * M-<RET> (org-table-wrap-region) :: 
	  以光标位置为界限分割当前域,并且把剩下的部分移动到下一行. 如果存在已选定的文本块,并且光标和标记处于同一个列中,the text in the column is wrapped to minimum width for the given number of lines. 如果存在一个数字的前置参数,那么该参数会用来指定操作的行数. 如果没有选定的区域,而你又指定了前置参数,当前域会被清空,并且原先的内容会粘贴在当前域的上个域的内容后面.
   * 计算
     * C-c + (org-table-sum) ::
          把当前列(或选定区域)的数字求总和.求和的结果会在echo区域显示,并且可以用C-y命令插入结果

     * S-<RET> (org-table-copy-down) ::
          若当前域是空的,就会拷贝上方的第一个非空域的值. 如果当前域不是空的,则拷贝当前域的值覆盖下一行的值,并且鼠标也跟着下移. 根据变量'org-table-copy-increment'的设置,若域中的值是整数,则拷贝时会自增. 若域中的整数值太过巨大了,则该值不会被增加. 另外,若前置参数为0,则会暂时地禁止这种增加行为. 该键序列在shift-selection和相关模式中也有定义,因此可能会有冲突(参见[[#Packages that lead to conflicts with org mode][与org-mode冲突的包]])
   * 杂项
     * C-c ` (org-table-edit-field) ::
          在另一个窗口中编辑当前域. 这在编辑显示不下内容的域时非常有用(参见[[#Column width and alignment][列宽度与对齐]]). 当添加了C-u前缀时,仅仅只是把当前域的内容全部显示出来,这样就能在本地编辑该域了. 如果加了两个C-u前缀则会保持一个编辑窗口,该窗口的内容随着光标的所在域不同而动态改变. 这种模式会一直持续到光标离开表格,或者你重复输入该命令'C-u C-u C-c `'

     * M-x org-table-import :: 
	  把一个文件当作表格导入进来. 文件内容必须是以TAB或空格分隔的(通常从电子表格或数据库中导出的数据是可以定义为以TAB分隔的文本文件的). 该命令先插入文件内容到缓冲区内然后调用转换命令(org-table-create-or-convert-from-region)将内容为一个表格. 任何前缀参数都会被传递给转换命令作为决定分隔符的参数.

     * C-c | (org-table-create-or-convert-from-region) :: 
	  也可以通过粘贴以tab分隔的文本到Org缓冲区的方式来导入表格.方法是,先用C-x C-x选择(也可以用其他方法)要粘贴的文本,然后使用'C-c |'命令

     * M-x org-tableexport :: 
	  导出表格,默认是以TAB作为分隔符. 常常用来与电子表格或数据库程序作数据交换. 导出文件的格式可以在变量'org-table-export-default-format'中配置. 你也可以在子树中用属性'TABLE_EXPORT_FILE'来定义导出文件的名字和属性'TABLE_EXPORt_FORMAT'来定义导出文件的格式. Org支持将表格导出为许多格式. 导出的格式与Orgtbl radio表格的格式是一样的. 详细描述请参见'[[#Translator functions][转换功能]]'.

     如果你不喜欢Org的表格功能(因为你可能象要有记录一些以|开头的行,而不作为表格),你可以用下面的配置语句关掉该功能
     #+BEGIN_SRC emacs-lisp
       (setq org-enable-table-editor nil)
     #+END_SRC
     这样一来,唯一可用的表格命令就是C-c C-c,该命令用来作人工的重对齐

** 列的宽度与对齐          :不使用自动化的设置
   列的宽度是有表格编辑器自动决定的. 列的对齐方式也是由列中的值的类型来自动决定的,若值类似于数字则默认右对齐,否则默认为左对齐.

   有时候,一个或多个域会由于包含了太多的文本而导致列的宽度看起来很不方便. 又或者你想象让多个列不管内容多少都保持固定的宽度. 要设置[fn:26]列的宽度, 在列的任何一个域中包含类似'<N>'这样的字符串即可. 这里N的意思代表了该列的宽度限定为N个字符长度. 下一次重排时,该列的宽度会调整为这个值.例如
   #+begin_example
     |---+------------------------------|               |---+--------|
     |   |                              |               |   | <6>    |
     | 1 | one                          |               | 1 | one    |
     | 2 | two                          |     ----\     | 2 | two    |
     | 3 | This is a long chunk of text |     ----/     | 3 | This=> |
     | 4 | four                         |               | 4 | four   |
     |---+------------------------------|               |---+--------|
   #+end_example

   太长的域会被裁减并且以字符串'=>'结尾. 注意,此时完成的字符串还保留在缓冲区内,只不过被隐藏起来罢了. 要查看完整的文本,只需要把鼠标移到要查看的域上过一会儿,会有一个小提示窗口弹出来,里面有完整的内容. 要编辑这个域,使用命令C-c `(C-c 接着反引号). 该编辑命令会打开一个新窗口给你编辑,里面是完整的内容.输入C-c C-c完成编辑

   打开一个文件时,若文件中存在缩小的列的表格,此时列中的文本不会自动进行隐藏动作.这时候的表格看起来不太好看,需要重排. 设置选项'org-startup-align-all-tables'会使org在打开文件时自动重排其中的所有表格,当然这个动作也会降低org启动的速度. 你也可以在每个文件中设置这个属性,方法为:
   #+begin_src org
     ,#+STARTUP: align
     ,#+STARTUP: noalign
   #+end_src

   默认清空下富含数字的列是右对齐的,富含字符串的列是左对齐的,但你也可以自定义列的对齐方式,方法为在列中使用类似'<r>','c'[fn:27],或'<l>'这样的字符串来定义该列的对齐方式. 当然你也可以同时定义列对齐方式和列的宽度,例如'<r10>'.

   当导出文档时,只包含指定格式的字符串的行会自动移除不被导出.
** 对列进行分组            :Grouping to trigger vertical lines
   当Org导出表格时,默认是不导出表格中的竖线的,因为通常来说这不美观. 然而有时候竖线可用用来把表格划分为几个列的组(类似于水平分隔行把行划分为几个组别). 要定义列的组别,你可以使用一种特殊的行,在这一行里,第一个域只包含'/'. 接下来的域中可用包含'<'(表格这一列是一个组别的起始列),或者'>'(指示这一列是组别的结束列),或者'<>'('<'和'>'中间没有空格,这表示这一列自成一组). 组别之间的边界在导出时会用竖线标示出来.如下例子所示
   #+begin_src org
     ,| N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
     ,|---+-----+-----+-----+---------+------------|
     ,| / |   < |     |   > |       < |          > |
     ,| 1 |   1 |   1 |   1 |       1 |          1 |
     ,| 2 |   4 |   8 |  16 |  1.4142 |     1.1892 |
     ,| 3 |   9 |  27 |  81 |  1.7321 |     1.3161 |
     ,|---+-----+-----+-----+---------+------------|
     ,#+TBLFM: $2=$1^2::$3=$1^3::$4=$1^4::$5=sqrt($1)::$6=sqrt(sqrt(($1)))
   #+end_src
   
   你也可以只是在想要竖线的地方插入列组的起始符号即可.例如
   #+begin_src org
     ,|  N | N^2 | N^3 | N^4 | sqrt(n) | sqrt[4](N) |
     ,|----+-----+-----+-----+---------+------------|
     ,| /  | <   |     |     | <       |            |
   #+end_src
** 名为Orgtbl的minor mode :使用minor-mode中的表格编辑器
** 电子表格               :带有电子表格功能的表格编辑器
** Org-Plot              :org表格绘图
* Footnotes

[fn:1] install-info的输出也是系统依赖的. 在特定的Debian及其衍生系统中使用两种不同版本的install-info程序.如果你看到
  #+BEGIN_EXAMPLE
    This is not dpkg install-info anymore, but GNU install-info
    See the man page for ginstall-info for command line arguments  
  #+END_EXAMPLE
  只管忽略它就好.

[fn:2] 如果你不想在全局范围使用font-lock,你可以用下面一句配置来只在Org-mode下打开font-lock选项
  #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook 'turn-on-font-lock) 
  #+END_SRC

[fn:3] 请考虑订阅邮件列表，以减少工作邮件列表版主的工作量。

[fn:4] 要配置C-a,C-e和标题环境中C-k的行为,参见参数'org-special-ctrl-a/e', 'org-special-ctrl-k和'org-ctrl-k-protect-subtree'

[fn:5] 参见org-cycle-emulate-tab选项

[fn:6] 参见org-cycle-global-at-bob选项

[fn:7] indirect buffer(关于indirect buffer的更多信息请查看Emacs手册)仅仅包含了原buffer中当前树的内容. 编辑这个indirect buffer也会修改原buffer,但是对原buffer的可见性不会有影响

[fn:8] 如果你不想一行内容被分割,你需要定制变量'org-M-RET-may-split-line'

[fn:9] 参见变量'org-show-hierarchy-above','org-show-following-heading','org-show-siblings'和'org-show-entry-below',这些参数详细定义了每次匹配多少内容

[fn:10] 这种行为依赖于'org-remove-highlights-with-change'选项

[fn:11] 这种方法在Xemacs中是行不通的,because XEmacs uses selective display for outlining, not text properties. 

[fn:12] 当使用*作为列表项的标志时,这一行必须是有缩进的,否则它们会被认为是顶层的标题. 同样的道理,如果你为了得到一个干净的大纲视图而隐藏了前面的星星,那么以*开头的列表项和真正的标题之间会很难区分. 总之,即使支持'*'作为列表项标志,但最好还是不要用它.

[fn:13] 你可以通过配置'org-plain-list-ordered-item-terminator'来过滤掉它们中的任何一个.

[fn:14] 通过配置'org-alphabetical-lists',你也可以用类似'a.','A.','a)','A)'作为列表项的标志. 为了最小化与普通文档的混淆,只准使用单个字符作为标志. 超过这个限制,列表项标志会自动变回数字.

[fn:15] 如果列表项中包含有复选框,那么这种标志必须放在复选框的前面. 如果你激活了字母列表,你也可以使用类似[@b]这样的形式.

[fn:16] 参见'org-empty-line-terminates-plain-lists'

[fn:17] Org只会改变Emacs的filling设置,对于XEmacs,你应该是i用Kyle E.Jones的'filladapt.el'.为了启用这个包,在'.emacs'中添加'(require 'filladapt)'

[fn:18] 如果你不想分割列表项,自定义变量'org-M-RET-may-split-line'

[fn:19] 如果你想用这种方式遍历列表项,你可能需要自定义'org-list-use-circular-motion'

[fn:20] 循环行为参见'org-liste-use-circular-motion'

[fn:21] 欲了解列表项标志的更多规则,参见'org-list-automatic-rules'

[fn:22] 你可以在每个文件中定义drawers,方法为添加一行类似'#DRAWERS: HIDDEN PROPERTIES STATE'这样的一行.

[fn:23] 相应的in-buffer设置为: '#+STARTUP: fninline'或者'#+STARTUP nofninline'

[fn:24] 相应的in-buffer设置为: 'fnadjust' 和 'nofnadjust'.

[fn:25] 要插入一个竖线到表格域中,使用\ vert(去掉空格)代替,若要插入竖线到单词中,则用\ vert{}(去掉空格)代替,例如abc\vert{}def.

[fn:26] 这个特征在XEmacs上无效

[fn:27] 诚然它在Emacs中是无效的,但是它在导出为HTML使却有效.


