<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Cpp<sub>Cookbook</sub></title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Cpp<sub>Cookbook</sub>"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-07-22T16:17+0800"/>
<meta name="author" content="DarkSun"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Cpp<sub>Cookbook</sub></h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 代码结构</a>
<ul>
<li><a href="#sec-1-1">1.1 使用向前类声明来减少#include的使用</a></li>
<li><a href="#sec-1-2">1.2 命名空间</a></li>
</ul>
</li>
<li><a href="#sec-2">2 数值计算</a>
<ul>
<li><a href="#sec-2-1">2.1 字符串转换成数值</a></li>
<li><a href="#sec-2-2">2.2 获取某种数值类型的最大和最小值</a></li>
</ul>
</li>
<li><a href="#sec-3">3 字符串操作</a>
<ul>
<li><a href="#sec-3-1">3.1 如何反转字符串</a></li>
<li><a href="#sec-3-2">3.2 从字符串中删除子字符串</a></li>
<li><a href="#sec-3-3">3.3 大小写不敏感的字符串比较</a></li>
<li><a href="#sec-3-4">3.4 如何在忽略大小写的情况下从一个字符串中查找一个子串</a></li>
<li><a href="#sec-3-5">3.5 字符测试函数</a></li>
<li><a href="#sec-3-6">3.6 getline函数</a></li>
<li><a href="#sec-3-7">3.7 如何使你的文本右对齐或左对齐</a></li>
<li><a href="#sec-3-8">3.8 如何把文件中连续的多个空格缩减为1个.</a></li>
</ul>
</li>
<li><a href="#sec-4">4 日期与时间</a>
<ul>
<li><a href="#sec-4-1">4.1 localtime，gmtime和asctime函数都返回一个指向静态分配的对象的指针</a></li>
<li><a href="#sec-4-2">4.2 如何将日期/时间格式化为一个字符串</a></li>
</ul>
</li>
<li><a href="#sec-5">5 容器</a>
<ul>
<li><a href="#sec-5-1">5.1 如何使用一个由逗号分割开的数列来初始化一个容器</a></li>
</ul>
</li>
<li><a href="#sec-6">6 算法</a>
<ul>
<li><a href="#sec-6-1">6.1 如何随机打乱数据</a></li>
<li><a href="#sec-6-2">6.2 如何在序列上进行集合运算</a></li>
<li><a href="#sec-6-3">6.3 如何将一个范围的元素输出到数据流中</a></li>
<li><a href="#sec-6-4">6.4 如何快速读取一系列数据存入容器中</a></li>
</ul>
</li>
<li><a href="#sec-7">7 类</a>
<ul>
<li><a href="#sec-7-1">7.1 类成员变量,需要在独立的源文件中初始化它,而不是在它所声明的头文件中.</a></li>
<li><a href="#sec-7-2">7.2 若在基类中提供了虚的析构函数,则你需要给它一个实现,这是因为子类的析构函数需要自动调用基类的析构函数</a></li>
<li><a href="#sec-7-3">7.3 如何调用超类中的虚函数</a></li>
</ul>
</li>
<li><a href="#sec-8">8 异常安全</a>
<ul>
<li><a href="#sec-8-1">8.1 保证初始化列表的异常安全</a></li>
<li><a href="#sec-8-2">8.2 如何使类具有强异常安全保证</a></li>
</ul>
</li>
<li><a href="#sec-9">9 流</a>
<ul>
<li><a href="#sec-9-1">9.1 如何实现自己的流操作符</a></li>
<li><a href="#sec-9-2">9.2 如何删除/重命名文件</a></li>
<li><a href="#sec-9-3">9.3 如何创建一个临时文件名和文件</a></li>
</ul>
</li>
<li><a href="#sec-10">10 数字</a>
<ul>
<li><a href="#sec-10-1">10.1 查找最大/最小值</a></li>
<li><a href="#sec-10-2">10.2 计算总和与平均值</a></li>
<li><a href="#sec-10-3">10.3 过滤掉给定范围之外的值</a></li>
<li><a href="#sec-10-4">10.4 生成随机数</a></li>
</ul>
</li>
<li><a href="#sec-11">11 国际化问题</a>
<ul>
<li><a href="#sec-11-1">11.1 硬编码Unicode字符串</a></li>
<li><a href="#sec-11-2">11.2 如何以遵循本地格式的方法读取/写入一个数字到流</a></li>
<li><a href="#sec-11-3">11.3 如何用本地的格式习惯来显示/读取时间和日期</a></li>
<li><a href="#sec-11-4">11.4 如何读取/写入符合本地格式的货币值</a></li>
<li><a href="#sec-11-5">11.5 如何对本地化字符串进行排序</a></li>
</ul>
</li>
<li><a href="#sec-12">12 指针</a>
<ul>
<li><a href="#sec-12-1">12.1 如何引用数据成员或成员函数的地址</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 代码结构</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 使用向前类声明来减少#include的使用</h3>
<div class="outline-text-3" id="text-1-1">


<p>
   当不关心引用类的细节时,可以使用向前类声明的方式来减少编译依赖.
</p>
<p>
   所谓不关心类A的细节,意味着不能使用类A的成员变量和方法,类A不能声明为其他类的成员变量,因为需要知道A的大小.
</p>
<p>
   但由于指针和引用具有固定大小,因此可以使用
</p></div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 命名空间</h3>
<div class="outline-text-3" id="text-1-2">

<ul>
<li>命名空间可以嵌套
</li>
<li>命名空间别名



<pre class="example">using 别名 = 全称;
别名::类 对象;
</pre>

</li>
<li>命名空间中的自动查找功能

<p>
     当你传入一个属于某个命名空间的函数参数时,在这个函数体内部执行这个函数的名字查找功能时,编译器会包含这个命名空间
</p>


<pre class="example">void f(dev::Device&amp; d){
        register(d);            // 这里的register实际可能是dev::register
}
</pre>

</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 数值计算</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 字符串转换成数值</h3>
<div class="outline-text-3" id="text-2-1">

<p>   还在使用C库中的atof和atoi吗?快来试试&lt;cstdlib&gt;中的strtol,strtod和strtoul吧,它们分别可以转换为long int,double,和unsigned long型,而且支持任意进制的字符串.
</p>
<p>
   这些函数还有对应的款字符函数,分别是wstrtol,wstrtod和wstrtoul
</p>
<p>
   也可以使用stringstream的operator&gt;&gt;方法来实现类型的转换,使用这种方法甚至能够解析含有科学计数法表示的数值
</p></div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 获取某种数值类型的最大和最小值</h3>
<div class="outline-text-3" id="text-2-2">

<p>   使用&lt;limits&gt;中的numeric_limits类模板中的max()/min()方法就可以知道某个数值类型所能表示的最大和最小值
</p></div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 字符串操作</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 如何反转字符串</h3>
<div class="outline-text-3" id="text-3-1">

<p>   字符串可以看成是字符的容器,还记得&lt;algorithm&gt;中的reverse函数模板么?那么,答案就是:
</p>


<pre class="example">std::reverse(s.begin(),s.end());
</pre>


<p>   
   若要翻转的复制一个字符串,则可以使用翻转迭代器
</p>


<pre class="example">std::string rs;
rs.assign(s.rbegin(),s.rend());
</pre>

</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 从字符串中删除子字符串</h3>
<div class="outline-text-3" id="text-3-2">

<p>   使用find查找到子字符串的位置,在用erase函数删除
</p></div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 大小写不敏感的字符串比较</h3>
<div class="outline-text-3" id="text-3-3">

<p>   使用equal模板函数来比较两个字符串,并提供自己的字符比较函数,在字符的比较函数中使用toupper函数/tolower函数(&lt;cctype&gt;)
</p>
<p>
   但光这样做还不行,还需要比较它们的长度. 因为equal函数只比较前n个元素.
</p></div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 如何在忽略大小写的情况下从一个字符串中查找一个子串</h3>
<div class="outline-text-3" id="text-3-4">

<p>   使用search算法+toupper函数就能实现.
</p>


<pre class="example">bool caseIngoreCharComp(char a,char b)
{
    return (toupper(a) == toupper(b));
}

string::size_type caseIgnoreFind(const string&amp; s,const string&amp; p)
{
    string::const_iterator pos = search(s.begin(),s.end(),p.begin(),p.end(),caseIngoreCharComp);
    if(pos == s.end())
    {
        return string::npos;
    }
    return pos - s.begin();
}

</pre>

</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 字符测试函数</h3>
<div class="outline-text-3" id="text-3-5">

<p>   在&lt;cctype&gt;中定义了大量的字符测试函数
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">单字符版函数</th><th scope="col" class="left">宽字符版函数</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">isalpha</td><td class="left">iswalpha</td><td class="left">希腊字母</td></tr>
<tr><td class="left">isupper</td><td class="left">iswupper</td><td class="left">大写希腊字母</td></tr>
<tr><td class="left">islower</td><td class="left">iswlower</td><td class="left">小些希腊字母</td></tr>
<tr><td class="left">isdigit</td><td class="left">iswdigit</td><td class="left">数字</td></tr>
<tr><td class="left">isxdigit</td><td class="left">iswxdigit</td><td class="left">十六进制数字</td></tr>
<tr><td class="left">isspace</td><td class="left">iswspace</td><td class="left">空白符</td></tr>
<tr><td class="left">iscntrl</td><td class="left">iswcntrl</td><td class="left">控制符</td></tr>
<tr><td class="left">ispunct</td><td class="left">iswpunct</td><td class="left">不属于以上各组的标点符号</td></tr>
<tr><td class="left">isalnum</td><td class="left">iswalnum</td><td class="left">希腊字符或数字</td></tr>
<tr><td class="left">isprint</td><td class="left">iswprint</td><td class="left">可打印的ASCII字符</td></tr>
<tr><td class="left">isgraph</td><td class="left">iswgraph</td><td class="left">希腊字符或数字或标点符号</td></tr>
</tbody>
</table>

</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> getline函数</h3>
<div class="outline-text-3" id="text-3-6">

<p>   &lt;string&gt;中提供了getline函数模板,使用它能够一次读取一行文本到某个string变量中,或者更精确的,可以把文本读取直到碰到一个特定的定界符.
</p>


<pre class="example">basic_istream&lt;char&gt;&amp; getline(basic_istream&lt;char&gt; cin,basic_string&lt;char&gt;&amp; str,char _delim='\n');
</pre>


<p>
   &lt;basic_istream&gt;中有个同名的函数,但它把输出存在一个字符缓存中而不是字符串中.
</p></div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> 如何使你的文本右对齐或左对齐</h3>
<div class="outline-text-3" id="text-3-7">

<p>   最简单的方法就是使用流和标准流中的格式标志右和左. 
</p>


<pre class="example">ofstream out(file);
ios_base::fmtflags flgs = out.setf(ios_base::right); // 当用完设置的格式标志时,你应该做的就是清掉它们.
out.width(72);
out&lt;&lt;line&lt;&lt;endl;                
out.flags(flgs);                // 还原原格式,flags函数和setf的不同在于flags是替代原标志,而setf是打开某个标志
</pre>

</div>

</div>

<div id="outline-container-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> 如何把文件中连续的多个空格缩减为1个.</h3>
<div class="outline-text-3" id="text-3-8">

<p>   最简单的方法就是使用&lt;string&gt;中的操作符&gt;&gt;函数模板,从一个流中把一块连续的非空白字符读入到一个字符串中,然后使用"&lt;&lt;"操作符,把文本写入到输出流中,并在每块的末尾追加一个空格.
</p>


<pre class="example">ifstream ifs;
ofstream ofs;

string tmp;
ifs &gt;&gt; tmp;
ofs &lt;&lt; tmp;
while(ifs &gt;&gt; tmp)
{
        ofs&lt;&lt;' '&lt;&lt;tmp;
}
</pre>

</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 日期与时间</h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> localtime，gmtime和asctime函数都返回一个指向静态分配的对象的指针</h3>
<div class="outline-text-3" id="text-4-1">

<p>   这意味着随后的调用将改变这些对象的值，且这些函数不能用在多线程环境中。
</p>



<pre class="example">char* x = asctime(localtime(time(NULL)));
sleep(15);
sactime(localtime(time(NULL)));
cout&lt;&lt;x&lt;&lt;endl;                  // 这里显示的是当前的时间而不是15s之前的时间
</pre>


<p>
   若要将这些函数用在多线程的环境下，则需要使用localtime_r,gmtime_r,asctime_r来代替。
</p></div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 如何将日期/时间格式化为一个字符串</h3>
<div class="outline-text-3" id="text-4-2">

<p>   除了可以使用C语言&lt;time.h&gt;中的strftime函数外,还可以使用&lt;locale&gt;中的time_put模板类.
</p>


<pre class="example">ostream&amp; formatDateTime(ostream&amp; out,const tm&amp; t, const char* fmt)
{
        const time_put&lt;char&gt;&amp; dateWriter = use_facet&lt;time_put&lt;char&gt; &gt;(out.getloc());
        int n = strlen(fmt);
        if(dateWriter.put(out,out,' ',&amp;t,fmt,fmt+n,).failed())
        {
                throw runtime_error("failure to format date time");
        }
        return out;
}
</pre>

<p>
   time_put成员函数与C语言的printf函数一样使用一个字符串来指定输出的格式. 
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>日期/时间格式的指定符</caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">格式指定符</th><th scope="col" class="left">描述</th></tr>
</thead>
<tbody>
<tr><td class="left">a</td><td class="left">星期的缩写(Mon)</td></tr>
<tr><td class="left">A</td><td class="left">星期的完整名(Monday)</td></tr>
<tr><td class="left">b</td><td class="left">月份的缩写(Dec)</td></tr>
<tr><td class="left">B</td><td class="left">月份的完整名(May)</td></tr>
<tr><td class="left">c</td><td class="left">完全的日期和时间</td></tr>
<tr><td class="left">d</td><td class="left">月份中的天数(01~31)</td></tr>
<tr><td class="left">H</td><td class="left">24小时制中的小时数(00-23)</td></tr>
<tr><td class="left">I</td><td class="left">12小时制的小时数(01-12)</td></tr>
<tr><td class="left">j</td><td class="left">一年中的天数(01~366)</td></tr>
<tr><td class="left">m</td><td class="left">月份数(01~12)</td></tr>
<tr><td class="left">M</td><td class="left">分钟数(00~59)</td></tr>
<tr><td class="left">p</td><td class="left">(上午/下午)的标识(AM/PM)</td></tr>
<tr><td class="left">S</td><td class="left">秒数,包括最多两个润秒</td></tr>
<tr><td class="left">U</td><td class="left">周数(00~53),第一周从第一个星期天开始</td></tr>
<tr><td class="left">w</td><td class="left">每周中的天数(0~6),星期天为0</td></tr>
<tr><td class="left">W</td><td class="left">周数(00~53),第一周从第一个星期一开始</td></tr>
<tr><td class="left">x</td><td class="left">采用MM/DD/YY格式的日期</td></tr>
<tr><td class="left">X</td><td class="left">24小时制中HH/MM/SS格式的时间</td></tr>
<tr><td class="left">y</td><td class="left">当前世纪中的年数(00-99)</td></tr>
<tr><td class="left">Y</td><td class="left">年</td></tr>
<tr><td class="left">Z</td><td class="left">时区的缩写,如果系统不知道时区的话,就是空</td></tr>
</tbody>
</table>

</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 容器</h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 如何使用一个由逗号分割开的数列来初始化一个容器</h3>
<div class="outline-text-3" id="text-5-1">

<p>   通过定义一个帮助类并重载逗号操作符,就可以在这些标准的容器中使用逗号初始化语法了.
</p>


<pre class="example">template&lt;class Seq_T&gt;
class comma_helper
{
public:
    typedef typename Seq_T::value_type value_type;
    explicit comma_helper(Seq_T&amp; x) :m(x){
    }
    comma_helper&amp; operator=(const value_type&amp; x){
        m.clear();
        m.push_back(x);
        return *this;
    }
    comma_helper&amp; operator+=(const value_type&amp; x){
        m.push_back(x);
        return *this;
    }

    template&lt;class Scalar_T&gt;
    comma_helper&amp; operator,(Scalar_T x){
        return operator+=(x);
    }
private:
    Seq_T&amp; m;
};

template&lt;typename Seq_T&gt;
comma_helper&lt;Seq_T&gt; initialize(Seq_T&amp; x)
{
    return comma_helper&lt;Seq_T&gt;(x);
}


int main(int argc,char** argv)
{
    vector&lt;int&gt; v;
    initialize(v) = 0,1,1,2,3,4,5;
    cout&lt;&lt;v[5]&lt;&lt;endl;
    return 0;
}
</pre>

</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 算法</h2>
<div class="outline-text-2" id="text-6">


</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 如何随机打乱数据</h3>
<div class="outline-text-3" id="text-6-1">

<p>   使用&lt;algorithm&gt;中的random_shuffle标准算法带两个随机访问迭代器和一个可选的随机数产生函数,可以在一定范围内随机打乱这些数据
</p>
<p>   
   若要使用自己的随机数产生器,则它必须接收一个简单参数并返回一个简单值,且这两个值都可以转换成iterator_traits&lt;RndIter&gt;::difference_type类型
</p></div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 如何在序列上进行集合运算</h3>
<div class="outline-text-3" id="text-6-2">

<p>   使用标准类库函数:set_union,set_difference,set_intersection和set_symmetric_difference
</p></div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 如何将一个范围的元素输出到数据流中</h3>
<div class="outline-text-3" id="text-6-3">

<p>   使用copy算法和ostream_iterator算法把每一个元素都写到一个流中去.
</p></div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 如何快速读取一系列数据存入容器中</h3>
<div class="outline-text-3" id="text-6-4">

<p>   使用istream_iterator即可
</p>


<pre class="example">istream_iterator&lt;stirng&gt; start(cin);
istream_iterator&lt;string&gt; end;
vector&lt;string&gt; vs(start,end)
</pre>

</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 类</h2>
<div class="outline-text-2" id="text-7">


</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 类成员变量,需要在独立的源文件中初始化它,而不是在它所声明的头文件中.</h3>
<div class="outline-text-3" id="text-7-1">




<pre class="example">// static.h
class OneStatic
{
        static int count;
};
// static.cpp
int OneStatic::count = 0;
</pre>


<p>   
   若把初始化语句放到头文件,则每个包含了头文件的实现文件都会給这个变量分配存储空间,这样会得到链接错误.
</p></div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 若在基类中提供了虚的析构函数,则你需要给它一个实现,这是因为子类的析构函数需要自动调用基类的析构函数</h3>
<div class="outline-text-3" id="text-7-2">

</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> 如何调用超类中的虚函数</h3>
<div class="outline-text-3" id="text-7-3">

<p>   使用目标基类来修饰你的成员函数名
</p>


<pre class="example">DerivedPtr-&gt;Base::foo()
</pre>

</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 异常安全</h2>
<div class="outline-text-2" id="text-8">


</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 保证初始化列表的异常安全</h3>
<div class="outline-text-3" id="text-8-1">

<p>   要捕获初始化列表中抛出的异常,需要使用try..catch的一种特殊用法
</p>


<pre class="example">class Broker
{
public:
        Broker(int devno1,int devno2)
        try:dev1_(Device(devno1)),
                    dev2_(Device(devno2)){}
        catch(...)
        {
                throw;          // 需要注意的是,这里无法访问dev1_和dev2_,因为这时候它们还不存在
        }
}
</pre>


<p>
   这里它把try代码块当成构造函数体.
</p></div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 如何使类具有强异常安全保证</h3>
<div class="outline-text-3" id="text-8-2">

<p>   先做可能抛出异常的操作. 这些危险操作完成后,再更新对象状态.
</p></div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 流</h2>
<div class="outline-text-2" id="text-9">


</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 如何实现自己的流操作符</h3>
<div class="outline-text-3" id="text-9-1">

<p>   有两类留操作符:带参数的和不带参数的.
</p>
<p>
   不带参数的流操作符容易实现. 只需要写一个以ios_base作为参数的函数. 在函数中对这个流做一些处理,然后再把这个流返回即可
</p>
<p>
   而带参数的流操作符,需要实现为一个类,该类以参数为构造函数的参数,并通过实现operator(ostream&amp; os)方法供流对象使用.
   此外,需要定义一个函数,该函数接收参数并返回上面定义的类对象.
   最后,还需要重载操作符&lt;&lt;,使得流对象直到 如何处理这个对象:
</p>


<pre class="example">class WidthSetter
{
public:
        WidthSetter(int n):width_(n){}
        void operator(osteram&amp; os) const {
                os.width(width_);
        }
private:
        int width_;
};


WidthSetter setWidth(int n){
        return WidthSetter(n);
}

ostream&amp; operator&lt;&lt;(ostream&amp; os, const WidthSetter&amp; ws){
        ws(os);
        return os;
}
</pre>

</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 如何删除/重命名文件</h3>
<div class="outline-text-3" id="text-9-2">

<p>   定义在&lt;cstdio&gt;中的标准C函数remove和rename可以完成这个任务
</p></div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> 如何创建一个临时文件名和文件</h3>
<div class="outline-text-3" id="text-9-3">

<p>   使用&lt;cstdio&gt;中的tmpfile或tmpname函数
</p></div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> 数字</h2>
<div class="outline-text-2" id="text-10">


</div>

<div id="outline-container-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 查找最大/最小值</h3>
<div class="outline-text-3" id="text-10-1">

<p>   使用&lt;algorithm&gt;中的函数max_element和min_element
</p></div>

</div>

<div id="outline-container-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 计算总和与平均值</h3>
<div class="outline-text-3" id="text-10-2">

<p>   使用&lt;numeric&gt;中的accumulate函数来计算总和,用distance函数来计算个数
</p>
<p>
   但该方法不能与istream_iterator一起工作
</p></div>

</div>

<div id="outline-container-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> 过滤掉给定范围之外的值</h3>
<div class="outline-text-3" id="text-10-3">

<p>   使用定义在&lt;algorithm&gt;中的remove_copy_if函数
</p></div>

</div>

<div id="outline-container-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> 生成随机数</h3>
<div class="outline-text-3" id="text-10-4">

<p>   &lt;cstdlib&gt;提供了一个C的运行函数rand来产生0到RAND_MAX之间的随机数
</p>
<p>
   使用rand函数前,还需要调用srand来給随机数产生器产生一个种子
</p></div>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> 国际化问题</h2>
<div class="outline-text-2" id="text-11">


</div>

<div id="outline-container-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 硬编码Unicode字符串</h3>
<div class="outline-text-3" id="text-11-1">

<p>   通过使用一个前置L来硬编码这个字符串,并且把这个字符像任何别的字符串一样输入,或者使用十六进制数字来代替这个unicode字符
</p>


<pre class="example">string ws = L"Infinity:\u221E";
</pre>


<p>   
   使用宽字符类型wchar_t可以用来存储Unicode字符. 这个类型的实现是预定义好的,常常使用UTF32编码
</p></div>

</div>

<div id="outline-container-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> 如何以遵循本地格式的方法读取/写入一个数字到流</h3>
<div class="outline-text-3" id="text-11-2">




<pre class="example">int main(int argc,char** argv)
{
    locale loc("");             // 创建一个本地的locale
    cout&lt;&lt;"Locale name is "&lt;&lt;loc.name()&lt;&lt;endl;
    cout.imbue(loc);            // 为流设置locale
    cout&lt;&lt;"pi in locale "&lt;&lt;cout.getloc().name()&lt;&lt;"is "&lt;&lt;3.14&lt;&lt;endl;
    return 0;
}
</pre>


<p>
   除了cout.imbue(loc)设置某个流的locale外,还能通过Locale::global来设置全局的locale
</p>
<p>
   Locale的名字是非标准化的. 通常它们看上去是这样的:
   &lt;language&gt;&lt;country&gt;.&lt;codepage&gt;
</p></div>

</div>

<div id="outline-container-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> 如何用本地的格式习惯来显示/读取时间和日期</h3>
<div class="outline-text-3" id="text-11-3">

<p>   用use_facet来从locale中获取符合本地习惯的facet
</p>


<pre class="example">const time_get&lt;char&gt;&amp; dateReader = use_facet&lt;time_get&lt;char&gt; &gt;(cin.getLoc());
const time_put&lt;char&gt;&amp; dataWriter = use_facet&lt;time_put&lt;char&gt; &gt;(cout.getloc());
</pre>


<p>
   然后可以使用facet time_put定义的put函数来将"存储于tm对象中的日期信息"转化成一个字符序列,写至output迭代器.
</p>


<pre class="example">ostreambuf_iterator osfitr = 
        dateWriter.put(out,             // output stream iterator
                       out,             // output stream
                       out.fill(),      // Fill char to use
                       &amp;t,              // Addr of tm struct
                       &amp;fmt[0],         // Begin of format string
                       &amp;fmt[2]);        // end of format string
</pre>


<p>
   可以通过time_put::put返回一个ostreambuf_iterator迭代器,它有一个成员函数failed()来判断输出是否有问题.
</p>


<pre class="example">if(osfitr.failed())
{
        throw Exception("put time failed");
}
</pre>

</div>

</div>

<div id="outline-container-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> 如何读取/写入符合本地格式的货币值</h3>
<div class="outline-text-3" id="text-11-4">

<p>   类似读取/写入本地格式的时间,但是用money_put和money_get facet来替代time_put和time_get facet
</p></div>

</div>

<div id="outline-container-11-5" class="outline-3">
<h3 id="sec-11-5"><span class="section-number-3">11.5</span> 如何对本地化字符串进行排序</h3>
<div class="outline-text-3" id="text-11-5">

<p>   使用collate facet的compare函数可以对本地化字符串进行比较
</p>


<pre class="example">bool localLessThan(const string&amp; s1, const string&amp; s2)
{
        const collate&lt;char&gt; &amp; col = use_facet&lt;collate&lt;char&gt; &gt;(locale());
        const char* pb1 = s1.data();
        const char* pb2 = s2.data();
        return (col.compare(pb1,pb1+s1.size(),
                            pb2,pb2+s2.size()) &lt; 0);
}
</pre>


<p>
   compare函数与strcmp函数类似,当第一个字符串&lt;第二个字符串时返回-1,相等时返回0,大于时返回1
</p></div>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> 指针</h2>
<div class="outline-text-2" id="text-12">


</div>

<div id="outline-container-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> 如何引用数据成员或成员函数的地址</h3>
<div class="outline-text-3" id="text-12-1">

<p>   使用类名和范围操作符::加上*来引用类成员
</p>


<pre class="example">MyClass::* mpi = &amp;MyClass::ival_; // 指向成员变量,这里的值不是一个内存中的具体地址,可以把它想象成是一个从这个类对象的起始地址开始到这个数据成员之间的偏移量
obj.*mpi = 5;                     // 給obj.ival赋值
int* pi = obj.ival_;              // 也可以普通指针引用具体某个对象的成员变量

void (MyClass::*mpf)();           // 指向成员函数的指针
mpf = &amp;MyClass::func;             // 指向成员函数
(obj.*mpf)();                     // 调用obj的成员函数
void(*pf)();                      // 定义一个普通函数指针
pf = &amp;obj.func();                 // 不能通过编译. 因为成员函数需要对象的上下文才有意义
</pre>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2014-07-22T16:17+0800</p>
<p class="author">Author: DarkSun</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
