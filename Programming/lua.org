#+TITLE: lua
#+AUTHOR: DarkSun
#+EMAIL: lujun9972@gmail.com
#+OPTIONS: H3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* NOTE
  1. ..为字符串连接运算符（可用于字符串与数字之间的连接）
  2. ~=为不等号
  3. *默认数组下标从1开始，不推荐数组下标从0开始，否则很多标准库无法使用* ，这点很不一样
  4. io.write()不输出换行，而print自动输出换行，print（）输出一个换行符
  5. lua中的table，类似于javascript中的Array(数组，同时也是Object，可以当Map用)
     #+BEGIN_SRC lua
     address={1,2,3}
     address.Street="Wyman Street"
     address.Contry="USA"
     print(address.Street,address["Contry"]
     #+END_SRC
  6. if语句
     * if 条件 then 语句 end
     * if 条件 then 语句 else 语句 end
     * if 条件 then 语句 elseif 条件 then 语句 else 语句 end
  7. util语句
     * repeat 语句 until 条件
  8. while语句
     * while 条件 do 语句 end
  9. for语句
     * for from语句,to值,by值
       #+BEGIN_SRC lua
-- Count from 1 to 4 by 1.
for a=1,4 do io.write(a) end

print()

-- Count from 1 to 6 by 3.
for a=1,6,3 do io.write(a) end
       #+END_SRC
     * for 变量 in 列表
       #+BEGIN_SRC lua
       for key,value in pairs({1,2,3,4}) do print(key, value) end
       -------- Output ------
  
       1       1
       2       2
       3       3
       4       4
       #+END_SRC
  10. 定义函数
      * 可以返回多个返回值
      function 函数名(parm1,parm2,parm3...)
      语句
      return value1,value2,value3...
      end
      #+BEGIN_SRC lua
 function myFirstLuaFunctionWithMultipleReturnValues(a,b,c)
     return a,b,c,"My first lua function with multiple return values", 1, true
 end

 a,b,c,d,e,f = myFirstLuaFunctionWithMultipleReturnValues(1,2,"three")
 print(a,b,c,d,e,f)


 -------- Output ------

 1       2       three   My first lua function with multiple return values
 1       true
      #+END_SRC
  11. 与javascript类似，所有的变量默认为全局变量.
      lua中的local与javascript中的var作用一样，使得变量成为局部变量
      #+BEGIN_SRC lua
-- All variables are global in scope by default.

b="global"

-- To make local variables you must put the keyword 'local' in front.
function myfunc()
    local b=" local variable"
    a="global variable"
    print(a,b)
end

myfunc()
print(a,b)


-------- Output ------

global variable  local variable
global variable global

      #+END_SRC
  12. 使用requre语句导入库
      #+BEGIN_SRC lua
      require("iuplua")
      #+END_SRC
* 术语
  1. Chunk:
     Chunk 是一系列语句，Lua 执行的每一块语句，比如一个文件或者交互模式下的每一行都是一个 Chunk。
  2. Upvalue:
     一个函数所使用的定义在它的函数体之外的局部变量（external local variable）称为这个函数的upvalue。
* 编译器lua
  1. 键入文件结束符可以退出交互模式，活着调用os.exit()函数也可以退出
  2. Lua 通常把每一个行当作一个 Chunk，但如果 Lua 一行不是一个完整的 Chunk时，他会等待继续输入直到得到一个完整的 Chunk.在 Lua 等待续行时，显示不同的提示符（一般是>>）.
** 参数说明
   * -l       让lua执行一系列文件
   * -i       要求 Lua 运行指定Chunk 后进入交互模式.
   * -e       直接将命令传入Lua
   * 
* 运算符
  1. 关系运算符:< > <= >= == ~=
     * lua中不等号用~=表示
     * 如果两个值类型不同，Lua认为两者不同；nil只跟自己相等
     * lua通过引用比较tables、userdata、functions
     * 为了避免不一致的结果，混合比较数字和字符串，lua会报错，例如2<'15'
  2. 逻辑运算符:and or not
     * 逻辑运算符认为false和nil是假，其他为真，0和""也为真
     * and 和 or的运算结果不是true和false，而是操作数的结果，这一点跟javascript类似
     * and的优先级比or高
     * C语言的a?b:c在lua中可以用(a and b) or c代替
  3. 连接运算符: ..
     * 如果操作数为数字，则自动转换成字符串
  4. 表构造符:{}
     * 初始化表a={v1,v2...}
     * 初始化表a={k1=v1,k2=v2...}
     * 通过a.x=nil来删除表中的项目
     * 每次调用{}，Lua都会创建一个新的table
       #+BEGIN_SRC Lua
-- 可以使用table构造一个list
list=nil
for line in io.lines() do
    list={next=list,value=line}
end
       #+END_SRC
     * 在同一个构造中，可以混用列表和record风格进行初始化
       #+BEGIN_SRC lua
polyline={k=v,k1,{a=b,c}}
       #+END_SRC
     * 上面的初始化方式有几个限制，你不能使用负索引，也不能使用类似+=*/这样的索引。
       更一般的初始化方式是tb={["+"]="add",["-"="SUB",[ 1 ]="one",[ 2 ]="two"]}
     * 构造函数中域分隔符都好(,)可以用分号(;)代替，通常我们使用分号来分割不同类型的表元素
       #+BEGIN_SRC lua
{x=10,y=45;"one","two"}
       #+END_SRC
* 变量
  lua中的变量如果没有特殊说明，全是全局变量，那怕是语句块或是函数里。变量前加local关键字的是局部变量。这一点跟javascript类似
** 变量类型
   * number
	 Lua的数字只有double型，64bit
   * string
     总是以\0结尾，但可以包含任意字符，包括\0
   * boolean
	 只有nil和false为假，其他都为真
   * function
     对lua来说，函数是一种基本数据类型――代表一种可执行对象，可以有自己的状态。
     可以用setfenv()来对函数设置函数环境
   * table
     任何类型的变量，除了nil，都可以做为表项的键。从简单的数值、字符串到复杂的函数、表等等都可以；同样，任何类型的变量，除了nil，都可以作为表项的值。给一个表项的值赋nil意味着从表中删除这一项.
	 #+begin_quote
: 所谓Table其实就是一个Key Value的数据结构，它很像Javascript中的Object，或
: 是PHP中的数组，在别的语言里叫Dict或Map，Table长成这个样子：
: 
: haoel = {name="ChenHao", age=37, handsome=True}
: 
: 下面是table的CRUD操作：
: 
: haoel.website="http://coolshell.cn/"
: local age = haoel.age
: haoel.handsome = false
: haoel.name=nil
: 
: 上面看上去像C/C++中的结构体，但是name,age, handsome, website都是key。你还
: 可以像下面这样写义Table：
: 
: t = {[20]=100, ['name']="ChenHao", [3.14]="PI"} 
: 
: 这样就更像Key Value了。于是你可以这样访问：t[20]，t["name"], t[3.14]。
: 
	 #+end_quote
	 
	 在lua中，数字其实也是一种特殊table。
	 #+begin_quote
: arr = {10,20,30,40,50}
: 
: 这样看上去就像数组了。但其实其等价于：
: 
: arr = {[1]=10, [2]=20, [3]=30, [4]=40, [5]=50}
: 
: 所以，你也可以定义成不同的类型的数组，比如：
: 
: arr = {"string", 100, "haoel", function() print("coolshell.cn") end}
: 
: 注：其中的函数可以这样调用：arr[4]()。
: 我们可以看到Lua的下标不是从0开始的，是从1开始的。
: 
: for i=1, #arr do
: print(arr[i])
: end
: 
: 注：上面的程序中：#arr的意思就是arr的长度。
:                              	 
	 #+end_quote
   * userdata
     用户（非脚本用户）定义的C数据结构。脚本用户只能使用它，不能定义。
   * thread
     Lua协作线程，与一般操作系统的抢占式线程不一样。
     yield的传入参数是另一个进程resume的返回值
     resume的传入参数是另一个进程yield的返回值
   * nil
** 特殊变量
   * 全局变量arg存放Lua的命令行参数:
     脚本名索引为0，脚本参数从1开始增加，脚本前面的参数从-1开始减少
     #+BEGIN_SRC lua
       prompt> lua -e "sin=math.sin" script a b 
       arg 表如下： 
       arg[-3] = "lua" 
       arg[-2] = "-e" 
       arg[-1] = "sin=math.sin" 
       arg[0] = "script" 
       arg[1] = "a" 
       arg[2] = "b" 
     #+END_SRC
   * LUA_INIT:
     Lua 会查找环境变量 LUA_INIT 的值，如果变量存在并且值为@filename，Lua 将加载指定文件。如果变量存在但不是以@开头，Lua假定 filename 为 Lua 代码文件并且运行他。
   * _G
	 lua使用一个名为_G的Table来保存全局变量。
* 语法
** 注释
   * 单行注释
     #+begin_src lua
       -- 单行注释
     #+end_src
   * 多行注释
	 #+begin_src lua
             --[[
                line1
                line2
                多行注释
             --']]
	 #+end_src
** 赋值
   1. Lua可以对多个变量同时赋值，这点类似Python
   2. 若变量个数与值个数不同则
      * 变量个数>值得个数,变量个数补足nil
      * 变量个数<值得个数,多余的值会被忽略
   3. 局部变量与代码块
      * 与javascript类似，所有的变量默认为全局变量.
      * lua中的local与javascript中的var作用一样，使得变量成为局部变量
        #+BEGIN_SRC lua
-- All variables are global in scope by default.

b="global"

-- To make local variables you must put the keyword 'local' in front.
function myfunc()
    local b=" local variable"
    a="global variable"
    print(a,b)
end

myfunc()
print(a,b)


-------- Output ------

global variable  local variable
global variable global

       #+END_SRC
      * 使用do...end定义一个block
** 控制结构语句
   1. if语句
      * if 条件 then 语句 end
      * if 条件 then 语句 else 语句 end
      * if 条件 then 语句 elseif 条件 then 语句 else 语句 end
		#+begin_src lua
          if age == 40 and sex =="Male" then
             print("男人四十一枝花")
          elseif age > 60 and sex ~="Female" then
             print("old man without country!")
          elseif age < 20 then
             io.write("too young, too naive!\n")
          else
             local age = io.read()
             print("Your age is "..age)
          end
          
          -- 上面的语句不但展示了if-else语句，也展示了
          -- 1）“～=”是不等于，而不是!=
          -- 2）io库的分别从stdin和stdout读写的read和write函数
          -- 3）字符串的拼接操作符“..”
          
          -- 另外，条件表达式中的与或非为分是：and, or, not关键字。
		#+end_src
   2. until语句
      * repeat 语句 until 条件
		#+begin_src lua
          sum = 2
          repeat
             sum = sum ^ 2 --幂操作
             print(sum)
          until sum >1000
		#+end_src
   3. while语句
      * while 条件 do 语句 end
		#+begin_src lua
          sum = 0
          num = 1
          while num <= 100 do
             sum = sum + num
             num = num + 1
          end
          print("sum =",sum)
          
		#+end_src
   4. for语句
      * for var=from值,to值,by值
        #+BEGIN_SRC lua
        -- Count from 1 to 4 by 1.
        for a=1,4 do io.write(a) end

        print()

        -- Count from 1 to 6 by 3.
        for a=1,6,3 do io.write(a) end
        #+END_SRC
	需要注意的是:from、to、by值仅会在循环开始前执行一次；控制变量var是局部变量自动被声明,并且只在循环内有效. 因此如果需要保留控制变量的值，需要在循环中将其保存。
      * for 变量 in 列表
        #+BEGIN_SRC lua
        for key,value in pairs({1,2,3,4}) do print(key, value) end
        -------- Output ------
       
        1       1
        2       2
        3       3
        4       4
        #+END_SRC
	需要注意的是:控制变量var是局部变量自动被声明,并且只在循环内有效. 因此如果需要保留控制变量的值，需要在循环中将其保存。
   5. Lua语法要求break和return职能出现在block的结尾一句，所以若是为了调试或其他需要在block中间使用return或break，需要显式使用do...end来实现
** 函数    
   Lua的函数的语法与Javascript的很像，特性与lisp很像。
*** 定义函数
	* 函数可以返回多个返回值
	  function 函数名(parm1,parm2,parm3...)
	  语句
	  return value1,value2,value3...
	  end
	  #+BEGIN_SRC lua
	   	function myFirstLuaFunctionWithMultipleReturnValues(a,b,c)
		   	return a,b,c,"My first lua function with multiple return values", 1, true
	   	end

	   	a,b,c,d,e,f = myFirstLuaFunctionWithMultipleReturnValues(1,2,"three")
	   	print(a,b,c,d,e,f)


	   	-------- Output ------

	   	1       2       three   My first lua function with multiple return values
	   	1       true
	  #+END_SRC
	* Lua的函数可以接受可变数据的参数，类似C语言在函数参数列表中使用三点...表示函数有可变的参数。Lua将函数放在一个叫arg特殊变量内，这个变量是一个表表。除了参数以外，arg表还有一个域n表示参数的个数。
   	  #+BEGIN_SRC lua
        printResult=""
        function print(...)
            for i,v in ipairs(arg) do
                printResult=printResult..tostring(v).."\t"
            end
            printResult=printResult.."\n"
        end
   	  #+END_SRC
	* 命名参数：Lua可以通过将所有的参数放在一个表内，把表作为函数的唯一参数来实现类似命名参数的功能。
   	  #+BEGIN_SRC lua
        function rename(args)
            return os.rename(args.old,args.new)
        end
        rename{old="old.lua",new="new.lua"}     --当函数参数仅一个，且为表或字符串时，可以省略()
   	  #+END_SRC
	* 定义匿名函数
   	  function (x)
   	  语句
   	  end
	  #+begin_src lua
        function foo(x) return x^2 end
        -- 等价于
        foo = function(x) return x^2 end
	  #+end_src
	* Lua将函数看成一个普通那个变量，也支持闭包
   	  #+BEGIN_SRC lua
        function newCounter() 
           local i = 0 
           return function()     -- anonymous function 
              i = i + 1 
              return i 
           end 
        end 
        c1 = newCounter() 
        print(c1())  --> 1  
        print(c1())  --> 2
   	  #+END_SRC
*** 调用函数
      * 当函数只有一个参数并且这个参数是字符串或者表构造时，()是可选的:
	#+BEGIN_SRC lua
	print "abc"       -- print("abc")
	#+END_SRC
      * Lua也提供面向对象方式调用函数的语法： obj:function().
	*这里object与function之间用:分隔开，而模块与方法之间用.分隔开！！*
	#+BEGIN_SRC lua
	o:foo(x)         --> o.foo(o,x)
	#+END_SRC
      * Lua函数的参数与javascript类似，，多余的部分被省略，缺少部分用nil补足
      * 如果没有返回，则值为nil
      * 函数调用作为函数参数或是表的构造函数中,或是在return语句之后时，与多值赋值时相同
	#+BEGIN_SRC lua
	print(f())          -->print(a,b,c)
	a={f()}             -->a={a,b,c}
	return f()          -->return a,b,c
	#+END_SRC
      * 可以使用圆括号强制使调用返回一个值
	print((f()))       -->print(a)
      * 可以用unpack函数来讲一个数组转换成多个元素
 
* 高级主题
** 面向对象编程
   与javascript类似，lua是基于对象的，其可以用setmetatable()设置一个元表（metatable）,这个元表类似于javascript的prototype
*** 简单的对象实现方式
    * 对象工厂模式
      如前面代码的create函数用表来表示对象,把对象的数据和方法都放在一张表内，虽然没有隐藏私有成员，但对于简单脚本来说完全可以接受。
    * 成员方法的定义
      function obj:method(a1, a2, ...) … end 等价于
      function obj.method(self, a1, a2, ...) … end 等价于
      obj.method = function (self, a1, a2, ...) … end
    * 成员方法的调用
      obj:method(a1, a2, …) 等价于
      obj.method(obj, a1, a2, ...)
    #+BEGIN_SRC lua
    function create(name, id)
       local obj = { name = name, id = id }
       function obj:SetName(name)
           self.name = name
       end
       function obj:GetName()
           return self.name
       end
       function obj:SetId(id)
           self.id = id
       end
       function obj:GetId()
           return self.id
       end
       return obj
    end
    #+END_SRC
*** 简单继承
    1. 先调用基类的工厂函数产生一个基类的对象
    2. 在这个基类的对象的基础上增加子类的属性和方法
    3. 返回这个对象
    #+BEGIN_SRC lua
    function createBase()
        local obj={attr="base"}
	function obj:setName(name)
	    self.name=name
	end
    end
    
    function createSub()
        local obj=createBase()
	obj.attr="Sub"
	function obj:setId(id)
	    self.id=id
	end
    end
    #+END_SRC
*** 实现对外隐藏属性
    *　实现方式 
    　 把需要隐藏的成员放在一张表里，把该表作为成员函数的upvalue。
    * 局限性 
      基于对象的实现不涉及继承及多态。但另一方面，脚本编程是否需要继承和多态要视情况而定。
*** 使用MetaTable实现重载运算符
	#+begin_quote
: 
: MetaTable 和 MetaMethod
: 
: MetaTable和MetaMethod是Lua中的重要的语法，MetaTable主要是用来做一些类似于C++重载操作符式的功能。
: 
: 比如，我们有两个分数：
: 
: fraction_a = {numerator=2, denominator=3}
: fraction_b = {numerator=4, denominator=7}
: 
: 我们想实现分数间的相加：2/3 + 4/7，我们如果要执行： fraction_a + fraction_b，会报错的。
: 
: 所以，我们可以动用MetaTable，如下所示：
: 
: fraction_op={}
: function fraction_op.__add(f1, f2)
: ret = {}
: ret.numerator = f1.numerator * f2.denominator + f2.numerator * f1.denominator
: ret.denominator = f1.denominator * f2.denominator
: return ret
: end
: 
: 为之前定义的两个table设置MetaTable：（其中的setmetatble是库函数）
: 
: setmetatable(fraction_a, fraction_op)
: setmetatable(fraction_b, fraction_op)
: 
: 于是你就可以这样干了：（调用的是fraction_op.__add()函数）
: 
: fraction_s = fraction_a + fraction_b
: 
: 至于__add这是MetaMethod，这是Lua内建约定的，其它的还有如下的MetaMethod：
: 
: __add(a, b)                     对应表达式 a + b
: __sub(a, b)                     对应表达式 a - b
: __mul(a, b)                     对应表达式 a * b
: __div(a, b)                     对应表达式 a / b
: __mod(a, b)                     对应表达式 a % b
: __pow(a, b)                     对应表达式 a ^ b
: __unm(a)                        对应表达式 -a
: __concat(a, b)                  对应表达式 a .. b
: __len(a)                        对应表达式 #a
: __eq(a, b)                      对应表达式 a == b
: __lt(a, b)                      对应表达式 a < b
: __le(a, b)                      对应表达式 a <= b
: __index(a, b)                   对应表达式 a.b
: __newindex(a, b, c)             对应表达式 a.b = c
: __call(a, ...)                  对应表达式 a(...)	
	#+end_quote
*** 使用元表实现继承
    * 实现方法
      将基类设置为子类的元表、并将子类的元表（即基类）设置为自身（也是基类，也就是代码self.__index=self）
      #+BEGIN_SRC lua
      Robot = { name = "Sam", id = 001 }
      function Robot:New(extension)
        local t = setmetatable(extension or { }, self)
        self.__index = self
        return t
      end
      FootballRobot = Robot:New( {position = "right back"})
      fr=FootballRobot:New()
      #+END_SRC
    * prototype模式
      一个对象既是一个普通的对象，同时也可以作为创建其他对象的原型的对象（即类对象，class object）；
	  动态的改变原型对象的属性就可以动态的影响所有基于此原型的对象；
	  另外，基于一个原型被创建出来的对象可以重载任何属于这个原型对象的方法、属性而不影响原型对象；
	  同时，基于原型被创建出来的对象还可以作为原型来创建其他对象。    
	  #+begin_quote
: 考虑到上面的index方法，该方法主要是重载了find key的操作.    
: 如果我们有两个对象a和b，我们想让b作为a的prototype只需要：
: setmetatable(a, {__index = b})
: 
	  #+end_quote
** 包
   * 定义
     包是一种组织代码的方式。
   * 实现方式
     一般在一个Lua文件内以module函数开始定义一个包。module同时定义了一个新的包的函数环境，以使在此包中定义的全局变量都在这个环境中，而非使用包的函数的环境中。理解这一点非常关键。以前面的代码为例， “module(..., package.seeall)”的意思是定义一个包，包的名字与定义包的文件的名字相同（除去文件名后缀，在前面的代码中，就是“mypack”），并且在包的函数环境里可以访问使用包的函数环境（比如，包的实现使用了print，这个变量没有在包里定义，而是定义在使用包的外部环境中）。
   * 使用方式
     一般用require函数来导入一个包，要导入的包必须被置于包路径（package path）上。包路径可以通过package.path或者环境变量来设定。一般来说，当前工作路径总是在包路径中。
	 #+begin_quote
: 我们可以直接使用require(“model_name”)来载入别的lua文件，文件的后缀是.lua。载入的时候就直接执行那个文件了。比如：
: 
: 我们有一个hello.lua的文件：
: 
: print("Hello, World!")
: 
: 如果我们：require(“hello”)，那么就直接输出Hello, World！了。
: 
: 注意：
: 1）require函数，载入同样的lua文件时，只有第一次的时候会去执行，后面的相同的都不执行了。
: 2）如果你要让每一次文件都会执行的话，你可以使用dofile(“hello”)函数
: 3）如果你要玩载入后不执行，等你需要的时候执行时，你可以使用 loadfile()函数，如下所示：
: 
: local hello = loadfile("hello")
: ... ...
: ... ...
: hello()
: 
: loadfile(“hello”)后，文件并不执行，我们把文件赋给一个变量hello，当hello()时，才真的执行。
: 
: 当然，更为标准的玩法如下所示。
: 
: 假设我们有一个文件叫mymod.lua，内容如下：
: 
: local HaosModel = {}
: local function getname()
: return "Hao Chen"
: end
: function HaosModel.Greeting()
: print("Hello, My name is "..getname())
: end
: return HaosModel
: 
: 于是我们可以这样使用：
: 
: local hao_model = require("mymod")
: hao_model.Greeting()
: 
: 其实，require干的事就如下：（所以你知道为什么我们的模块文件要写成那样了）
: 
: local hao_model = (function ()
: --mymod.lua文件的内容--
: end)()     
	 #+end_quote
** 协作线程
   * 创建协作线程
     通过coroutine.create可以创建一个协作线程，该函数接收一个函数类型的参数作为线程的执行体，返回一个线程对象。
   * 启动线程
     通过coroutine.resume可以启动一个线程或者继续一个挂起的线程。该函数接收一个线程对象以及其他需要传递给该线程的参数。线程可以通过线程函数的参数或者coroutine.yield调用的返回值来获取这些参数。当线程初次执行时，resume传递的参数通过线程函数的参数传递给线程，线程从线程函数开始执行；当线程由挂起转为执行时，resume传递的参数以yield调用返回值的形式传递给线程，线程从yield调用后继续执行。
   * 线程放弃调度
     线程调用coroutine.yield暂停自己的执行，并把执行权返回给启动/继续它的线程；线程还可利用yield返回一些值给后者，这些值以resume调用的返回值的形式返回
   * 另一种迭代方式
     协作线程可以作为for循环迭代器的另一种实现方式。虽然对于简单的数组遍历来说，没有必要这么做，但是考虑一下，如果需要遍历的数据集合是一个复杂数据结构，比如一棵树，那么协作线程在简化实现上就大有用武之地了。
     #+BEGIN_SRC lua
     function enum(array)
       return coroutine.wrap(function()
        local len = #array
        for i = 1, len do
            coroutine.yield(array[i])
        end
      end)
     end
     function foreach(array, action)
       for element in enum(array) do
         action(element)
       end
     end
     foreach({1, 2, 3}, print)
     #+END_SRC
