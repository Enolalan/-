#+TITLE: bash
#+AUTHOR: lujun9972
#+TAGS: Programming
#+DATE: [2016-11-28 一 23:06]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* set
set是shell的一个内部命令,它能处理很多事情.

当没有参数时,set给出环境变量的值.

set还能重置基本参数,如$1,$2的值. 如 =set 1 2= 就将$1设置成1,$2设置成2.

* trap
trap会捕获信号并执行相应的命令序列. 并且trap在执行完相应命令序列后又会回到断点继续执行下面的命令.

trap可以用于保护程序不会由于连接中断造成的挂断信号而中断.
#+BEGIN_SRC sh
  (trap '' 1;long-running-command) &
#+END_SRC

事实上,使用trap能实现我们自己的nohup程序:
#+BEGIN_SRC sh
  trap "" 1 15
  if test -t 2>&1
  then
      echo "Sending output to 'nohup.out'"
      exec nice -5 $* >>nohup.out 2>&1
  else
      exec nice -5 $* 2>&1
  fi
#+END_SRC
* getopts
getopts的使用方法为:
#+BEGIN_SRC sh
  getopts option_string variable [args]
#+END_SRC
+ 其中 =option_string= 中每个字母表示一个选项,选项之前不带 =-=

+ getopts查看所有以连字符开头的参数,将其视为选项,如果输入选项,将把这与option_string对比,如果匹配发现,将 =variable= 的值设置为该选项. 如果不匹配发现,则variable的值为 =?=

  假设有这么一个脚本
  #+BEGIN_SRC sh :exports both :results org
    cat > /tmp/test.sh <<'EOF'
    #!/bin/bash

    HELP=false
    FILE=false

    while getopts hf OPTION
    do
        case $OPTION in
            h)HELP=true
              echo "HELP is $HELP"
              ;;
            f)FILE=true
              echo "FILE is $FILE"
              ;;
            ,*)echo "OPTION is $OPTION"
        esac
    done
    EOF

    chmod +x /tmp/test.sh

    echo "选项分来写"
    /tmp/test.sh -h -f
    echo "选项合并起来写"
    /tmp/test.sh -hf
    echo "未知的选项"
    /tmp/test.sh -h -p
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  选项分来写
  HELP is true
  FILE is true
  选项合并起来写
  HELP is true
  FILE is true
  未知的选项
  HELP is true
  OPTION is ?
  #+END_SRC

+ 如果需要为选项指定一个值,那么需要在 =option_string= 中放一个冒号到选项后面. 此时使用变量OPTARG来保存该参数值.

  例如:
  #+BEGIN_SRC sh :exports both :results org
    cat > /tmp/test.sh <<'EOF'
        #!/bin/bash

        HELP=false
        FILE=false

        while getopts hf: OPTION
        do
            case $OPTION in
                h)HELP=true
                  echo "HELP is $HELP"
                  ;;
                f)FILE=$OPTARG
                  echo "FILE is $FILE"
                  ;;
            esac
        done
    EOF

    chmod +x /tmp/test.sh

    echo "选项f必须取值"
    /tmp/test.sh -h -f /etc/passwd
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  选项f必须取值
  HELP is true
  FILE is /etc/passwd
  #+END_SRC

+ 若在 =option_string= 中的某选项后加了 =:=,但实际执行时没有给该选项带参数则会返回一个错误信息.

  但是你可以用自己的反馈信息屏蔽它,方法是

  1. 将冒号放在option_string开始部分

  2. 在case中用?作为匹配捕获错误

  例如:
  #+BEGIN_SRC sh :exports both :results org
    cat >/tmp/test.sh <<'EOF'
    while getopts :af: OPTION
    do
        case $OPTION in
            a)echo "a means ALL"
              ;;
            f)echo "FILE is $OPTARG"
              ;;
            ?)echo "Usage: $0 [-a] [-f file]"
               ;;
        esac
    done
    EOF

    chmod +x /tmp/test.sh

    echo "给f带上参数"
    /tmp/test.sh -a -f /etc/passwd

    echo "f不带参数"
    /tmp/test.sh -a -f
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  给f带上参数
  a means ALL
  FILE is /etc/passwd
  f不带参数
  a means ALL
  Usage: /tmp/test.sh [-a] [-f file]
  #+END_SRC
