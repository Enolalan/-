#+TITLE: bash
#+AUTHOR: lujun9972
#+TAGS: Programming
#+DATE: [2016-11-28 一 23:06]
#+LANGUAGE:  zh-CN
#+OPTIONS:  H:6 num:nil toc:t \n:nil ::t |:t ^:nil -:nil f:t *:t <:nil

* set
set是shell的一个内部命令,它能处理很多事情.

当没有参数时,set给出环境变量的值.

set还能重置基本参数,如$1,$2的值. 如 =set 1 2= 就将$1设置成1,$2设置成2.

* trap
trap会捕获信号并执行相应的命令序列. 并且trap在执行完相应命令序列后又会回到断点继续执行下面的命令.

trap可以用于保护程序不会由于连接中断造成的挂断信号而中断.
#+BEGIN_SRC sh
  (trap '' 1;long-running-command) &
#+END_SRC

事实上,使用trap能实现我们自己的nohup程序:
#+BEGIN_SRC sh
  trap "" 1 15
  if test -t 2>&1
  then
      echo "Sending output to 'nohup.out'"
      exec nice -5 $* >>nohup.out 2>&1
  else
      exec nice -5 $* 2>&1
  fi
#+END_SRC
* getopts
getopts的使用方法为:
#+BEGIN_SRC sh
  getopts option_string variable [args]
#+END_SRC
+ 其中 =option_string= 中每个字母表示一个选项,选项之前不带 =-=

+ getopts查看所有以连字符开头的参数,将其视为选项,如果输入选项,将把这与option_string对比,如果匹配发现,将 =variable= 的值设置为该选项. 如果不匹配发现,则variable的值为 =?=

  假设有这么一个脚本
  #+BEGIN_SRC sh :exports both :results org
    cat > /tmp/test.sh <<'EOF'
    #!/bin/bash

    HELP=false
    FILE=false

    while getopts hf OPTION
    do
        case $OPTION in
            h)HELP=true
              echo "HELP is $HELP"
              ;;
            f)FILE=true
              echo "FILE is $FILE"
              ;;
            ,*)echo "OPTION is $OPTION"
        esac
    done
    EOF

    chmod +x /tmp/test.sh

    echo "选项分来写"
    /tmp/test.sh -h -f
    echo "选项合并起来写"
    /tmp/test.sh -hf
    echo "未知的选项"
    /tmp/test.sh -h -p
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  选项分来写
  HELP is true
  FILE is true
  选项合并起来写
  HELP is true
  FILE is true
  未知的选项
  HELP is true
  OPTION is ?
  #+END_SRC

+ 如果需要为选项指定一个值,那么需要在 =option_string= 中放一个冒号到选项后面. 此时使用变量OPTARG来保存该参数值.

  例如:
  #+BEGIN_SRC sh :exports both :results org
    cat > /tmp/test.sh <<'EOF'
        #!/bin/bash

        HELP=false
        FILE=false

        while getopts hf: OPTION
        do
            case $OPTION in
                h)HELP=true
                  echo "HELP is $HELP"
                  ;;
                f)FILE=$OPTARG
                  echo "FILE is $FILE"
                  ;;
            esac
        done
    EOF

    chmod +x /tmp/test.sh

    echo "选项f必须取值"
    /tmp/test.sh -h -f /etc/passwd
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  选项f必须取值
  HELP is true
  FILE is /etc/passwd
  #+END_SRC

+ 若在 =option_string= 中的某选项后加了 =:=,但实际执行时没有给该选项带参数则会返回一个错误信息.

  但是你可以用自己的反馈信息屏蔽它,方法是

  1. 将冒号放在option_string开始部分

  2. 在case中用?作为匹配捕获错误

  例如:
  #+BEGIN_SRC sh :exports both :results org
    cat >/tmp/test.sh <<'EOF'
    while getopts :af: OPTION
    do
        case $OPTION in
            a)echo "a means ALL"
              ;;
            f)echo "FILE is $OPTARG"
              ;;
            ?)echo "Usage: $0 [-a] [-f file]"
               ;;
        esac
    done
    EOF

    chmod +x /tmp/test.sh

    echo "给f带上参数"
    /tmp/test.sh -a -f /etc/passwd

    echo "f不带参数"
    /tmp/test.sh -a -f
  #+END_SRC

  #+RESULTS:
  #+BEGIN_SRC org
  给f带上参数
  a means ALL
  FILE is /etc/passwd
  f不带参数
  a means ALL
  Usage: /tmp/test.sh [-a] [-f file]
  #+END_SRC

* --
对于linux来说, =--= 是一个特殊字符,用于表示选项列表的结束,后面的命令行参数都被认为是普通参数.

* 用exec进行永久重定向 
如果脚本中有大量数据需要重定向,那么重定向每条语句会显得很麻烦. 
这种情况可以用 =exec= 命令告诉shell在命令执行期间重定向某个特定符号描述符.

例如
#+BEGIN_SRC sh
  exec 1>testout                  # 把stdout重定向到testout文件中
  exec 2>testerr                  # 把stderr重定向到testerr文件中
  exec 0<testin                   # 把stdin重定向到testin文件
#+END_SRC

在shell中不仅仅局限于这3个默认的文件描述符.
shell最多可以又9个打开的文件描述符. 其他6个3~8的文件描述符均可用作输入或输出重定向

例如
#+BEGIN_SRC sh
  exec 3>test3                    # 创建一个输出文件描述符
  echo "should be in test3" >&3   # 将stdout重定向到3这个描述符,也就是test3文件中
#+END_SRC

如果要恢复已经重定向的文件描述符,你需要分配另一个文件描述符来保存原文件描述符的指向. 像这样:
#+BEGIN_SRC sh
  exec 3>&1                       # 用文件描述符3指向屏幕
  exec 1>test                     # 将stdout指向test文件
  echo "should be in test"
  exec 1>&3                       # 将stdout又指向屏幕
#+END_SRC

如果需要关闭文件描述符,则将它重定向特殊符号 =&-= 即可
#+BEGIN_SRC sh
  exec 3> test
  echo "should in test" >&3
  exec 3>&-                       # 关闭文件描述符3
  echo "will cause an error" >&3  # 将会提示3 Bad file descriptor
#+END_SRC
