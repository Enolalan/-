#+TITLE: C专家编程
#+AUTHOR: DarkSun
#+EMAIL: lujun9972@gmail.com
#+OPTIONS: H3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 分析C语言的声明
** 理解C语言声明的规则
   1. 声明从它的名字开始读取,然后按照优先级顺序以此读取
   2. 优先级从高到低依次是:
      1. 声明中被括号扩起来的那部分
      2. 后缀操作符
         * 括号()表示这是一个函数
         * 放括号[]表示这是一个数组
      3. 前缀参数操作符
         * 星号*表示指向...的指针
   3. 如果const和volatile关键字的后面紧跟着类型说明符(如int,long),那么
      它作用于类型说明符. 其他情况下,从const和volatile关键字作用于它左
      侧紧邻的指针星号.

      我的理解是const和volatile关键字约束的是它后面的东西,*
      例如const char* p表示p是个指向char的指针,这个char是const的,
      char const * p表示p是个指向const变量的指针同时这个变量是char型,
      而char * const p 表示p是const的,这个p是个指针,该指针指向char型.
** 例子
   分析char * const *(*next)();
   
   | 适用规则 | 解释                                    |
   |----------+-----------------------------------------|
   | A        | 首先看变量next,同时注意到它直接被()括住 |
   | B.1      | 把括号内的东西看成一个整体              |
   | B.3      | 表示next为一个指向...的指针             |
   | B        | 考虑括号外的东西,在星号前缀和括号后缀之间进行选择 |
   | B.2      | 规则告诉我们,优先级高的是后边的函数括号,所以next是一个函数指针,指向一个返回...的函数 |
   | B.3      | 前缀*表示该函数返回一个指针                                                          |
   | C        | 该指针指向一个const的值,*注意不要理解为该指针是const的!!*                              |
   | B.3      | 该常量是一个指向char的指针                                                                  |
* 运行时的数据结构
** 段
   * 目标文件和可执行文件可以有几个不同的格式:ELF格式(最常见的格式),COFF格式,a.out格
     式
   * 尽管格式不相同,但是段的概念是共同的,可以用size命令来获得可执行文
     件中的文本段,数据段和bss段. 其中文本段保存可执行文件的指令,数据段
     保存初始化后的全局和静态变量,BSS段只保存没有值的变量的总大小.
** 内存布局
   * 在运行时,操作系统将可执行文件的文本段加载到进程的文本段,将可执行
     文件的数据段加载到进程的数据段,根据可执行文件中BSS段标注的大小分
     配一块内存作为进程的BSS段. 此外还需要分配栈空间用于存放临时变量,
     临时数据,过程活动记录和函数参数等,还需要堆空间用于动态分配的内存.
   * 需要注意的是,进程地址空间最低部分有一小部分区域未被映射到物理内存
     中,所以任何对它的引用都是非法的. 通常情况下它是从地址0开始的几K字
     节,被用于捕捉使用空指针和小整型值指针引用内存的情况.
   * 运行时,系统维护一个sp指针指向栈空间的当前顶部位置.
   * 过程活动记录用于跟踪函数调用链--哪些函数调用了哪些函数,函数返回时
     控制将返回何处. 过程活动记录一般包括如下一些内容:局部变量,参数,静
     态链接(用于嵌套函数指向它的上一层函数的过程活动记录,C语言中不采用).
     指向前一个过程活动记录的指针和返回地址.
   * 根据实现的不同,过程活动记录并不一定存在栈空间中,也可能存放入寄存
     器或堆空间中.
   * UNIX的栈空间是自动生长的,程序员可以认为它是无限大的. 正常情况下栈
     空间顶部的下端有一个称为red zone的小型区域,如果对这个区域进行引用,并
     不会产生失败,相反操作系统新增一块内存来增加栈空间的大小.
   * MSDOS的栈空间大小是固定的.
** 关于内存的错误
   * 如何检测内存泄漏?
     1. 不断的调用swap命令查看是否交换区在减少
     2. 不断的用vmstat命令查看是否不断有内存在分配且从不释放
     3. 使用ps -lu用户名 来显示所有进程的大小,其中SZ列为进程的大小页数.
   * 总线错误和段错误有什么区别?

     总线错误几乎总是由于未对齐的读或写引起的. 对齐的意思就是数据项只
     能存储在地址是数据项大小的整数倍的内存位置上.

     段错误是由于尝试对一个并不属于进程的地址空间的地址进行操作而产生
     的. 这常常是由于解引用一个为初始化或非法值的指针引起的.

     要注意的是,如果为初始化的指针恰好具有未对齐的值,则会产生总线错误
     而不是段错误.
** setjmp和longjmp
   * setjmp(jmp_buf i)函数用变量i保存了当前的程序计数器和栈顶指针. 同
     时返回0.
   * longjmp(jmp_buf i,int j)跳回变量i保持的位置,让它看起来就像是从原
     来的setjmp函数返回一样,但是返回值设为j以便区分是否正常返回.
   * 保证局部变量在longjmp过程中一直保持它的值的唯一可靠方法是把它声明
     为volatile.
   * setjmp和longjmp最大用处是错误恢复(C++中变异为更普遍的异常处理机制
     了).
* UNIX实现逐字符输入的方法
** 阻塞式
   使用stty程序临时修改终端驱动模式
   #+BEGIN_SRC c
     #include <stdio.h>
     int main()
     {
       int c;
       system("stty raw");           /* 更改终端为一次一个字符的模式 */
       c = getchar();
       system("stty cooked");        /* 终端切换回一次一行的模式 */
     }
   #+END_SRC
** 非阻塞式
   使用ioctl系统调用
   #+BEGIN_SRC c
     #include<sys/filio.h>
     int kbhit()
     {
       int i;
       ioctl(0,FIONREAD,%i);
       return i;
     }
     main()
     {
       int i = 0;
       int c = ' ';
       system("stty raw -echo");
       printf("enter q to quit\n");
       for(; c !='q';++i) {
         if (kbhit()){
           c = getchar();
           printf("\n got 5c, on iteration %d",c,i);
         }
       }
       system("stty cooked echo");
     }
     
   #+END_SRC
