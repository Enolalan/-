#+TITLE: Exceptional_C
#+AUTHOR: DarkSun
#+EMAIL: lujun9972@gmail.com
#+OPTIONS: H3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t

* 编译防火墙和Pimp惯用法
  1. 对于函数的参数类型和返回值类型来说,只需要前置申明就足够了
     被继承的基类必须有完整的定义,这样编译器才能确定子类对象的大小,虚函数以及其他基本信息.
     定义类中的成员变量类型,必须有完整的定义(指针不需要),这样才能确定子类对象的大小
  2. 如果只要流的前置申明,应该优先使用#include<iosfwd>
  3. 如果只需要前置申明,绝对不要用#include包含相应的头文件
  4. 对于广泛应用的类,应该优先使用Pimpl惯用法来隐藏实现细节,通过一个不透明的指针(指向一个进行了前置声明但又没有定义的类)来保存私有成员(包括成员变量和成员函数).
     * 不能将虚成员函数放在Pimpl隐藏起来,这是为了能够在更深层次的派生类中进行覆盖
     * Pimpl中的函数可能需要一个指向可见对象的回指指针,并通过这个指针来调用可见类中的函数,这将会增加一个间接层
     * 通常,最好的折中方法就是将所有的私有成员(包括成员变量和函数)放入Pimpl中,并将只有私有成员才会调用的非私有函数也放入Pimpl中.
     * protected成员永远不应该被放入Pimpl中,因为这样会使保护成员失去其应有的作用.
     * 在某些情况下可以将Pimpl写成与原来的类完全一样的形式,而将原来的类写成仅由转调函数组成的共有接口.但这样原来的类在继承时基本无用了.
  5. 只有当性能分析和经验教训都证明了,确实需要有额外的性能提升时,才使用Pimpl惯用法,并且在通常情况下使用pimpl,而在特殊情况下使用Fast Pimpl(使用定容量的Allocator)
* 名字查找,名字控件和接口规则
  1. 如果在声明函数的参数时,使用了一个类(例如NS::T),那么在查找正确的函数名字时,编译器在包含参数类型的名字空间中也会进行参数名字的匹配.
     #+BEGIN_SRC C++
     namespace NS
     {
         class T{};
         void f(T);
     }
     NS::T parm;
     int main()
     {
         f(parm);
     }
     #+END_SRC C++
  2. 所有的函数(包括自由函数,非类的成员函数)也可以在逻辑上看成是类X的一部分(它们可以看作是类X接口的一部分),如果它满足:
     * 使用了类X
     * 与X同时被定义(在同一个头文件/同一个命名空间中)
  3. 如果在客户代码中定义了一个使用类X的函数,并且这个函数与X所在的命名空间(不是类空间!),并且这个函数与X所在的命名空间中的一个函数原型相匹配,那么这个函数的调用将出现二义性
     #+BEGIN_SRC C++
     namespace A
     {
         class X{};
         void f(X);
     }
     namespace B
     {
         void f(A::X);
         void g(A::X param)
         {
             f(param)  //二义性:是A::f还是B::f?
         }
     }
     #+END_SRC
  4. 根据接口规则,成员函数与类的关系要强于非成员函数与类的关系,例如
     #+BEGIN_SRC C++
     namespace A
     {
         class X{};
         void f(X);
     }
     class B
     {
         void f(A::X);
         void g(A::X param)
         {
             f(param)  //不存在二义性,使用B::f,因为成员函数与类的关系更强于非成员函数与类的关系
         }
     }
     #+END_SRC
  5. 从接口规则中可以推断出如果A和B是两个类,并且f(A,B)是一个自由函数,那么
     * 如果A和f同时被定义,那么f就是A的一部分,因此A将依赖于B
     * 如果B和f同时被定义,那么f就是B的一部分,因此B将依赖于A
     * 如果A,B和f同时被定义,那么f即是A的一部分,也是B的一部分,因此A和B相互依赖
  6. 派生类中的名字隐藏问题在所有的嵌套作用域中也同样存在,其中包括命名空间.
  7. 当在基类/派生类的名字隐藏中遇到这样的问题时,可以有两种解决方案:
     * 让调用代码明确第指出它想调用的函数
     * 通过using申明语句使它向调用的函数在正确的作用域中是可见的.
  8. 正确地使用命名空间.如果将一个类放入命名空间,那么同时要保证将这个类的所有辅助函数和运算符函数也放入相同的命名空间.否则,你将在代码中发现奇怪的结果.
* 内存管理
  1. operator new和operator delete永远都是静态成员函数!,因此最好显示第将这两个函数声明为静态函数,虽然C++并不会强制要求显式第使用static
  2. operator new和operator delete因为是一个静态函数,因此不能成为虚函数,但从行为上来看它们却像是虚函数,子类会调用正确的operator new和operator delete函数
  3. C++规定:传递给operator delete[]的指针的静态类型与动态类型必须是相同的.因此
     #+BEGIN_SRC C++
     B* pb = new D[ 100 ];
     delete[] pb
     //这段代码的行为是未定义的
     #+END_SRC
     而对operator delete和operator new,operator new[ ]则并无此限制.
     因此,永远都不要通过多态的方式处理数组
  4. const auto_ptr意味着永远不会失去所有权,因此对一个const auto_ptr进行拷贝是非法的(auto_ptr的拷贝函数参数为非const引用).
* 对象标识
  1. 在编写拷贝赋值运算函数时,永远都不要指望能够通过对自我赋值进行检测来保证函数的正确性(当类operator&可以被重载);应该在拷贝赋值运算符函数中使用"创建临时对象并进行交换"的惯用法,折中方法不仅是异常安全的,而且在处理自我赋值时也是安全的.
  2. 可以将自我赋值检测作为一种优化手段,以避免不必要的工作,这也是正确的做法
  3. 在构造函数中进行自我赋值的检测是无意义的,因为我们的对象还在构造过程中,因此对象other与我们的对象不可能相等
  4. 在有些情况下,指针的比较运算与大多数人想象的不一样
     * 对字符串常量进行比较运算的行为未定义.因为C++标准明确指出,编译器可以在重叠的内存中存储字符串
     * 有时候,在通过内部的运算符<,<=,>,>=来比较裸指针时,不能得到明确定义的结果.
* 控制流程
  1. 在编译单元之间,全局变量(包括类的静态成员)的初始化顺序是未定义的
     *避免使用全局变量或静态变量.如果必须使用,那么一定要特别注意这些变量的初始化顺序*
  2. 在多重继承中,子类按照从左到右顺序对非虚基类进行初始化,为了防止一个基类初始化时用到了另一个基类,另一个基类还未初始化的情况出现:
     *在构造函数的初始值列表中,应该把基类按照它们在类定义中出现的先后顺序进行排序*
  3. 成员变量是按照它们在类定义中出现的先后顺序来进行初始化的:
     *在构造函数的初始值列表中,应该把成员变量按照它们在类定义中出现的先后顺序进行排序*
  4. 对函数参数进行求值的顺序是未定义的:
     *在编写代码时,永远都不应该依赖函数参数的求值顺序*
  5. assert()函数会在release版本中被去掉:
     *永远不要使代码的执行依赖于函数assert()的调用*
