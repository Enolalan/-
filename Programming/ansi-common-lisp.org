#+TITLE: ansi-common-lisp
#+AUTHOR: DarkSun
#+OPTIONS: ^:{}
* Lisp对函数的求值顺序为从左至右对实参求值
* 列表
** 集合
   * (member-if PREDICATE LIST [keyword value])

	 List中的元素,是否有符合PREDICATE的

	 支持的keyword有:key

   * (adjoin item list [keyword value])

	 当list中没有item时,才将item加入list中

	 支持的keywrod有:test,:test-not,:key

   * (union list1 list2 [keyword value])
	 
	 两个集合的并集

   * (intersection list1 list2 [keyword value])
	 
	 两个集合的交集

   * (set-difference list1 list2 [keyword value])
	 
	 求补集
** 序列

   * (subseq seq start &optonal end)

	 复制seq的一部分,范围为[start,end)
	 #+BEGIN_SRC lisp
       (subseq '(a b c d) 1 2)                 ;=>(b)
       (subseq '(a b c d) 1 )                  ;=>(b c d)
	 #+END_SRC

   * (copy-list list)

	 返回list的拷贝

   * (reverse list)
   
	 返回翻转的list

   * (sort list predicate)

	 根据predicate来对list中的元素进行排序,该函数会破坏list的原始值

	 若希望原list的值不变,使用copy-list函数

   * (some predicate seq1...seqN)

	 seqs中是否有元素能符合(predicate element1...elementN)

   * (every predicate seq1...seqN)

	 seqs中是否所有元素都符合(predicate element1...elementN)
** 栈
   * (push obj list)

	 压入一个obj到list的第一个元素位置. 这里的list其实是一个generialized variable
	 #+BEGIN_SRC lisp
       (setf x '(b))                           ; (B)
       (push 'a x)                             ; (A B)
       x                                       ; (A B)
	 #+END_SRC

   * (pop list)

	 返回list的第一个元素,并从list中移除该元素
	 #+BEGIN_SRC lisp
       (setf y x)                              ; (A B)
       (pop x)                                 ; (A)
       x                                       ; (B)
       y                                       ; (A B)
	 #+END_SRC

   * (pushnew obj list [keyword value])

	 类似push,但是实现时用adjoin代替了cons,即它只push未见的obj
	 #+BEGIN_SRC lisp
       (let ((x '(a b)))
         (pushnew 'c x)
         (pushnew 'a x)
         x)
       ;; (C A B)
	 #+END_SRC
* 特殊数据结构
** 数组
   使用字面常量来表示数组,可以使用#Na这个语法,其中n为数组的维度.
   #+BEGIN_SRC lisp
     #2a((b nil nil) (nil nil nil))
   #+END_SRC

   * (make-array dimen-list [keyword value])

	 创建数组,其中dimen-list为表示数组维度的list.
	 #+BEGIN_SRC lisp
       (setf arr (make-array '(2 3) :initial-element nil))
       ;; #<Simple-Array T (2 3) BFC4FE>
	 #+END_SRC

	 使用:element-type参数指定数组包含值的种类,这种数组被成为特化数值.

	 若想创建一维数组,则dimen-list可以直接使用整数代替
	 #+BEGIN_SRC lisp
       (setf vec (make-array 4 :initial-element nil))
       ;; #(NIL NIL NIL NIL)
	 #+END_SRC

	 从未初始化的数组中取元素,结果为未定义

   * (vector object1...objectN)
	 
	 vector即一维数组,可以通过该方法直接构造由objectN组成的vector
	 #+BEGIN_SRC lisp
       (vector "a" 'b 3)
       ;; #("a" b 3)
	 #+END_SRC

   * (aref array idx1...idxN)

	 取出数组中的元素,idxN以0为开始
	 #+BEGIN_SRC lisp
       (aref arr 0 0)
       ;; NIL
	 #+END_SRC

   * (svref vector idx)

	 类似aref,但专用于从vector中取值.idx从0开始

   * (setf (aref array idx1...idxN) value)

	 替换数组中的某个元素.
** 字符与字符串
   字符用#\c来表示.

   * (char-code char)
  
	 返回char相关的数组

   * (code-char code)

	 返回code相关的字符

   * (char< c1 c2) / (char<= c1 c2) / (char= c1 c2) / (char>= c1 c2) / (char> c1 c2) / (char/= c1 c2)
	 
	 字符比较

   * (aref str idx)

	 将str当array来看待

   * (char str idx)

	 取str中第idx个的char,比aref更快

   * (equal str1 str2)

	 比较字符串,大小写敏感
	 #+BEGIN_SRC lisp
       (equal "fred" "fred")
       ;; T
       (equal "fred" "Fred")
       ;; NIL
	 #+END_SRC

   * (string-equal str1 str2)

	 忽略大小写比较字符串
	 #+BEGIN_SRC lisp
       (string-equal "fred" "Fred")
       ;; T
	 #+END_SRC

   * (format nil fmt object1...objectN)

	 参照格式fmt,返回字符串

   * (concatenate type sequence1...sequencesN)

	 将sequences按type指定的格式连接起来
	 #+BEGIN_SRC lisp
       (concatenate 'string "not " "to worry")
       ;; "not to worry"
	 #+END_SRC
** 序列

   序列包括list,array和string. 

   许多序列函数接收一个或多个keyword:
   | 参数      | 用途                 | 缺省值   |
   |-----------+----------------------+----------|
   | :key      | 应用至每个元素的函数 | identity |
   | :test     | 作来比较的函数 | eql      |
   | :from-end | 若为真，反向工作。 | nil      |
   | :start    | 起始位置         | 0        |
   | :end      | 若有给定，结束位置。 | nil      |

   * (position object seq [keyword value])

	 获取object在seq中的位置
	 #+BEGIN_SRC lisp
       (position #\a "fantasia")
       ;; 1
       (position #\a "fantasia" :start 3 :end 5)
       ;; 4
       (position #\a "fantasia" :from-end t)
       ;; 7
       (position 'a '((c d) (a b)) :key #'car)
       ;; 1
       (position '(a b) '((a b) (c d)))
       ;; NIL
       (position '(a b) '((a b) (c d)) :test #'equal)
       ;; 0
       (position 3 '(1 0 7 5) :test #'<)       ;:test 关键字参数可以是任何接受两个实参的函数。举例来说，给定 < ，我们可以询问第一个使第一个参数比它小的元素位置
       ;; 2
	 #+END_SRC

   * (position-if predicate seq [keyword value])

	 找到seq中满足predicate的元素位置

   * (find item seq [keyword value])

	 寻找seq中第一个item,并返回该item. 若没找到则返回nil

   * (find-if predicate seq [keyword value])

	 寻找seq中第一个符合predicate的item,并返回该item,若没找到则返回nil

   * (remove elt seq [keyword value]) / (remove-if predicate seq [keyword value]) / (remove-duplicates seq [keyword value])

   * (reduce fn seq)
** 结构体
   * (defstruct NAME SLOT1...SLOTN)

	 其中NAME可以使结构名称symbol或(结构名称symbol (keyword1 value1)...(keyword2 value2))这种格式
	 #+BEGIN_SRC lisp
       (defstruct (point (:conc-name p)
                         (:print-function print-point))
         (x 0)
         (y 0))

       (defun print-point (p stream depth)
         (format stream "#<~A, ~A>" (px p) (py p)))
	 #+END_SRC
     :conc-name指定了要放在字段前面的名字，并用这个名字来生成存取函数。预设是 point- ；现在变成只有 p 。不使用缺省的方式使代码的可读性些微降低了，只有在需要常常用到这些存取函数时，你才会想取个短点的名字。

     :print-function是在需要显示结构出来看时，指定用来打印结构的函数 ── 需要显示的情况比如，要在顶层显示时。这个函数需要接受三个实参：要被印出的结构，在哪里被印出，第三个参数通常可以忽略。 [2] 我们会在 7.1 节讨论流（stream）。现在来说，只要知道流可以作为参数传给 format 就好了。

	 其中参数SLOTN可以是属性名symbol或(属性名symbol 默认值form)这种格式
	 #+BEGIN_SRC lisp
       (defstruct polemic
         (type (progn
                 (format t "What kind of polemic was it? ")
                 (read)))
         (effect nil))

	 #+END_SRC
** HashTable
   * (make-hash-table &rest KEYWORD-ARGS)

	 创建hash table

	 支持的keyword有:test :size

   * (gethash key hashtable)

	 获取hashtable中key对应的value

	 返回两个值,第一个值为对应value,第二个值为表示是否找到key的标识

   * (remhash key hashtable)

	 移除hashtable中对应key的entry

   * (maphash fn hashtable)

	 fn接收两个参数,hashtable中的key和value

	 maphash返回nil
* 控制结构
** Blocks
   * (progn bodys...)

   * (block NAME &rest BODYS)

	 参数NAME为symbol标识该block的名称. 

	 在bodys中可以使用(return-from NAME &optional RESULT)退出该block
	 #+BEGIN_SRC lisp
       (block head
         (format t "Here we go.")
         (return-from head 'idea)
         (format t "We'll never see this."))
       ;; Here we go.
       ;; IDEA
	 #+END_SRC

	 参数NAME还可以是nil,这时可以使用(return &optional result)来返回该block
	 #+BEGIN_SRC lisp
       (block nil
         (return 27))
       ;; 27
	 #+END_SRC

     *许多接受一个表达式主体的 Common Lisp 操作符，皆隐含在一个叫做 nil 的区块里。*
     比如，所有由 do 构造的迭代函数
	 #+BEGIN_SRC lisp
       (dolist (x '(a b c d e))
         (format t "~A " x)
         (if (eql x 'c)
             (return 'done)))
       ;; A B C
       ;; DONE
	 #+END_SRC

	 *使用 defun 定义的函数主体，都隐含在一个与函数同名的区(对elisp不成立,elisp中可以使用cl-defun代替)*
	 #+BEGIN_SRC lisp
       (defun foo ()
         (return-from foo 27))
	 #+END_SRC
** Context

   * let / let*
     概念上说，一个 let 表达式等同于函数调用. 即
     #+BEGIN_SRC lisp
       (let ((x 7)
             (y 2))
         (format t "Number")
         (+ x y))
       ;; 等价于
       (funcall (lambda (x y) (format t "Number") (+ x y))
                7
                2)
     #+END_SRC
	 
	 一个let*等于嵌套的let

   * (destructuring-binding ARGS-PATTERN EXPR &rest bodys)

	 该宏中的ARGS-PATTERN与EXPR需要有相同的结构. 它将EXPR中对应的结构与ARGS-PATTERN中的参数一一对应.
	 #+BEGIN_SRC lisp
       (destructuring-bind (w (x y) . z) '(a (b c) d e)
         (list w x y z))
       ;; (A B C (D E))
	 #+END_SRC

** 条件判断

** 提前退出
   
   * 在block中可以使用return/return-from退出

   * 使用catch throw语句

	 一个 catch 表达式接受一个标签（tag），标签可以是任何类型的对象，伴随着一个表达式,表达式中一个带有特定标签的 throw 会导致 catch 表达式直接返回:
	 #+BEGIN_SRC lisp
       (defun super ()
         (catch 'abort
           (sub)
           (format t "We'll never see this.")))

       (defun sub ()
         (throw 'abort 99))

       (super)
       ;; 99
	 #+END_SRC

   * error语句可以直接中断程序的正常执行

   * 使用unwind-protect来保证程序被打断时依然执行清理操作

	 一个 unwind-protect 接受任何数量的实参，并返回第一个实参的值。然而即便是第一个实参的求值被打断时，剩下的表达式仍会被求值
	 #+BEGIN_SRC lisp
       (setf x 1)
       ;; 1
       (catch 'abort
         (unwind-protect
             (throw 'abort 99)
           (setf x 2)))
       ;; 99

       x
       ;; 2
	 #+END_SRC

* 函数
** 破坏性函数
  | 安全              | 破坏性            |
  | append            | nconc             |
  | reverse           | nreverse          |
  | remove            | delete            |
  | remove-if         | delete-if         |
  | remove-duplicates | delete-duplicates |
  | subst             | nsubst            |
  | subst-if          | nsubst-if         |
  | union             | nunion            |
  | intersection      | nintersection     |
  | set-difference    | nset-difference   |
** 全局函数
   
   * (fboundp symbol)

	 symbol是否与某个function相关联

   * (symbol-function symbol)

	 返回与该symbol相关联的function

   * 通过setf和symbol-function可以为函数分配名称

	 #+BEGIN_SRC lisp
       (setf (symbol-function 'add2)
             #'(lambda (x) (+ x 2)))
       (add2 1)
       ;; 3
	 #+END_SRC

*** defun

	若defun的函数名称为列表(setf f),则你定义了当 setf 第一个实参是 f 的函数调用时，所会发生的事情

	在函数名是这种形式 (setf f) 的函数定义中，第一个实参代表新的数值，而剩余的实参代表了传给f的参数

	现在任何 primo 的 setf ，会是上面后者的函数调用:
	#+BEGIN_SRC lisp
      (defun primo (lst) (car lst))

      (defun (setf primo) (val lst)
        (setf (car lst) val))

      (let ((x (list 'a 'b 'c)))
        (setf (primo x) 480)
        x)
      ;; (480 b c)
	#+END_SRC

	* 通过调用documentation可以获取函数的文档字符串
	  
	  #+BEGIN_SRC lisp
        (defun foo (x)
          "Implements an enhanced paradigm of diversity"
          x)
        (documentation 'foo 'function)
        ;; "Implements an enhanced paradigm of diversity"
	  #+END_SRC
** 局部函数
   局部函数可以使用labels来定义,它是一种像是給函数使用的let. 只是它的第一个实参是新局部函数的定义,而不是变量说明.

   #+BEGIN_SRC lisp
	 (labels ((add10 (x) (+ x 10))
			  (consa  (x) (cons 'a x)))
	   (consa (add10 3)))
	 ;; (A . 13)
   #+END_SRC

   与let不同的是,由 labels 表达式所定义的局部函数，可以被其他任何在此定义的函数引用，包括自己。所以这样定义一个递归的局部函数是可能的：

   #+BEGIN_SRC lisp
	 (labels ((len (lst)
				   (if (null lst)
					   0
					 (+ (len (cdr lst)) 1))))
	   (len '(a b c)))
	 ;; 3
   #+END_SRC

   *do表达式可以被解释成调用递归函数* 这样形式的 do :

   #+BEGIN_SRC lisp
	 (do ((x a (b x))
		  (y c (d y)))
		 ((test x y) (z x y))
	   (f x y))
	 ;; 等同于
	 (labels ((rec (x y)
				(cond ((test x y)
					   (z x y))
					  (t
					   (f x y)
					   (rec (b x) (d y))))))
	   (rec a c))
   #+END_SRC
** 参数列表
*** 可选参数

	&optional之后的参数都是可选参数,默认为nil

	也可以为可选参数设置默认值,格式为(&optional (参数 默认值)) 或 (&optional (参数 默认值 参数传递标志))
	#+BEGIN_SRC lisp
      (defun philosoph (thing &optional (property 'fun))
        (list thing 'is property))

      (philosoph 'death)
      ;; (death is fun)
	#+END_SRC
	
	参数传递标志,用于标识是否传递了实参給参数,一般参数传递标志的名称为参数名称后结`-suppiled-p'

*** 剩余参数

	&rest后的参数接收任意多的参数,并将他们组合成list

*** 关键字参数

	&key后面的参数,会作为关键字参数. 关键字参数缺省值也为nil,但可以在形参列表中明确地指定缺省值
	#+BEGIN_SRC lisp
      (defun keylist (a &key x y z)
        (list a x y z))
      ;; KEYLIST
      (keylist 1 :y 2)
      ;; (1 NIL 2 NIL)
      (keylist 1 :y 3 :x 2)
      ;; (1 2 3 NIL)
	#+END_SRC

	&key后的关键字参数还可以是一个格式为`(参数 默认值 参数传递标志)'的list,其中参数传递标志当该key参数被传值时为t,key参数未传值时为nil

	destructuring-bind宏也支持关键字参数:
	#+BEGIN_SRC lisp
      (destructuring-bind ((&key w x) &rest y) '((:w 3) a)
        (list w x y))
      ;; (3 NIL (A))
	#+END_SRC
	
	*一般情况下,不要让关键字参数与可选参数/剩余参数混搭,这样会产生很奇怪的后果*

** 函数内变量作用域
*** 闭包

   	我们可以产生共享变量的数个闭包。下面我们定义共享一个计数器的两个函数:
   	#+BEGIN_SRC lisp
      (let ((counter 0))
       	(defun reset ()
          (setf counter 0))
       	(defun stamp ()
          (setf counter (+ counter 1))))
   	#+END_SRC

*** 动态作用域

	common lisp中一个在let内的局部变量,默认处于lexical scope下, 这时符号引用到上下文中符号名字被定义时的变量上.

	而动态作用域，我们在环境中函数被调用的地方寻找变量。要使一个变量是动态作用域的，我们需要在任何它出现的上下文中声明它是special(该变量我们称之为特殊变量)。
	#+BEGIN_SRC lisp
	  (let ((x 10))
		(defun foo ()
		  (declare (special x))               ;声明x处于动态作用域下
		  x))
	#+END_SRC

	则函数内的 x 就不再引用到函数定义里的那个词法变量，但会引用到函数被调用时，当下所存在的任何特别变量 x :
	#+BEGIN_SRC lisp
	  (let ((x 20))
		(declare (special x))
		(foo))
	  ;; 20
	#+END_SRC
   
	通过在顶层调用 setf 来配置全局变量，是隐式地将变量声明为特殊变量:
	#+BEGIN_SRC lisp
	  (setf x 30)
	  ;; 30
	  (foo)
	  ;; 30
	#+END_SRC
	在一个文件里的代码，如果你不想依赖隐式的特殊声明，可以使用defparameter 取代，让程序看起来更简洁。
** 编译

   * (compiled-function-p fn)

	 参数fn是否为已编译的函数

   * (compile fn)

	 编译函数fn

	 当被编译的函数fn包含内部函数fn-in时,fn-in也会被编译. 例如:
	 #+BEGIN_SRC lisp
       (defun make-adder (n)
         (lambda (x)
           (+ x n)))
       ;; make-addr
       (compile 'make-adder)
       ;; MAKE-ADDER
       (compiled-function-p (make-adder 2))
       ;; T
	 #+END_SRC

   * (compile-file file)

	 编译整个file

   * 
* 流
** 字符流
*** 使用文件作为流
**** open
	 开启一个文件的基本函数是 open 。它接受一个路径名以及大 量的选择性关键字参数:

	 * :direction说明了输入还是输出流
	   * :input
	   * :output
	   * :io

	 * if-exists说明了创建输出流时如果文件已存在怎么办
	   * :supersede表示覆盖

	 #+BEGIN_SRC lisp
       (setf str (open path :direction :output
                       :if-exists :supersede))
       ;; #<Stream C017E6>
	 #+END_SRC

	 路径名是一种指定一个文件的可移植方式。路径名包含了六个部分：host、device、directory、name、type 及 version。
	 你可以通过调用 make-pathname 搭配一个或多个对应的关键字参数 来产生一个路径。在最简单的情况下，你可以只指明名字，让其他的部分留为缺省：
	 #+BEGIN_SRC lisp
       (setf path (make-pathname :name "myfile"))
       ;; #P"myfile"
	 #+END_SRC
**** with-open-file宏
	 (with-open-file (stream path [keyword value]) bodys)

	 创建一个stream指向path文件,提供給bodys中使用
*** 输入流函数
**** read-line

	 (read-line &optional stream error default-value)

	 读取stream中的一行内行作为字符串返回

**** read

	 (read &optional stream error default-value)

	 读取stream中的一个lisp object

**** read-from-string
	 (read-from-string str &optional error default-value)

	 从str中读取一个lisp object.

	 参数error表示读取到字符串结尾时是否报错.

	 参数default-value表示若读取到文件结尾时不报错,则返回哪个值.

	 该函数返回两个值,第一个值为读取到的object. 第二个值为停止读取字符串的位置

**** read-char

	 从字符串中读取一个char

**** peek-char

	 从字符串中读取一个char,但该char不会从字符串流中移除
	
*** 输出流函数
	
**** prin1

	 以程序可读的形式产生输出.例如 prin1 会印出字符串左右的双引号
	 #+BEGIN_SRC lisp
       (prin1 "Hello")
       ;; "Hello"
       ;; "Hello"
	 #+END_SRC

**** princ

	 以人可读的格式产生输出. 例如princ不会打印出字符串左右的双引号
	 #+BEGIN_SRC lisp
       (princ "Hello")
       ;; Hello
       ;; "Hello"
	 #+END_SRC

**** terpri

	 输出eof

**** format
	 
** 二进制流
   一个二进制流是一个整数的来源及/或终点，而不是字符。
   你通过指定一个整数的子类型来创建一个二进制流 ── 当你打开流时，通常是用 unsigned-byte ── 来作为 :element-type 的参数。

   关于二进制流的 I/O 函数仅有两个，read-byte 以及 write-byte 
   #+BEGIN_SRC lisp
     (defun copy-file (from to)
       (with-open-file (in from :direction :input
                           :element-type 'unsigned-byte)
                       (with-open-file (out to :direction :output
                                            :element-type 'unsigned-byte)
                                       (do ((i (read-byte in nil -1)
                                               (read-byte in nil -1)))
                                           ((minusp i))
                                         (declare (fixnum i))
                                         (write-byte i out)))))
     ;; 仅通过指定 unsigned-byte 给 :element-type ，你让操作系统选择一个字节 (byte)的长度。举例来说，如果你明确地想要读写 7 比特的整数，你可以使用：(unsigned-byte 7)
   #+END_SRC
* 符号
** 符号名称  
   以使用(symbol-name symbol)获取symbol的名称字符串

   缺省情况下，Common Lisp 在读入时，会把符号名字所有的英文字母都转成大写。代表 Common Lisp 缺省是不分大小写的：
   #+BEGIN_SRC lisp
     (eql 'abc 'Abc)
     ;; T
     (CaR '(a b c))
     ;; A
   #+END_SRC

   若symbol名字包含空白，或其它可能被读取器认为是重要的字符的符号，要用特殊的语法来引用。

   任何存在垂直杠 (vertical bar)之间的字符序列将被视为符号。可以如下这般在符号的名字中，放入任何字符：
   #+BEGIN_SRC lisp
     (list '|Lisp 1.5| '|| '|abc| '|ABC|)
     ;; (|Lisp 1.5| || |abc| ABC)
   #+END_SRC
   当这种符号被读入时，不会有大小写转换

   NOTE: *垂直杠是一种表示符号的特殊语法。它们不是符号的名字之一*
   #+BEGIN_SRC lisp
     (symbol-name '|a b c|)
     ;; "a b c
   #+END_SRC
	 
   如果想要在符号名称内使用垂直杠，可以放一个反斜线在垂直杠的前面
** 属性列表

   在 Common Lisp 里，每个符号都有一个属性列表（property-list）或称为 plist 。

   * (get symbol property)

     返回在符号的属性列表中，与键值相关的数值：
     #+BEGIN_SRC lisp
     (get 'alizarin 'color)
     ;; NIL
     #+END_SRC
   
   * (setf (get symbol property) newValue)
   
	 为symbol的property赋值
     #+BEGIN_SRC lisp
     (setf (get 'alizarin 'color) 'red)
     ;; RED
     (get 'alizarin 'color)
     ;; RED
     #+END_SRC

   * (symbol-plist symbol)

	 返回symbol中的plist
** 包(Package)

   概念上来说，包是将名字映射到符号的符号表（symbol-tables）。
   每个普通的符号都属于一个特定的包。
   符号属于某个包，我们称为符号被包所有（intern）。
   函数与变量用符号作为名称。包借由限制哪个符号可以访问来实现模块化（modularity），也是因为这样，我们才可以引用到函数与变量。
   
   在第一次输入一个新符号的名字时，Lisp 会产生一个新的符号对象，并将它归到到当下的包所有（缺省是 common-lisp-user 包)。

   但也可以通过给入字符串与选择性包参数给 intern 函数，来捕获一个名称为字符串名的符号:

   * (intern symbol-name &optional package)

	 创建名为symbol-name的symbol.

	 该函数返回两个值:第一个值是创建的symbol. 第二个值表示该symbol是否早就存在于package中
	 #+BEGIN_SRC lisp
       (intern "RANDOM-SYMBOL")
       ;; RANDOM-SYMBOL
       ;; NIL
	 #+END_SRC

   * 引用其他包里的符号

	 语法为:`package:symbol'

   * 使用defpackage定义package
	 
	 #+BEGIN_SRC lisp
       (defpackage "MY-APPLICATION"            ;定义新包名为my-application
         (:use "COMMON-LISP" "MY-UTILITIES")   ;继承了两个包: common-lisp 与 my-utilities ，这代表着可以不需要用包修饰符（package qualifiers）来存取这些包所导出的符号。
         (:nicknames "APP")                    ;创建昵称app,别的包可以这样引用到这些符号，比如 app:win 。
         (:export "WIN" "LOSE" "DRAW"))        ; my-application 包本身只输出三个符号: WIN 、LOSE以及DRAW
	 #+END_SRC

   * 使用in-package切换当前默认包
	 #+BEGIN_SRC lisp
       (in-package my-application)
	 #+END_SRC
** 关键字

   在 keyword包中的符号 (称为关键字)有两个独特的性质：它们总是对自己求值，以及可以在任何地方引用它们，如 :x 而不是 keyword:x
   
   为什么使用关键字而不用一般的符号？因为关键字在哪都可以存取。一个函数接受符号作为实参，应该要写成预期关键字的函数。举例来说，这个函数可以安全地在任何包里调用:
   #+BEGIN_SRC lisp
     (defun noise (animal)
       (case animal
         (:dog :woof)
         (:cat :meow)
         (:pig :oink)))
   #+END_SRC
** 符号与变量

   Lisp 有一件可能会使你困惑的事情是，符号与变量的从两个非常不同的层面互相关联。
   当符号是特别变量（special variable）的名字时，变量的值存在符号的 value 栏位。symbol-value函数引用到那个栏位，所以在符号与特殊变量的值之间，有直接的连接关系。

   而对于词法变量（lexical variables）来说，事情就完全不一样了。
   一个作为词法变量的符号只不过是个占位符（placeholder）。
   编译器会将其转为一个寄存器（register）或内存位置的引用位址。
   在最后编译出来的代码中，我们无法追踪这个符号 (除非它被保存在调 试器「debugger」的某个地方)。因此符号与词法变量的值之间是没有连接的；只要一有值，符号就消失了。
* 数字

  Common Lisp 提供了四种不同类型的数字：整数、浮点数、比值与复数。
  * 整数写成一串数字：如 2001 。
  * 浮点数是可以写成一串包含小数点的数字，如 253.72 ，或是用科学表示法，如 2.5372e2 。
  * 比值是写成由整数组成的分数：如 2/3 。
  * 复数 a+bi 写成 #c(a b) ，其中 a 与 b 是任两个类型相同的实数。

  谓词 integerp 、 floatp 以及 complexp 针对相应的数字类型返回真

  常量most-positive-fixnum 与 most-negative-fixnum 表示一个实现不使用大数所可表示的最大与最小的数字大小

* 宏
  作为一个规则，写成宏是因为你不能将它写成函数。
  但这个规则有几个例外。
  有时候你或许想要定义一个操作符来作为宏，好让它在编译期完成它的工作。
  * 使用coerce可以将列表转换为代码

	#+BEGIN_SRC lisp
      (coerce '(lambda (x) x) 'function)
      ;; #<Interpreted-Function BF9D96>
	#+END_SRC

  * 使用compile将列表转换为代码

	而如果你将 nil 作为第一个参数传给 compile ，它会编译作为第二个参数传入的 lambda 表达式。
	#+BEGIN_SRC lisp
      (compile nil '(lambda (x) (+ x 2)))
      ;; #<Compiled-Function BF55BE>
      ;; NIL
      ;; NIL
	#+END_SRC

  * eval将列表当代码来执行
	#+BEGIN_SRC lisp
      (eval '(+ 1 2))
      ;; 3
	#+END_SRC

  * 宏的实现

	对一个宏的调用,实际上是被转换为一个函数的调用
	#+BEGIN_SRC lisp
      (defmacro null! (x)
        (list 'setf x nil))

      (null! x)

      ;; 其实就是
      (setf expr '(null! x))
      (lambda (expr)
        (apply #'(lambda (x) (list 'setf x nil))
               (cdr expr)))
	#+END_SRC

	* 定义宏时,要注意变量捕获的问题

      使用gensym来生产内部变量名
	  #+BEGIN_SRC lisp
        (defmacro ntimes (n &rest body)
          (let ((g (gensym)))
            `(do ((,g 0 (+ ,g 1)))
                 ((>= ,g ,n))
               ,@body)))
	  #+END_SRC

	* 定义宏时,要注意多重求值的问题

	  因此要使用一个内部变量,在任何迭代前都存储参数的值,这又需要另一个gensym
	  #+BEGIN_SRC lisp
        (defmacro ntimes (n &rest body)
          (let ((g (gensym))
                (h (gensym)))
            `(let ((,h ,n))
               (do ((,g 0 (+ ,g 1)))
                   ((>= ,g ,h))
                 ,@body))))
	  #+END_SRC

	* 使用macroexpand-1可以查看宏扩展后的表达式

	  #+BEGIN_SRC lisp
        (pprint (macroexpand-1 '(cond (a b)
                                      (c d e)
                                      (t f))))
        ;; (IF A
        ;;     B
        ;;     (IF C
        ;;         (PROGN D E)
        ;;         F))
	  #+END_SRC

** 通用化引用
   
   由于一个宏调用可以直接在它出现的地方展开成代码，任何展开为 setf 表达式的宏调用都可以作为 setf 表达式的第一个参数。
   举例来说，如果我们定义一个 car 的同义词，
   #+BEGIN_SRC lisp
     (defmacro cah (lst) `(car ,lst))
   #+END_SRC

   然后因为一个 car 调用可以是 setf 的第一个参数，而 cah 一样可以:
   #+BEGIN_SRC lisp
     (let ((x (list 'a 'b 'c)))
       (setf (cah x) 44)
       x)
     ;; (44 B C)
   #+END_SRC

   但是撰写一个展开成一个 setf 表达式的宏是另一个问题，是一个比原先看起来更为困难的问题。看起来也许你可以这样实现 incf:
   #+BEGIN_SRC lisp
     (defmacro incf (x &optional (y 1)) ; wrong
       `(setf ,x (+ ,x ,y)))
   #+END_SRC

   但这是行不通的。这两个表达式不相等:
   #+BEGIN_SRC lisp
     (setf (car (push 1 lst)) (1+ (car (push 1 lst))))

     (incf (car (push 1 lst)))
   #+END_SRC
   如果 lst 是 nil 的话，第二个表达式会设成 (2) ，但第一个表达式会设成 (1 2) 。

   Common Lisp 提供了 define-modify-macro 作为写出对于 setf 限制类别的宏的一种方法它接受三个参数: 宏的名字，额外的参数 (隐含第一个参数 place)，以及产生出 place 新数值的函数名。
   所以我们可以将 incf 定义为
   #+BEGIN_SRC lisp
     (define-modify-macro our-incf (&optional (y 1)) +)
   #+END_SRC

   另一版将元素推至列表尾端的 push 可写成：
   #+BEGIN_SRC lisp
     (define-modify-macro append1f (val)
       (lambda (lst val) (append lst (list val))))
   #+END_SRC

   后者会如下工作:
   #+BEGIN_SRC lisp
     (let ((lst '(a b c)))
       (append1f lst 'd)
       lst)
     ;; (A B C D)
   #+END_SRC

   顺道一提，push 与 pop 都不能定义为 modify-macros，前者因为 place 不是其第一个参数，而后者因为其返回值不是更改后的对象。
* CLOS
** 创建对象

   1. 使用defclass定义一个类

	  #+BEGIN_SRC lisp
        (defclass class (parent-classes...)
          (slot1...slotN))                      ;CLOS中的slot就是C++中的成员变量
	  #+END_SRC
	  例如:
	  #+BEGIN_SRC lisp
        (defclass circle ()                     ;创建一个circle类,它没有继承任何基类
          (radius center))                      ;circle对象有两个成员变量radius和center

	  #+END_SRC

   2. 使用make-instance函数创建对象

	  #+BEGIN_SRC lisp
        (make-instance class-symbol)
	  #+END_SRC

	  例如
	  #+BEGIN_SRC lisp
        (setf c (make-instance 'circle))
        ;; #<CIRCLE #XC27496>

	  #+END_SRC

** 对象操作

   1. 使用slot-value获取对象成员变量

	  #+BEGIN_SRC lisp
        (slot-value obj slot)
	  #+END_SRC

** 基类

   defclass 接受的第二个参数是一个列出其基类的列表。一个类别继承了所有基类槽的联集
   #+BEGIN_SRC lisp
     (defclass graphic ()
       ((color :accessor graphic-color :initarg :color)
        (visible :accessor graphic-visible :initarg :visible
                 :initform t)))

     (defclass screen-circle (circle graphic) ())
   #+END_SRC
   这里screen-circle的实例会有四个槽，分别从两个基类继承而来

   基类中的:accessor及:initargs参数可以用在子类中:
   #+BEGIN_SRC lisp
     (graphic-color (make-instance 'screen-circle
                                   :color 'red :radius 3))
     ;; RED
   #+END_SRC

   我们也可以为子类定义自己的:initform
   #+BEGIN_SRC lisp
     (defclass screen-circle (circle graphic)
       ((color :initform 'purple)))

     ;; 现在 screen-circle 的实例缺省会是紫色的：

     (graphic-color (make-instance 'screen-circle))
     ;; PURPLE
   #+END_SRC

*** 基类的优先级
	由于CLOS支持多个基类,所有存在基类的优先级问题. 

	优先级以层级最小优先,相同层级的基类,第一个出现的优先.
** slot定义说明

	 传给 defclass 的第三个参数必须是一个槽定义的列表。如上例所示，最简单的槽定义是一个表示其名称的符号。
	 在一般情况下，一个槽定义可以是一个列表，第一个是槽的名称，伴随著一个或多个属性 (property)。
	 属性像关键字参数那样指定。

	 * :accessor

	   通过替一个槽定义一个访问器 (accessor)，我们隐式地定义了一个可以引用到槽的函数，使我们不需要再调用 slot-value 函数.

	   例如
	   #+BEGIN_SRC lisp
		 (defclass circle ()
		   ((radius :accessor circle-radius)
			(center :accessor circle-center)))

		 ;; 那我们能够分别通过 circle-radius 及 circle-center 来引用槽：

		 (setf c (make-instance 'circle))
		 ;; #<CIRCLE #XC5C726>

		 (setf (circle-radius c) 1)
		 ;; 1

		 (circle-radius c)
		 ;; 1

	   #+END_SRC

	 * :writer / :reader

	   通过指定一个 :writer 或是一个 :reader ，而不是 :accessor ，我们可以获得访问器的写入或读取行为

	 * :initform / :initarg

	   要指定一个槽的缺省值，我们可以给入一个 :initform 参数。

	   若我们想要在 make-instance 调用期间就将槽初始化，我们可以用 :initarg 定义一个参数名。
	   #+BEGIN_SRC lisp
		 (defclass circle ()
		   ((radius :accessor circle-radius
					:initarg :radius
					:initform 1)
			(center :accessor circle-center
					:initarg :center
					:initform (cons 0 0))))

		 ;; 现在当我们创建一个 circle 类的实例时，我们可以使用关键字参数 :initarg 给槽赋值，或是將槽的值设为 :initform 所指定的缺省值。

		 (setf c (make-instance 'circle :radius 3))
		 ;; #<CIRCLE #XC2DE0E>
		 (circle-radius c)
		 ;; 3
		 (circle-center c)
		 ;; (0 . 0)
	   #+END_SRC

	 * :allocation

	   该参数说明了slot是对象成员变量(:allocation :instance,默认)还是类成员变量(:allocation :instance)
	   #+BEGIN_SRC lisp
		 (defclass tabloid ()
		   ((top-story :accessor tabloid-story
					   :allocation :class)))

		 ;; 那么如果我们创立两家小报，无论一家的头条是什么，另一家的头条也会是一样的：

		 (setf daily-blab (make-instance 'tabloid)
				 unsolicited-mail (make-instance 'tabloid))
		 ;; #<TABLOID #x302000EFE5BD>
		 (setf (tabloid-story daily-blab) 'adultery-of-senator)
		 ;; ADULTERY-OF-SENATOR
		 (tabloid-story unsolicited-mail)
		 ;; ADULTERY-OF-SENATOR

	   #+END_SRC

	 * :documentation

	   若有给入 :documentation 属性的话，用来作为 slot 的文档字符串。

	 * :type

	   通过指定一个 :type ，你保证一个槽里只会有这种类型的元素
** 通用函数
   一个通用函数 (generic function) 是由一个或多个方法组成的一个函数。方法可用defmethod 来定义，与 defun 的定义形式类似：
   #+BEGIN_SRC lisp
     ;; 参数未特化的版本
     (defmethod combine (x y)
       (list x y))

     ;; 参数特化版本
     (defmethod combine ((ic class1) (top class2))
       (format nil "~A ice-cream with ~A topping."
               (name ic)
               (name top)))
   #+END_SRC
   一个方法的特化指出它是应用至何种类别的参数。刚定义的方法仅能在传给combine的参数分别是class1与classs2的实例时有效
   
   方法特化时,可以对任意个参数作特化,也可以使用lisp内建的类型. 例如
   #+BEGIN_SRC lisp
     (defmethod combine ((x number) (y number))
       (+ x y))
   #+END_SRC

   类似C++的模板,还能对具体的对象作特化,用eql来作决定:
   #+BEGIN_SRC lisp
     (defmethod combine ((x (eql 'powder)) (y (eql 'spark)))
       'boom)
   #+END_SRC

   方法可以像一般 Common Lisp 函数一样有复杂的参数列表(*但只有必要参数可以被特化*),所有组成通用函数方法的参数列表必须是一致的
   参数的数量必须一致，同样数量的选择性参数（如果有的话），要嘛一起使用&rest 或是 &key 参数，或者一起不要用。
   #+BEGIN_SRC lisp
     下面的参数列表对是全部一致的，

     (x)             (a)
     (x &optional y) (a &optional b)
     (x y &rest z)   (a b &key c)
     (x y &key z)    (a b &key c d)

     而下列的参数列表对不是一致的：

     (x)             (a b)
     (x &optional y) (a &optional b c)
     (x &optional y) (a &rest b)
     (x &key x y)    (a)  
   #+END_SRC
** 辅组方法
   
   方法可以通过如 :before ， :after 以及 :around 等辅助方法来增强。
   这称为标准方法组合机制 (standard method combination)。
   在标准方法组合机制里，调用一个通用函数会调用
   #+BEGIN_QUOTE
   
   1. 最具体的 :around 方法，如果有的话。
	  
   2. 否则，依序，

         1. 所有的 :before 方法，从最具体到最不具体。
         2. 最具体的主方法
         3. 所有的 :after 方法，从最不具体到最具体
			
	返回值为 :around 方法的返回值（情况 1）
    或是最具体的主方法的返回值（情况 2）。
   #+END_QUOTE

   辅助方法通过在 defmethod 调用中，在方法名后加上一个修饰关键字 (qualifying keyword)来定义
   #+BEGIN_SRC lisp
     (defclass speaker () ())

     (defmethod speak ((s speaker) string)
       (format t "~A" string))
     (speak (make-instance 'speaker)
            "I'm hungry")
     ;; I'm hungry
     ;; NIL
     (defclass intellectual (speaker) ())

     (defmethod speak :before ((i intellectual) string)
       (princ "Perhaps "))

     (defmethod speak :after ((i intellectual) string)
       (princ " in some sense"))

     (speak (make-instance 'intellectual)
            "I am hungry")
     ;; Perhaps I am hungry in some sense
     ;; NIL
   #+END_SRC

   如果有一个替传入通用函数特别定义的 :around 方法，则优先调用 :around 方法，而其它的方法要看 :around 方法让不让它们被运行。
   一个 :around 或主方法，可以通过调用 call-next-method 来调用下一个方法。
   在调用下一个方法前，它使用 next-method-p 来检查是否有下个方法可调用。  
   #+BEGIN_SRC lisp
     (defclass courtier (speaker) ())

     (defmethod speak :around ((c courtier) string)
       (format t "Does the King believe that ~A?" string)
       (if (eql (read) 'yes)
           (if (next-method-p) (call-next-method))
         (format t "Indeed, it is a preposterous idea. ~%"))
       'bow)

     (speak (make-instance 'courtier) "kings will last")
     ;; Does the King believe that kings will last? yes
     ;; I think kings will last
     ;; BOW
     (speak (make-instance 'courtier) "kings will last")
     ;; Does the King believe that kings will last? no
     ;; Indeed, it is a preposterous idea.
     ;; BOW

     ;; 记得由 :around 方法所返回的值即通用函数的返回值，这与 
     ;; :before 与 :after 方法的返回值不一样。
   #+END_SRC

** defgeneric

* 速度
** 瓶颈规则
   不管是什么实现，关于优化都可以整理出三点规则：

   * 它应该关注瓶颈
   * 它不应该开始的太早
   * 它应该始于算法。
** 编译
   有五个参数可以控制代码的编译方式,权重从0(最不重要)到3(最重要)： 

   * speed (速度)代表编译器产生代码的速度；
   * compilation-speed (编译速度)代表程序被编译的速度；
   * safety (安全) 代表要对目标代码进行错误检查的数量； 
   * space (空间)代表目标代码的大小和内存需求量；
   * debug (调试)代表为了调试而保留的信息量。

   #+BEGIN_SRC lisp
     (declaim (optimize (speed 3)
                        (compilation-speed 0)
                        (safety 0)
                        (debug 0)))
   #+END_SRC
** 类型说明
   在 Common Lisp 中，类型声明完全是可选的。它们可以让程序运行的更快，但(除非错误)不会改变程序的行为。
   
   全局声明以 declaim 伴随一个或多个声明的形式来实现。一个类型声明是一个列表，包含了符号 type ，后跟一个类型名，以及一个或多个变量组成。
   #+BEGIN_SRC lisp
     (declaim (type fixnum *count*))
   #+END_SRC
   在 ANSI Common Lisp 中，可以省略 type 符号，将声明简写为：
   #+BEGIN_SRC lisp
     (declaim (fixnum *count*))
   #+END_SRC
   
   局部声明通过 declare 完成，它接受的参数和 declaim 的一样。声明可以放在那些创建变量的 *代码体* 之前：如 defun 、lambda 、let 、do ，诸如此类。
   #+BEGIN_SRC lisp
     (defun poly (a b x)
       (declare (fixnum a b x))
       (+ (* a (expt x 2)) (* b x)))
   #+END_SRC

   你也可以通过 the 为某个表达式的值声明类型。
   如果我们提前就知道 a 、b 和 x 是足够小的定长数，并且它们的和也是定长数的话，那么可以进行以下声明：
   #+BEGIN_SRC lisp
     (defun poly (a b x)
       (declare (fixnum a b x))
       (the fixnum (+ (the fixnum (* a (the fixnum (expt x 2))))
                      (the fixnum (* b x)))))
   #+END_SRC

   可以通过 make-array 的 :element-type 参数指定数组包含值的种类。这样的数组被称为特化数组(specialized array)。
   
   除了在创建数组时指定元素的类型，你还应该在使用数组的代码中声明数组的维度以及它的元素类型。
   #+BEGIN_SRC lisp
     (declare (type (vector fixnum 20) v))
     ;; 以上代码声明了一个仅含有定长数，并且长度固定为 20 的向量。
   #+END_SRC

   最为通用的数组声明形式由数组类型以及紧接其后的元素类型和一个维度列表构成：
   #+BEGIN_SRC lisp
     (declare (type (simple-array fixnum (4 4)) ar))
   #+END_SRC
** 避免垃圾回收

   * 填充指针

   * map-into

   * 鼓励编译器在栈上分配对象而不是在堆上

     如果你知道只是临时需要某个东西，你可以通过将它声明为 dynamic extent 来避免在堆上分配空间。
	 
	 通过一个动态范围 (dynamic extent)变量声明，你告诉编译器，变量的值应该和变量保持相同的生命期。
	 #+BEGIN_SRC lisp
       (defun our-adjoin (obj lst &rest args)
         (declare (dynamic-extent args))
         (if (apply #'member obj lst args)
             lst
           (cons obj lst)))
	 #+END_SRC
** 与其他语言整合
* Read-Macros
  宏字符 (macro character)的概念，一个对于 read 有特别意义的字符。
  每一个这样的字符，都有一个相关联的函数，这函数告诉 read 当遇到这个字符时该怎么处理。
  你可以变更某个已存在宏字符所相关联的函数，或是自己定义新的宏字符。

  函数 set-macro-character 提供了一种方式来定义读取宏 (read-macros)。
  它接受一个字符及一个函数，因此当 read 碰到该字符时，它返回调用传入函数后的结果。

  Lisp 中最古老的读取宏之一是 ' ，即 quote 。我们可以定义成：
  #+BEGIN_SRC lisp
    (set-macro-character #\'
                         #'(lambda (stream char)
                             (list (quote quote) (read stream t nil t))))

    ;; 当 read 在一个普通的语境下遇到 ' 时，它会返回在当前流和字符上调用这个函数的结果。
  #+END_SRC

  你可以（通过使用 make-dispatch-macro-character ）来定义你自己的派发宏字符（dispatching macro character），但由于 # 已经是一个宏字符，所以你也可以直接使用。
  六个 # 打头的组合特别保留给你使用：#! 、#? 、##[ 、##] 、#{ 、#} 。

  你可以通过调用 set-dispatch-macro-character 定义新的派发宏字符组合，与 set-macro-character 类似，除了它接受两个字符参数外。
  下面的代码定义了#? 作为返回一个整数列表的读取宏。
  #+BEGIN_SRC lisp
        (set-dispatch-macro-character #\# #\?
          #'(lambda (stream char1 char2)
              (list 'quote
                    (let ((lst nil))
                      (dotimes (i (+ (read stream t nil t) 1))
                        (push i lst))
                      (nreverse lst)))))
    ;; 现在 #?n 会被读取成一个含有整数 0 至 n 的列表。
  #+END_SRC
* Packages

  * package-name 返回包的名字，

	#+BEGIN_SRC lisp
      (package-name *package*)
      ;; "COMMON-LISP-USER"
	#+END_SRC

  * find-package 返回一个给定名称的包

	#+BEGIN_SRC lisp
      (find-package "COMMON-LISP-USER")
      ;; #<Package "COMMON-LISP-USER" 4CD15E>
	#+END_SRC

  * 函数 symbol-package 接受一个符号并返回该符号被 interned 的包
	
	#+BEGIN_SRC lisp
      (symbol-package 'sym)
      ;; #<Package "COMMON-LISP-USER" 4CD15E>
	#+END_SRC

  * 要在用户包之外参照到原来的 sym ，我们必须把包的名字加上两个冒号作为前缀：
	 
	#+BEGIN_SRC lisp
      common-lisp-user::sym
	#+END_SRC
    但是使用两个冒号作为包的前缀也是很差的风格。这么做你就违反了包本应提供的模块性。如果你不得不使用一个双冒号来参照到一个符号，这是因为某人根本不想让你用。

  * 使用export使得package中的符号在其他package中可见

	这时可以用单冒号来引用package中的符号
	#+BEGIN_SRC lisp
      (in-package common-lisp-user)
      ;; #<Package "COMMON-LISP-USER" 4CD15E>
      (export 'bar)
      ;; T
      (setf bar 5)
      ;; 5
      (in-package mine)
      ;; #<Package "MINE" 63390E>
      common-lisp-user:bar                    ;此时处于mine package中,使用单冒号引用common-lisp-user的值
      ;; 5
	#+END_SRC
  
    一个包是一个将名字映对到符号的 Lisp 对象。当前的包总是存在全局变量*package*里。当 Common Lisp 启动时，当前的包会是 *common-lisp-user* ，通常称为用户包 (user package)。

  * 通过import将其他package中的符号引入到当前package中

	#+BEGIN_SRC lisp
      (import 'common-lisp-user:bar)
      ;; T
      bar
      ;; 5
	#+END_SRC

  * 使用use-package将其他package中所有exported的符号都引入到当前package中

	#+BEGIN_SRC lisp
      (use-package 'common-lisp-user)
      ;; T
      ;; 现在所有common-lisp-user包所输出的符号，可以不需要使用任何限定符在 mine 包里使用。
	#+END_SRC
* Loop语句
  #+BEGIN_SRC lisp
     (loop for x from 0 to 9
            do (princ x))
    ;; 0123456789
    ;; NIL

    (loop for x = 8 then (/ x 2)
            until (< x 1)
            do (princ x))
    ;; 8421
    ;; NIL

    ;; 可以使用 and 来创建复合的 for 子句，同时初始及更新两个变量：
    (loop for x from 1 to 4
            and y from 1 to 4
            do (princ (list x y)))
    ;; (1 1)(2 2)(3 3)(4 4)
    ;; NIL

    ;; 另一件在迭代代码通常会做的事是累积某种值。举例来说：
    (loop for x in '(1 2 3 4)
            collect (1+ x))
    ;; (2 3 4 5)

    ;; 一个 collect 子句也可以累积值到一个有名字的变量上。下面的函数接受一个数字的列表并返回偶数与奇数列表：
    (defun even/odd (ns)
      (loop for n in ns
            if (evenp n)
               collect n into evens
               else collect n into odds
            finally (return (values evens odds))))

    ;; 一个 sum 子句和一个 collect 子句类似，但 sum 子句累积一个数字，而不是一个列表。要获得 1 至 n 的和，我们可以写：
    (defun sum (n)
      (loop for x from 1 to n
            sum x))
  #+END_SRC
* 状况处理

  * error抛出错误

  * ecase类似case,但没有键值匹配时会抛出错误
	#+BEGIN_SRC lisp
      (ecase 1
        (2 3)
        (4 5))
	#+END_SRC

  * check-type宏接受一个位置，一个类型名以及一个选择性字符串，并在该位置的值不是预期的类型时，捕捉一个可修正的错误
	#+BEGIN_SRC lisp
      (let ((x '(a b c)))
        (check-type (car x) integer "an integer")
        x)
      ;; Error: The value of (CAR X), A, should be an integer.
      ;; Options: :abort, :backtrace, :continue

	#+END_SRC

  * assert接受一个测试表达式以及一个有着一个或多个位置的列表，伴随着你可能传给 error 的参数
	
	#+BEGIN_SRC lisp
      (let ((sandwich '(ham on rye)))
        (assert (eql (car sandwich) 'chicken)
                ((car sandwich))
                "I wanted a ~A sandwich." 'chicken)
        sandwich)
      ;; Error: I wanted a CHICKEN sandwich.
      ;; Options: :abort, :backtrace, :continue
      ;; >> :continue
      ;; New value of (CAR SANDWICH)? 'chicken
      ;; (CHICKEN ON RYE)

	#+END_SRC

  * (ignore-errors &rest bodys)

	bodys若抛出错误,则ignore-errors会直接返回两个值:nil以及捕捉到的状况. 若无错误,则类似progn
	#+BEGIN_SRC lisp
      (defun user-input (prompt)
        (format t prompt)
        (let ((str (read-line)))
          (or (ignore-errors (read-from-string str))
              nil)))
	#+END_SRC
* 注释
  * 4个分号常用于文件头注释

  * 3个分号,通常作为段落注释应用到接下来的一大段代码上

  * 2个分号说明该注释应用于接下来的代码上

  * 1个分号用于行尾注释,说明某个语句
