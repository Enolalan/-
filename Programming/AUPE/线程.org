#+TITLE: 线程
#+AUTHOR: DarkSun
#+CATEGORY: Programming, AUPE
#+DATE: [2015-05-28 周四 12:48]
#+OPTIONS: ^:{}

* 线程的好处
+ 通过为每个事件类型的处理分配单独的线程,能够简化处理异步事件的代码,同步编程模式比异步编程模式简单得多
+ 进程所有信息对该进程的所有线程都是共享的,包括 *可执行的程序文本,程序的全局内存和堆内存,栈以及文件描述符*,而多进程必须通过操作系统的复杂机制才能实现
+ 交互式的程序可以使用多线程改善程序响应.

* 线程的组成部分
** 线程ID
线程ID只在所属的进程环境中有效,其使用pthread_t数据类型来表示. 

线程获取自己线程ID的函数是pthread_self
#+BEGIN_SRC C
  #include <pthread.h>

  pthread_t pthread_self();
#+END_SRC

由于pthread_t的实现方式可能为结构体,因此需要使用专门的pthread_equal来比较两个pthread_t是否相等.
#+BEGIN_SRC C
  #include <pthread.h>

  /* 若相等返回非0,否则返回0 */
  int pthread_equal(pthread_t tid1,pthread_t tid2);
#+END_SRC

*用结构表示pthread_t数据类型的一个不好的后果是:不能用一种可移植的方式打印该数据类型的值*
** 一组寄存器值
** 栈
** 调度优先级
** 策略
** 信号屏蔽字
** errno变量
** 线程私有数据
* 线程的创建
** pthread_create
#+BEGIN_SRC C
  #include <pthread.h>

  /* 成功返回0,否则返回错误编号 */
  int pthread_create(pthread_t* tidp,const pthread_attr_t* attr,void* (*start_rtn)(void*),void* arg)
#+END_SRC
+ tidp所指向的pthread_t数据结构被设置为新创建线程的线程ID
+ attr参数指定新线程的属性,NULL表示默认属性
+ start_rtn函数指针指明了新线程调用哪个函数,该函数只有一个void*参数arg,因此若需要向start_rtn函数传递的参数不止一个,则需要 *把参数放到一个结构中*.
+ 新创建的线程继承调用线程的浮点环境和信号屏蔽字, *但该线程的未决信号集被清除*
+ 由于可能在主线程的pthread_create函数返回前就运行新线程了,因此在新线程中不能安全的使用tidp的值.
