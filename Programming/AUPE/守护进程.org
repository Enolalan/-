#+TITLE: 守护进程
#+AUTHOR: DarkSun
#+CATEGORY: Programming, AUPE
#+DATE: [2015-06-02 周二 11:32]
#+OPTIONS: ^:{}

* 守护进程的特点
+ *大多数* 守护进程以超级用户特权运行
+ 守护进程不具有控制终端
+ 所有用户层守护进程都是进程组的组长进程以及会话的首进程,且是这些进程组和会话中的唯一进程
+ *大多数* 守护进程的父进程为init进程

* 编写守护进程的基本规则
编写守护进程需要遵循一些基本规则,以防止产生并不需要的交互作用.
1. 调用umask将文件模式创建屏蔽字设置为0.

   这样做的目的是为了防止继承得来的文件模式创建屏蔽字在创建文件时会拒绝设置某些权限

2. 调用fork

   这样作的目的是:子进程不是一个进程组的组长进程,这为下面执行setsid创建新会话创建条件

3. (子进程)调用setsid以创建一个新会话.

   这使得进程(a)成为新会话的首进程. (b)成为新进程组的组长进程. (3)没有控制终端与之相连

4. 继续fork出孙进程作为守护进程,并退出子进程.

   这样做的目的是(a)孙进程的父进程变为init进程. (b)孙进程不是会话首进程,这就阻止了它取得控制终端(*只有会话首进程长才有权利打开一个控制终端*)

5. 更改守护进程的当前目录

   由于守护进程一般在系统重启之前都是存在的,它会占着当前目录无法被被卸载. 因此一般会将守护进程的当前目录更改为一直不会被卸载的目录,比如根目录

6. 关闭不必要的文件描述符

7. 将stdin,stdout,stderr重定向到/dev/null

   守护进程不应该在终端上有任何输入/输出信息,因此一般用dup函数将stdin,stdout,stderr重定向到/dev/null. 这样任何一个试图读标准输入,写标准输出和标准出错的函数都不会有任何效果.

* 编写守护进程的惯例
+ 若守护进程使用锁文件(*可以保证只有一个守护进程副本运行*),那么该文件通常存放在`/var/run'目录下,且名称通常为`守护进程或服务名称.pid'. 例如cron守护进程额锁文件为`/var/run/crond.pid'

+ 若守护进程支持配置文件,那么配置文件通常存放在`/etc'目录中.且名称格式为`守护进程或服务名字.conf'

+ 守护进程通常在启动时或捕捉到SIGHUP信号时会读取配置文件. 其他时候一般不会再读取配置文件信息.

+ 守护进程可以用命令启动,但一般由系统初始化脚本启动
