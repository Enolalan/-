#+TITLE: 文件IO
#+AUTHOR: DarkSun
#+CATEGORY: AUPE
#+DATE: [2015-05-13 周三 16:36]
#+OPTIONS: ^:{}

* 文件共享
** 内核是如何表示打开的文件的?
内核使用三种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响.
+ 每个进程在进程表中都有一个记录项,记录项中包含有一张打开文件描述符的表. 

  每个文件描述符符与一个指向文件表项的指针相关联. 而文件表项保持在内核中

+ 内核为所有打开的文件维护一张文件表. 其中每个文件表项包括:

  - 文件状态标志(读,写,添写,同步,非阻塞...)

  - 当前文件偏移量

  - 指向表示该文件的v节点表项的指针

+ 每个打开的文件(或设备)都有一个v节点结构.
  
  v节点包含了文件类型和对此文件进行各种操作的函数的指针.

  对于大多数文件,v节点还包含了该文件的i节点信息.

** 当多个进程打开同一个文件时,发生了什么?
一般来说,多个进程打开同一个文件时,会分别在不同的文件描述符上打开该文件. 不同的文件描述符指向不同的文件表项. 但不同的文件表项指向了同一个v节点.

即,每个文件都有自己独立的文件描述符和文件表项,但共用同一个文件v节点.

但当使用dup函数或fork时,也可能出现多个文件描述符项指向同一个文件表项

** 多个进程打开同一个文件带来的影响是什么?
多个进程读取同一个文件时,由于各个进程都由自己的文件表项,也就有自己的当前文件偏移符,因此多个进程读取同一个文件时很正常.

但当多个进程写入同一个文件时,由于各自不同的文件偏移符,所以可能出现写入内容相互覆盖的情况.

解决多个进程写入同一个文件的一个方法是,在打开文件时设置O_APPEND标志. 这种情况下,内核每次对该文件进行写之前,都将该进程的当前偏移量设置到文件的尾端.

XSI扩展还定义了pread和pwrite函数用于将定位搜索和执行IO统一为一个原子操作:
#+BEGIN_SRC c
  #include <unistd.h>

  /* 先lseek到offset处,然后读取文件内容 */
  ssize_t pread(int filedes,void* buf,size_t n,off_t offset);

  /* 先lseek到offset处,然后写入buf内容 */
  ssize_t pwrite(int filedes,const void* buf,size_t n,off_t offset);
#+END_SRC

** dup和dup2函数
可以用dup和dup2函数来复制一个现存的文件描述符,复制出来的文件描述符与原文件描述符共享同一个文件表项,即它们共享同一个文件标志状态及文件偏移量:
#+BEGIN_SRC c++
  #include <unistd.h>

  // dup返回的新文件描述符是当前可用文件描述符的最小数值
  int dup(int filedes);

  // dup2可以用filedes2参数指定新描述符的数值.
  // 如果filedes2已经打开,则先关闭它.
  // 如果filedes == filedes2,则dup2直接返回filedes2,而不关闭它
  int dup2(int filedes,int filedes2);
#+END_SRC

除了dup和dup2外,也可以使用fcntl函数来复制描述符.
#+BEGIN_SRC c++
  dup(filedes);
  // 类似于
  fcntl(filedes,F_DUPFD,0);

  dup2(filedes,filedes2);
  // 类似于
  close(filedes2);fcntl(filedes,F_DUPFD,filedes2);
#+END_SRC

* sync,fsync和fdatasync
传统UNIX实现在内核中设置了缓冲区,当数据写入文件时,内核现将数据复制到一个缓冲区中,而不立即将其排入输出队列.

UNIX系统提供了sync,fsync和fdatasync三个函数用于通知内核将数据立即排入输出队列中:
#+BEGIN_SRC c
  #include <unistd.h>

  /* 将filedes指定的文件内容写入磁盘,该函数等待写磁盘操作结束后才返回,并同步更新文件属性 */
  int fsync(int filedes);

  /* 类似fsync,但不更新文件属性 */
  int fdatasync(int filedes);

  /* sync只是将所有修改过的块缓冲区排入写队列,然后就返回,而并等待实际写磁盘操作结束 */
  void sync(void)
#+END_SRC
