#+TITLE: 文件IO
#+AUTHOR: DarkSun
#+CATEGORY: AUPE
#+DATE: [2015-05-13 周三 16:36]
#+OPTIONS: ^:{}

* 基本文件IO操作函数
** open函数
** create函数
** close函数
** lseek函数
** read函数
** write函数
* 文件共享
** 内核是如何表示打开的文件的?
内核使用三种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响.
+ 每个进程在进程表中都有一个记录项,记录项中包含有一张打开文件描述符的表. 

  每个文件描述符符与一个指向文件表项的指针相关联. 而文件表项保持在内核中

+ 内核为所有打开的文件维护一张文件表. 其中每个文件表项包括:

  - 文件状态标志(读,写,添写,同步,非阻塞...)

  - 当前文件偏移量

  - 指向表示该文件的v节点表项的指针

+ 每个打开的文件(或设备)都有一个v节点结构.
  
  v节点包含了文件类型和对此文件进行各种操作的函数的指针.

  对于大多数文件,v节点还包含了该文件的i节点信息.

** 当多个进程打开同一个文件时,发生了什么?
一般来说,多个进程打开同一个文件时,会分别在不同的文件描述符上打开该文件. 不同的文件描述符指向不同的文件表项. 但不同的文件表项指向了同一个v节点.

即,每个文件都有自己独立的文件描述符和文件表项,但共用同一个文件v节点.

但当使用dup函数或fork时,也可能出现多个文件描述符项指向同一个文件表项

** 多个进程打开同一个文件带来的影响是什么?
多个进程读取同一个文件时,由于各个进程都由自己的文件表项,也就有自己的当前文件偏移符,因此多个进程读取同一个文件时很正常.

但当多个进程写入同一个文件时,由于各自不同的文件偏移符,所以可能出现写入内容相互覆盖的情况.

解决多个进程写入同一个文件的一个方法是,在打开文件时设置O_APPEND标志. 这种情况下,内核每次对该文件进行写之前,都将该进程的当前偏移量设置到文件的尾端.

XSI扩展还定义了pread和pwrite函数用于将定位搜索和执行IO统一为一个原子操作:
#+BEGIN_SRC c
  #include <unistd.h>

  /* 先lseek到offset处,然后读取文件内容 */
  ssize_t pread(int filedes,void* buf,size_t n,off_t offset);

  /* 先lseek到offset处,然后写入buf内容 */
  ssize_t pwrite(int filedes,const void* buf,size_t n,off_t offset);
#+END_SRC

** dup和dup2函数
可以用dup和dup2函数来复制一个现存的文件描述符,复制出来的文件描述符与原文件描述符共享同一个文件表项,即它们共享同一个文件标志状态及文件偏移量:
#+BEGIN_SRC c++
  #include <unistd.h>

  // dup返回的新文件描述符是当前可用文件描述符的最小数值
  int dup(int filedes);

  // dup2可以用filedes2参数指定新描述符的数值.
  // 如果filedes2已经打开,则先关闭它.
  // 如果filedes == filedes2,则dup2直接返回filedes2,而不关闭它
  int dup2(int filedes,int filedes2);
#+END_SRC

除了dup和dup2外,也可以使用fcntl函数来复制描述符.
#+BEGIN_SRC c++
  dup(filedes);
  // 类似于
  fcntl(filedes,F_DUPFD,0);

  dup2(filedes,filedes2);
  // 类似于
  close(filedes2);fcntl(filedes,F_DUPFD,filedes2);
#+END_SRC

* sync,fsync和fdatasync
传统UNIX实现在内核中设置了缓冲区,当数据写入文件时,内核现将数据复制到一个缓冲区中,而不立即将其排入输出队列.

UNIX系统提供了sync,fsync和fdatasync三个函数用于通知内核将数据立即排入输出队列中:
#+BEGIN_SRC c
  #include <unistd.h>

  /* 将filedes指定的文件内容写入磁盘,该函数等待写磁盘操作结束后才返回,并同步更新文件属性 */
  int fsync(int filedes);

  /* 类似fsync,但不更新文件属性 */
  int fdatasync(int filedes);

  /* sync只是将所有修改过的块缓冲区排入写队列,然后就返回,而并等待实际写磁盘操作结束 */
  void sync(void)
#+END_SRC

* fcntl函数
fcntl函数可以改变已打开的文件属性,该函数常用于修改由shell代为打开的文件描述符的属性.
#+BEGIN_SRC c
  #include <fcntl.h>

  int fcntl(int filedes,int cmd);
  int fcntl(int filedes,int cmd,long arg);
  int fcntl(int filedes,int cmd,struct flock* lock);

  struct flock
  {
    short int l_type;             /* 锁类型:F_RDLCK,F_WRLCK,F_UNLCK */
    short int l_whence;           /* 决定l_start的位置:SEEK_SET,SEEK_CUR,SEEK_END */
    off_t l_start;                /* 锁定区域的开头位置 */
    off_t l_len;                  /* 锁定区域的大小 */
    pid_t l_pid;                  /* 锁定操作的进程 */
  }
#+END_SRC

其中fcntl支持的cmd操作有:
+ 复制一个现有的文件描述符(F_DUPFD)
+ 获得/设置文件描述符标记(F_GETFD/F_SETFD)
+ 获得/设置文件状态标记(F_GETFL/F_SETFL)
+ 获得/设置异步IO所有权(F_GETOWN/F_SETOWN)
+ 获得/设置记录锁(F_GETLK/F_SETLK/F_SETLKW)

* ioctl函数
每个驱动程序都定义了它自己的专门的一组ioctl命令,而系统提供一个统一的ioctl函数来调用这些专门的命令.
#+BEGIN_SRC c
  #include <unistd.h>             /* System V */
  #include <sys/ioctl.h>          /* BSD and Linux */
  #include <stropts.h>            /* XSI STREAMS */

  int ioctl(int filedes,int request,...);
#+END_SRC

* /dev/fd
新UNIX系统一般都提供了名为/dev/fd的目录,其中包含0,1,2等文件. 打开文件/dev/fd/n等效于复制描述符n.
#+BEGIN_SRC c
  fd = open("/dev/fd/n",mode);
  /* 等效于 */
  fd = dup(n);
#+END_SRC

/dev/fd的主要作用其实时提供给shell使用,它允许使用文件路径名为参数的程序也能处理标准输入输出
=======
** 参数filedes
filedes参数为待设置的文件描述符

** 参数cmd
cmd参数表示欲操作的指令
| F_DUPFD  | 寻找大于或等于参数arg的最小未使用文件描述符,并复制参数filedes的文件描述符,类似dup2的功能                         |
| F_GETFD  | 获取close-on-exec标志. 若标志为0,表示调用exec相关函数时文件不关闭                                                |
| F_SETFD  | 设置close-on-exec标志                                                                                            |
| F_GETFL  | 取得文件描述符状态标志,这个标志为open的flag参数                                                                  |
| F_SETFL  | 设置文件描述符的新状态标志. 但只运行修改 *O_APPEND,O_NONBLOCK,O_ASYNC*                                           |
| F_GETLK  | 取得文件锁状态                                                                                                   |
| F_SETLK  | 设置文件锁状态,其中flock.l_type必须是 *F_RDLCK,F_WRLCK或F_UNLCK*, 若无法锁定,则立即返回-1,errno为EACCESS或EAGAIN |
| F_SETLKW | 与F_SETLK类似,但若无法建立锁定,则该调用会一直阻塞至成功为止.                                                                            |
* 非阻塞IO
非阻塞IO使得我们在调用open,read和write这样的IO操作时,若操作不能完成,则直接返回错误提示,而不是阻塞.

** 指定非阻塞IO的方法
+ 调用open获得描述符时,指定`O_NONBLOCK'标志
+ 使用fcntl对 *已打开描述符* 修改O_NONBLOCK文件状态标志.

* 记录锁
所谓记录锁,更合适的术语应该叫`字节范围锁'. 它的功能是,当进程读取或修改文件的 *某个部分时*,阻止其他进程修改 *同一文件区域*.

** fcntl记录锁
#+BEGIN_SRC C
  #include <fcntl.h>

  int fcntl(int fieldes,int cmd,struct flock* lock);

  struct flock
  {
    short int l_type;             /* 锁类型:F_RDLCK(读锁),F_WRLCK(写锁),F_UNLCK(解锁) */
    short int l_whence;           /* 决定l_start的位置:SEEK_SET,SEEK_CUR,SEEK_END */
    off_t l_start;                /* 锁定区域的开头位置 */
    off_t l_len;                  /* 锁定区域的大小 */
    pid_t l_pid;                  /* 锁定操作的进程 */
  };
#+END_SRC
fcntl的锁分读锁和写所,其规则类似线程的rwlock,但它只能影响不同进程提出的锁请求.

如果一个进程对一个文件区间加了一把锁,后来该进程又在 *同一个文件区间* 再加锁,则 *新锁替代旧锁*

加读锁时,该文件描述符必须是读打开的. 加写锁时,该文件描述符是写打开的.

*在设置/释放文件上的锁时,系统会按要求组合或风儿锁区块*. 
例如:一开始对第100--199字节加了锁
若又对第150位字节解锁,则内核需要维持两个锁:100-149和151-199. 
若又对150位字节加锁,则系统又合并相邻的三个加锁区为一个区
*** cmd操作说明
fcntl中与记录锁相关的cmd操作是`F_GETLK',`F_SETLK',`F_SETLKW'. 且第三个参数为flock类型的指针
+ F_GETLK
  
  判断原lock参数描述的区域,是否有一把锁. (*但不能用于测试自己进程所加的锁*)

  锁信息会修改原lock参数. 

  若不存在锁则会将原lock参数中的l_type设为F_UNLCK,lock参数中的其他信息保存不变.

+ F_SETLK

  尝试加由参数lock所描述的锁,若无法加锁,则立即出错返回,且errno设置为EACCES或EAGAIN.

  若参数lock的l_type为F_UNLCK,则表示解锁

+ F_SETLKW

  这时F_SETLK的阻塞版本.


需要注意的是, *F_GETLK和F_SETLK/F_SETLKW两个调用之间完全有可能有另一个进程创建了相关锁*.
*** flock结构说明
+ flock结构中的l_type标明了锁的类型

+ 要加锁或解锁区域的起始字节偏移量由l_start和l_whence共同决定,类似于lseek函数

+ 起始字节偏移量 *可以为文件尾端或越过文件尾端,但不能在文件起始位置之前开始*

+ 加锁/解锁的字节长度由l_len表示,但0表示锁的区域 *无穷大*

+ 持有锁的进程由l_pid表示
** 关于锁的释放与继承
*** 锁的释放
+ 当进程终止时,该进程所建立的锁全部释放

+ 当关闭一个文件描述符时,所有与该文件描述符 *指向同一个文件* 的相关锁全部被释放. 即
  #+BEGIN_SRC C
    fd1 = open(pathname,...);
    fd2 = dup(fd1);                 /* fd1和fd2指向同一个文件 */
    close(fd2);                     /* 此时,fd1上设置的锁也会被释放 */


    fd1 = open(pathname,...);
    fd2 = open(pathname,...);       /* fd1和fd2也是指向同一个文件 */
    close(fd2);                     /* 此时,fd1上设置的锁也会被释放 */
  #+END_SRC
*** 锁的继承
+ fork产生的子进程不继承父进程所设置的锁.

  因为子进程已经是另一个进程了.

+ *执行exec后,进程继承原程序的锁*

  因此exec后,进程id没变.

  但若文件描述符设置了close-on-exec标志,则由于exec时会关闭文件标识符,因此对应文件的锁都会被释放
** 建议性锁和强制性锁
一个文件加锁时是使用建议性锁还是强制性锁,是由文件本身的权限决定的. 若文件打开了其设置组ID位并关闭了组的执行位,则表示文件开启的是强制性锁机制(之所以这样设计是因为当组执行位关闭时,设置组ID位不再有意义).

当使用建设性锁时,它无法阻止其他进程直接对文件进行读写. 它的实现有赖于其他进程在读写前自我的对锁进行检测.

而强制锁使内核对任何open,read和write系统调用进行检查. *但强制锁对unlink函数无影响!*
** flock文件锁
flock只能对锁定整个文件而无法锁定某个区域
#+BEGIN_SRC C
  #include <sys/file.h>

  int flock(int fd,int operatioon);
#+END_SRC
参数operatiion可以为:
+ LOCK_SH :: 共享锁
+ LOCK_EX :: 排它锁
+ LOCK_UN :: 解锁
+ LOCK_NB :: 无法加锁时,立即返回不阻塞.

*当使用dup()或fork()时,文件描述符不会继承这种锁定*
* IO多路转换
IO多路转换需要先构造一张描述符的列表,然后调用一个函数,该函数直到这些描述符中的一个已经准备好IO时,才返回.

poll,pselect和select这三个函数使得我们能够执行IO多路转换,并返回哪些描述符已经准备好进行IO了.
** select
传给select的参数告诉内核:
+ 我们关心哪些描述符
+ 对于每个描述符,我们所关心的条件是什么(想读?想写?发生异常条件?)
+ 原意等待多久(一直等待,等待某个时间段,不等待)

select返回时的到的消息包括:
+ 已准备好的描述符的总数量
+ 对于读,写或异常这3个条件中的每一个,分别有哪些描述符准备好了.

#+BEGIN_SRC C
  #include <sys/select.h>

  /* 返回准备就绪的描述符数目,若超时则返回0,若出错返回-1 */
  /* 若不同fd_set中包含同一个就绪的fd,则返回值会重复累加 */
  int select(int maxfdp,fd_set* readfds,fd_set* writefds,fd_set* exceptfds,struct timeval* tvptr);
#+END_SRC
*** 时间参数tvptr意义说明:
select函数等待tvptr时间,若时间内有描述符准备好则返回准备好描述符的数量. 若超时则返回0.

若捕捉到一个信号,则select返回-1,errno设置为EINTR.

tvptr == NULL表示无限等待.

*select返回后,有可能会修改tvptr表示超时时间未到期的剩余时间值*
*** fd_set数据类型说明
使用fd_set数据类型,唯一可进行的处理就是同类型之间的变量进行赋值,或者使用一下四个函数修改数据值
#+BEGIN_SRC C
  #include <sys/select.h>

  /* 判断fd是否在fd_set中 */
  int FD_ISSET(int fd,fd_set* fdset);

  /* 从fd_set中删除调fd */
  void FD_CLR(int fd,fd_set* fdset);

  /* 添加fd到fd_set中 */
  void FD_SET(int fd,fd_set* fdset);

  /* 清空fset */
  void FD_ZERO(fd_set* fdset);
#+END_SRC
*** fd_set*三个参数说明
select函数会修改各fd_set值,使得他们只保留准备好的fd.

*即使莫描述符上的文件指针已经到达尾部,但select依然认为该描述符是可读的,只不过read会返回0而已* (很多人错误第认为,当到达文件尾端时,select会指示一个异常条件)

fd_set*的参数值可以为NULL,表表示不关心响应条件

*三个指针可以都是NULL,则select提供了比sleep更精确的定时器(sleep精确到秒,select精确到微秒)*
*** 参数maxfdp说明
该参数一般为三个fd_set中最大fd的值+1(加1的原因在于描述符编号从0开始). 它的意义在于提供給select函数一个搜索fd的范围. 使得内核不用搜索fd_Set中数百个无用的fd.

一般<sys/select.h>中定义了一个常量FD_SETSIZE,该常量的值表示允许的最大描述符.
** pselect
#+BEGIN_SRC C
  #include <sys/select.h>

  /* 返回就绪的描述符总数,超时则返回0,出错则返回-1 */
  int pselect(int maxfdp,
              fd_set* readfds,
              fd_set* writefds,
              fd_set* exceptfds,
              const struct timespec*tsptr,
              const sigset_t* sigmask);

#+END_SRC

*** pselect与select的不同之处
+ select用timeval结构指定超时,而pselect用timespec结构指定超时. timespec能提供更精确的超时时间

+ pselect的超时值为const,这保证了pselect不会改变次值

+ 若参数sigmask为非NULL,则pselect可以原子操作的方式安装该信号屏蔽字,返回时恢复以前的信号屏蔽字.

** 函数poll
#+BEGIN_SRC C
  #include <poll.h>

  /* 返回准备就绪的描述符数目,若超时返回0,出错则返回-1 */
  int poll(struct pollfd fdarray[],nfds_t nfds,int timeout);
#+END_SRC
poll函数的作用类似select,但poll并不是为每个条件(读,写,异常)构造一个描述符集合. 

poll是构造一个pollfd结构的数组. 每个pollfd结构体指定了一个描述符编号以及我们对描述符感兴趣的条件
#+BEGIN_SRC C
  struct pollfd
  {
    int fd;                       /* 要检测的文件描述符 */
    short events;                 /* 关注文件描述符上的哪些事件 */
    short revents;                /* 函数返回时,被修改为该描述符发生了哪些事件 */
  }
#+END_SRC

*** poll中的事件说明
| 标志名     | 是否可设置为events | 是否可设置为revents | 说明                                 |
|------------+--------------------+---------------------+--------------------------------------|
| POLLIN     | 是                 | 是                  | 可以不阻塞地读高优先级数据以外的数据 |
| POLLRDNORM | 是                 | 是                  | 可以不阻塞地读普通数据               |
| POLLRDBAND | 是                 | 是                  | 可以不阻塞地读优先级数据             |
| POLLPRI    | 是                 | 是                  | 可以不阻塞地读高优先级数据           |
|------------+--------------------+---------------------+--------------------------------------|
| POLLOUT    | 是                 | 是                  | 可以不阻塞第写普通数据               |
| POLLWRNORM | 是                 | 是                  | 与POLLOUT相同                        |
| POLLWRBAND | 是                 | 是                  | 可以不阻塞第写优先级数据             |
|------------+--------------------+---------------------+--------------------------------------|
| POLLERR    | 否                 | 是                  | 已出错                               |
| POLLHUP    | 否                 | 是                  | 已挂断(制解调器被挂断)                    |
| POLLNVAL   | 否                 | 是                  | 描述符没有引用一个打开文件.                     |

*** timeout说明
+ timeout == -1表示一直等待
+ timeout == 0表示不等待
+ timeout > 0表示等待timeout *毫秒*

* 异步IO
