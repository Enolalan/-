#+TITLE: 信号
#+AUTHOR: DarkSun
#+CATEGORY: Programming, AUPE
#+DATE: [2015-05-22 周五 09:44]
#+OPTIONS: ^:{}

* 编号为0的信号
不存在编号为0的信号,kill函数对编号为0的信号有特殊处理. POSIX.1将这种信号称为空信号

* 信号的处理

有两种信号是不能忽略的,就是SIGKILL和SIGSTOP,因为进程收到这两个信号后必须终止或停止0运行.

* 不产生core文件的条件
1. 进度是设置用户ID的,但当前用户并非程序文件的所有者
2. 进程是设置组ID的,但当前用户组并非程序文件的组所有者
3. 用户没有写当前工作目录的权限,也就无法产生新的core文件
4. core文件已存在,且用户对该文件没有写权限,也就无法覆盖原core文件
5. core文件太大,超过了RLIMIT_CORE的限制

* 常用信号说明
| 信号      | 说明                                                                                                                                                                        |
|-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SIGABRT   | 调用abort函数产生的信号. 进程异常终止                                                                                                                                       |
| SIGALRM   | 函数alarm设置的计时器超时,或setitimer函数设置的间隔时间超时产生该信号                                                                                                       |
| SIGCHLD   | 子进程终止或停止时,发送该信号給父进程                                                                                                                                       |
| SIGCONT   | 该作业控制信号发送给处于停止状态的进程,让其继续运行                                                                                                                         |
| SIGFPE    | 算术运算异常                                                                                                                                                                |
| SIGHUP    | 终端接口检测到连接断开,会将该信号发送给该终端相关的会话首进程. 会话首进程关闭时也会发送该信号到该会话中的所有进程. 常用于使用该信号通知守护进程,以便重新读取它们的配置文件. |
| SIGINT    | 用户按下中断键(一般为C-c或DEL键)                                                                                                                                            |
| SIGIO     | 该信号指示一个异步IO事件                                                                                                                                                    |
| SIGKILL   | 该信号无法被捕捉,进程接收后必定终止                                                                                                                                         |
| SIGPIPE   | 写到管道时读进程已终止,则产生该信号. SOCK_STREAM的套接字不再连接时,进程写到该套接字也产生此信号                                                                             |
| SIGPOLL   | 在一个可轮询设备上发生特定事件时产生此信号                                                                                                                                  |
| SIGQUIT   | 用户在终端上按退出键(一般为C-\)                                                                                                                                             |
| SIGSEGV   | 进程进行了一次无效的内存引用                                                                                                                                                |
| SIGSTOP   | 这是一个作业控制进程,用于暂停一个进程. 类似于SIGTSTP信号,但不能被捕获或忽略                                                                                                 |
| SIGSYS    | 产生一个无效的系统调用                                                                                                                                                      |
| SIGTERM   | kill命令发送的系统默认终止信号                                                                                                                                              |
| SIGTSTP   | 交互式停止信号,当用户在终端上按挂起键(C-z)时产生,并发送至前台进程组中的 *所有进程*                                                                                          |
| SIGTTIN   | 当后台进程组中的进程试图读取控制终端时产生. 但若 *读取进程所属的进程组为孤儿进程组,此时操作返回出错,且errno为EIO*                                                           |
| SIGTTOU   | 当后台进程组中的进程试图写到其控制终端时产生. 若 *终端设置为不允许写且写进程所属进程组为孤儿进程组,则写操作返回出错,errnro为EIO*                                            |
| SIGURG    | 通知进程已发生一个紧急情况                                                                                                                                                  |
| SIGUSR1   | 用户自定义进程                                                                                                                                                              |
| SIGUSR2   | 用户自定义进程                                                                                                                                                              |
| SIGVTALRM | setitimer函数设置的虚拟间隔时间到期时产生此信号                                                                                                                             |
| SIGXCPU   | 进程超过其软CPU时间限制                                                                                                                                                     |
| SIGXFSZ   | 进程超过了其软文件长度限制                                                                                                                                                  |
|           |                                                                                                                                                                             |

* 注册信号处理函数
** signal
#+BEGIN_SRC C
  #include <signal.h>

  typedef void (*SIGN_HANDER_P)(int);

  /* signal函数的返回值是之前的信号处理函数指针,若失败,返回SIG_ERR */
  SIGN_HANDER_P signal(int signo,SIGN_HANDER_P func);
#+END_SRC
+ signal函数由ISO C定义. 因为ISO C不涉及多进程,进程组以及终端IO等,所以它对信号的定义非常模糊,以至于 *对UNIX系统而言几乎毫无用处*
+ signal的语义与实现有关,所以最好使用sigaction函数代替signal函数
+ 系统预先定义了SIG_IGN和SIG_DEF两个信号处理函数.
+ signal函数的一个缺陷在于,不改变信号的处理方式,就无法确定信号的当前处理方式.
* 不可靠的信号
早期UNIX中的信号是不可靠的,即信号可能会丢失
+ 当发生信号到调用信号处理函数之间又发生另一次中断信号,这时程序会转去执行第二个中断点的处理函数
+ 当信号发生时,进程只能选择立即处理该信号或忽略该信号, *而无法让内核暂时记录下该信号*
